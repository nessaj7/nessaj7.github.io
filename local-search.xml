<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java笔记——IO流</title>
    <link href="/2022/07/10/e50dfc354168.html"/>
    <url>/2022/07/10/e50dfc354168.html</url>
    
    <content type="html"><![CDATA[<h2 id="文件">文件</h2><p>文件是保存数据的地方</p><p>文件流：文件在程序中是以流的形式来操作的，流是指数据源(文件)和程序(<strong>内存</strong>)之间经历的路径</p><p>输入流：文件(磁盘) <span class="math inline">\(\rightarrow\)</span>Java程序(内存)</p><p>输出流：Java程序(内存) <spanclass="math inline">\(\rightarrow\)</span> 文件(磁盘)</p><h3 id="常用文件操作">常用文件操作</h3><ul><li>创建文件对象相关构造器和方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(String pathname) <span class="hljs-comment">// 根据路径构建一个File对象</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(File parent, String child) <span class="hljs-comment">// 根据父目录文件 + 子路径构建</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(String parent, String child) <span class="hljs-comment">// 根据父目录 + 子路径构建</span><br>  <br>file.createNewFile(); <span class="hljs-comment">// 写到磁盘</span><br></code></pre></td></tr></table></figure><ul><li>获取文件相关信息</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">getName<br>getAbsolutePath<br>getParent<br><span class="hljs-function"><span class="hljs-title">length</span><span class="hljs-params">()</span></span> <span class="hljs-comment">// 一个汉字3个字节</span><br>exists<br>isFile<br>isDirectory<br></code></pre></td></tr></table></figure><ul><li>目录的操作和文件删除</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//m</span>kdir创建一级目录、mkdirs创建多级目录、<span class="hljs-keyword">delete</span>删除空目录或文件<br>返回boolean<br>在java编程中，目录也被当做文件<br></code></pre></td></tr></table></figure><h3 id="io流原理及流的分类">IO流原理及流的分类</h3><figure><imgsrc="https://cdn.jsdelivr.net/gh/nessaj7/ImageHost/img/202207161900007.png"alt="io流概览" /><figcaption aria-hidden="true">io流概览</figcaption></figure><ul><li><p>Java IO 流原理</p><ol type="1"><li>I/O技术是非常实用的技术，用于处理数据传输。如读写文件，网络通讯等。</li><li>Java 程序中，对于数据的输入、输出操作以“流(stream)”的方式进行。</li><li><code>java.io</code>包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过方法输入或输出数据</li></ol></li><li><p>流的分类</p><ul><li>按<em>操作数据</em>单位不同分为：字节流(8bit)二进制文件，字符流(按字符)文本文件（一个汉字3个字节）</li><li>按<em>数据流的流向</em>不同分为：输入流，输出流</li><li>按流的<em>角色</em>的不同分为：节点流，处理流/包装流</li></ul></li></ul><table><thead><tr class="header"><th style="text-align: center;">（抽象基类）</th><th style="text-align: center;">字节流</th><th style="text-align: center;">字符流</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">输入流</td><td style="text-align: center;"><code>InputStream</code></td><td style="text-align: center;"><code>Reader</code></td></tr><tr class="even"><td style="text-align: center;">输出流</td><td style="text-align: center;"><code>OutputStream</code></td><td style="text-align: center;"><code>Writer</code></td></tr></tbody></table><p>Java 的 IO流共涉及40多个类，实际上非常规则，都是如上4个<strong>抽象基类</strong>派生的，由这四个类派生出来的子类名称都是以其父类名作为子类名前缀。</p><h2 id="inputstream-字节输入流">InputStream 字节输入流</h2><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">InputStream抽象类是所有 类字节输入流 的超类</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">InputStream常用子类</span><span class="hljs-punctuation">:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">FileInputStream：文件输入流</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">BufferedInputStream：缓存字节输入流 （直接父类FilterInputStream）</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">ObjectInputStream：对象字节输入流</span><br></code></pre></td></tr></table></figure><h3 id="fileinputstream">FileInputStream</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">构造器<br><span class="hljs-function"><span class="hljs-title">FileInputStream</span><span class="hljs-params">(File file)</span></span><br><span class="hljs-function"><span class="hljs-title">FileInputStream</span><span class="hljs-params">(FileDescriptor fdObj)</span></span><br><span class="hljs-function"><span class="hljs-title">FileInputStream</span><span class="hljs-params">(String name)</span></span>  <span class="hljs-comment">// 指定路径</span><br><br>方法<br><span class="hljs-function"><span class="hljs-title">read</span><span class="hljs-params">()</span></span> 从此输入流中读取一个数据字节<br><span class="hljs-function"><span class="hljs-title">read</span><span class="hljs-params">(byte[] b)</span></span> 从此输入流中将最多<span class="hljs-selector-tag">b</span>.length个字节的数据读入一个byte数组中<br><span class="hljs-function"><span class="hljs-title">close</span><span class="hljs-params">()</span></span> 关闭此文件输入流并释放于此流有关的所有系统资源<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile01</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">readDate</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        fileInputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;./hhh.txt&quot;</span>);<br>        <span class="hljs-keyword">while</span> ((readDate = fileInputStream.read()) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.print((<span class="hljs-type">char</span>)readDate);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fileInputStream.close(); <span class="hljs-comment">// 关闭流</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile02</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">readLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">9</span>];  <span class="hljs-comment">// 一次读9个字节</span><br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        fileInputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;./hhh.txt&quot;</span>);<br>        <span class="hljs-keyword">while</span> ((readLen = fileInputStream.read(b)) != -<span class="hljs-number">1</span>) &#123;<br>            System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(b, <span class="hljs-number">0</span>, readLen)); <span class="hljs-comment">// char[]转String输出</span><br>        &#125;<br><br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fileInputStream.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="fileoutputstream">FileOutputStream</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">构造器<br><span class="hljs-function"><span class="hljs-title">FileOutputStream</span><span class="hljs-params">(File file)</span></span><br><span class="hljs-function"><span class="hljs-title">FileOutputStream</span><span class="hljs-params">(String name, boolean append)</span></span> <span class="hljs-comment">// 追加</span><br><br>方法<br><span class="hljs-function"><span class="hljs-title">write</span><span class="hljs-params">(byte[] b)</span></span><br><span class="hljs-function"><span class="hljs-title">write</span><span class="hljs-params">(byte[] b, int off, int len)</span></span> <span class="hljs-comment">// off表示偏移量，即启示位置</span><br><span class="hljs-function"><span class="hljs-title">write</span><span class="hljs-params">(int b)</span></span> <span class="hljs-comment">// 将指定的字节写入此文件输出流</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, world!&quot;</span>;<br>fileOutputStream.write(str.getBytes());<br></code></pre></td></tr></table></figure><p>文件拷贝 = 输入流 + 输出流</p><h2 id="filereader-和-filewriter">FileReader 和 FileWriter</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">FileReader 和 FileWriter 是字符流，即按照字符来操作io<br><br>FileReader方法 （直接父类InputStreamReader, 父类的父类Reader）<br> <span class="hljs-keyword">new</span> <span class="hljs-constructor">FileReader(File<span class="hljs-operator">/</span>String)</span><br> read<span class="hljs-literal">()</span>  <span class="hljs-comment">// 每次读取一个字符，返回该字符，如果读到文件末尾返回-1</span><br> read(<span class="hljs-built_in">char</span><span class="hljs-literal">[]</span>) <span class="hljs-comment">// 批量读取多个字符到数组，返回读取的字符数</span><br> <span class="hljs-keyword">new</span> <span class="hljs-constructor">String(<span class="hljs-params">char</span>[])</span>  <span class="hljs-comment">// 将char[] 转成String</span><br> <span class="hljs-keyword">new</span> <span class="hljs-constructor">String(<span class="hljs-params">char</span>[], <span class="hljs-params">off</span>, <span class="hljs-params">len</span>)</span><br> <br>FileWriter方法 (直接父类OutputStreamWriter, 父类的父类Writer)<br> <span class="hljs-keyword">new</span> <span class="hljs-constructor">FileWriter(File<span class="hljs-operator">/</span>String)</span> <span class="hljs-comment">// 覆盖写入</span><br> <span class="hljs-keyword">new</span> <span class="hljs-constructor">FileWriter(File<span class="hljs-operator">/</span>String, <span class="hljs-params">true</span>)</span> <span class="hljs-comment">// 追加写入</span><br> write(<span class="hljs-built_in">int</span>/<span class="hljs-built_in">char</span><span class="hljs-literal">[]</span>/<span class="hljs-built_in">string</span>)<br> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span> <span class="hljs-comment">// 将String转换成char[]</span><br> 注意：FileWriter使用后必须close或flush, 否则写入不到指定文件！<br></code></pre></td></tr></table></figure><h2 id="节点流和处理流">节点流和处理流</h2><ol type="1"><li>节点流可以从一个<strong>特定的数据源</strong>读取数据，如<code>FileReader</code>、 <code>FileWriter</code></li><li>处理流也叫<strong>包装流</strong>，是连接在已存在的流（节点流或处理流）之上，为程序提供更为强大的读取功能，如<code>BufferedReader</code>、<code>BufferedWriter</code></li></ol><p><code>BufferedReader</code> 是 <code>Reader</code> 的子类，有属性<code>private Reader in;</code>，即可以封装一个节点流，该节点流可以是任意的，只要是 <code>Reader</code>的子类；同理 <code>BufferedWriter</code> 也一样。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/nessaj7/ImageHost/img/202207161905005.png"alt="节点流和处理流" /><figcaption aria-hidden="true">节点流和处理流</figcaption></figure><h3 id="区别与联系">区别与联系</h3><ol type="1"><li>节点流是底层流/低级流，直接跟数据源相接。</li><li>处理流包装节点流既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出。</li><li>处理流对节点流进行包装，使用了<strong>修饰器设计模式</strong>，不会直接与数据源相连</li></ol><p>处理流的功能主要体现在：</p><ol type="1"><li>性能的提高：主要以增加缓冲的方式来提高输入输出的效率</li><li>操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加灵活方便</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company.file;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedReader_</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">BufferReader_</span> <span class="hljs-variable">bufferReader_</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferReader_</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader_</span>());<br><span class="hljs-comment">//        bufferReader_.readFiles(4);</span><br>        bufferReader_.readFile();<br>        <span class="hljs-type">BufferReader_</span> <span class="hljs-variable">bufferReader_1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferReader_</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringReader_</span>());<br><span class="hljs-comment">//        bufferReader_1.readStrings(3);</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reader_</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fileRead</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stringRead</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReader_</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reader_</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fileRead</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;读取文件~~~&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringReader_</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reader_</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stringRead</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;读取字符串~~~&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferReader_</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reader_</span> &#123;<br>    <span class="hljs-keyword">private</span> Reader_ reader_;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BufferReader_</span><span class="hljs-params">(Reader_ reader_)</span> &#123;  <span class="hljs-comment">// 构造器</span><br>        <span class="hljs-built_in">this</span>.reader_ = reader_;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">// 封装一层</span><br>        reader_.fileRead();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFiles</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123; <span class="hljs-comment">// 多次读取文件，或者加缓冲byte[]</span><br>        <span class="hljs-keyword">while</span> (num-- != <span class="hljs-number">0</span>) &#123;<br>            reader_.fileRead(); <span class="hljs-comment">// 动态绑定</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readStrings</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">while</span> (num -- != <span class="hljs-number">0</span>) &#123;<br>            reader_.stringRead();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="处理流-bufferedreader-和-bufferedwriter">处理流 BufferedReader和 BufferedWriter</h3><p><code>BufferedReader</code> 和 <code>BufferedWriter</code>属于字符流，是按照字符来读取数据的，关闭时，只需要关闭外层流即可。不要去操作二进制文件(音频,视频, pdf, doc)，可能造成文件损坏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>());<br>String line;<br><span class="hljs-keyword">while</span> ((line = bufferedReader.readLine()) != <span class="hljs-literal">null</span>) <span class="hljs-comment">// 按行读取，当返回null，表示文件读取完毕</span><br>    System.out.println(line);<br><span class="hljs-comment">// 关闭流，只需要关闭Bufferedreader, 因为底层会自动去关闭节点流FileReader</span><br>bufferedReader.close();<br><br><span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;./ok.txt&quot;</span>));<br>bw.write(<span class="hljs-string">&quot;hello, world!&quot;</span>);<br>bw.newLine();<br>bw.write(<span class="hljs-string">&quot;hello, java!&quot;</span>);<br>bw.newLine();<br>bw.close();<br></code></pre></td></tr></table></figure><h3 id="处理流-bufferedinputstream-和-bufferedoutputstream">处理流BufferedInputStream 和 BufferedOutputStream</h3><p><code>BufferedInputtStream</code> 是<strong>字节流</strong>，在创建<code>BufferedInputStream</code> 时，会创建一个内部缓存区数组。<code>BufferedOutputStream</code>也是<strong>字节流</strong>，实现缓冲的输出流，可以将多个字节写入底层输出流中，而不必对每个字节写入调用底层系统。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字节流拷贝</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedCopy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">readLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">try</span> &#123;<br>            bis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;./demo.png&quot;</span>));<br>            bos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;./tmp/demo1.png&quot;</span>));<br>            <span class="hljs-keyword">while</span> ((readLen = bis.read(b)) != -<span class="hljs-number">1</span>) &#123;<br>                bos.write(b, <span class="hljs-number">0</span>, readLen);<br>            &#125;<br>            <br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (bis != <span class="hljs-literal">null</span>) &#123;<br>                bis.close();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (bos != <span class="hljs-literal">null</span>) &#123;<br>                bos.close();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对象处理流-objectinputstream和objectoutputstream">对象处理流ObjectInputStream和ObjectOutputStream</h3><p>能够将<strong>基本数据类型</strong>或者<strong>对象</strong>进行序列化和反序列化操作，<code>ObjectInputStream</code>提供反序列化功能，<code>ObjectOutputStream</code> 提供序列化功能。</p><ol type="1"><li>序列化就是在保存数据时，保存数据的值和数据类型</li><li>反序列化就是在恢复数据时，恢复数据的值和数据类型</li><li>需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Serializable <span class="hljs-comment">// 这是一个标记接口</span><br>Externalizable <span class="hljs-comment">// 继承自Serializable</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">writeInt()<br>writeBoolean()<br>writeChar()<br>writeDouble()<br>writeUTF(<span class="hljs-string">&quot;你好&quot;</span>)<br>oos.writeObject(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;kimi&quot;</span>));<br><br><span class="hljs-comment">// 读取(反序列化)顺序要和保存(序列化)数据顺序一致</span><br>...<br><span class="hljs-comment">// dog的编译类型是Object, 运行类型是Dog</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> ois.readObject();<br><span class="hljs-comment">// 如果希望调用Dog的方法，需要向下转型(要保证Dog类的定义可被引用)</span><br><span class="hljs-type">Dog</span> <span class="hljs-variable">dog2</span> <span class="hljs-operator">=</span> (Dog)dog;<br>dog2.getName();<br></code></pre></td></tr></table></figure><p>注意事项：</p><ol type="1"><li>读写顺序要一致</li><li>要求序列化或反序列化对象,需要实现 <code>Serializable</code></li><li>序列化的类中建议添加<code>SerialVersionUID</code>,为了提高版本的兼容性</li><li>序列化对象时，默认将里面所有属性都进行序列化，但除了<code>static</code> 或 <code>transient</code> 修饰的成员</li><li>序列化对象时，要求里面属性的类型也需要实现序列化接口</li><li>序列化具备可继承性，也就是如果某类已经实现了序列化，则它的所有子类也已经默认实现了序列化</li></ol><h3 id="标准输入输出流">标准输入输出流</h3><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">编译类型</th><th style="text-align: center;">运行类型</th><th style="text-align: center;">默认设备</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>System.in</code></td><td style="text-align: center;"><code>InputStream</code></td><td style="text-align: center;"><code>BufferedInputStream</code></td><td style="text-align: center;">键盘</td></tr><tr class="even"><td style="text-align: center;"><code>System.out</code></td><td style="text-align: center;"><code>PrintStream</code></td><td style="text-align: center;"><code>PrintStream</code></td><td style="text-align: center;">显示器</td></tr></tbody></table><h3 id="转换流-inputstreamreader和outputstreamwriter">转换流InputStreamReader和OutputStreamWriter</h3><p>字节流转成字符流：解决文件乱码问题</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">InputStreamReader</span><span class="hljs-params">(InputStream, Charset)</span></span> <span class="hljs-comment">//指定编码方式</span><br><span class="hljs-function"><span class="hljs-title">OutputStreamReader</span><span class="hljs-params">(OutputStream, Charset)</span></span> <br></code></pre></td></tr></table></figure><ol type="1"><li><code>InputStreamReader</code>: <code>Reader</code> 的子类，可以将<code>InputStream</code> (字节流)包 装成Reader(字符流)</li><li><code>OutputStreamWriter</code>: <code>Writer</code> 的子类，实现将<code>OutputStream</code> (字节流) 包装成<code>Writer</code>(字符流)</li><li>当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题，所以建议将字节流转换成字符流</li><li>可以在使用时指定编码格式(比如utf 8, gbk，gb2312, IS08859-1等)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath), <span class="hljs-string">&quot;gbk&quot;</span>); <span class="hljs-comment">// 转换流</span><br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(isr); <span class="hljs-comment">// 包装一次，让效率更高</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> br.readLine();<br>System.out.println(<span class="hljs-string">&quot;读取内容: &quot;</span> + s);<br>br.close();<br><br><span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;./tmmp.txt&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">charSet</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;utf-8&quot;</span>;<br><span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">osw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath), charSet));<br>osw.write(<span class="hljs-string">&quot;你好&quot;</span>);<br>osw.close();<br></code></pre></td></tr></table></figure><h3 id="打印流-printstream和printwriter">打印流PrintStream和PrintWriter</h3><p>打印流只有输出流，没有输入流</p><p>字节流 <code>PrintStream</code> 的父类<code>OutputStream</code>，字符流 <code>PrintWriter</code> 的父类<code>Writer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PrintStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> System.out; <span class="hljs-comment">// 默认输出位置显示器</span><br>out.print(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// print的底层是write</span><br><span class="hljs-comment">// out.write(&quot;hello&quot;.getByte());</span><br>out.close();<br><br>System.setOut(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(<span class="hljs-string">&quot;./tmp.txt&quot;</span>)); <span class="hljs-comment">//重定向输出设备到文件</span><br>System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>); <span class="hljs-comment">// 写入内容</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PrintWriter pw = new PrintWriter(System.out);</span><br><span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;./tmp.txt&quot;</span>));<br>pw.print(<span class="hljs-string">&quot;hello, world&quot;</span>);<br>pw.close(); <span class="hljs-comment">// 没关闭无法刷新写入</span><br></code></pre></td></tr></table></figure><h2 id="properties-类">Properties 类</h2><p>配置文件的读取和写入</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">1. 专门用于读写配置文件的集合类 （Hashtable的子类）</span><br><span class="hljs-attribute">  格式：键=值 （键值对不需要有空格，值不需要用引号引起来，默认类型是String）</span><br><span class="hljs-attribute">2. 常见方法</span><br><span class="hljs-attribute"> load</span><span class="hljs-punctuation">:</span> <span class="hljs-string">加载配置文件的键值对到Properties对象</span><br> <span class="hljs-attribute">list</span><span class="hljs-punctuation">:</span> <span class="hljs-string">将数据显示到指定设备/流对象</span><br> <span class="hljs-attribute">getProperty(key)</span><span class="hljs-punctuation">:</span> <span class="hljs-string">根据键获取值</span><br> <span class="hljs-attribute">setProperty(key, value)</span><span class="hljs-punctuation">:</span> <span class="hljs-string">设置键值对到Properties对象</span><br> <span class="hljs-attribute">store</span><span class="hljs-punctuation">:</span> <span class="hljs-string">将Properties中的键值对存储到配置文件 (中文unicode)</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建Properties对象</span><br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Peoperties</span>();<br><span class="hljs-comment">// 2. 加载指定配置文件</span><br>properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;./sql.properties&quot;</span>));<br><span class="hljs-comment">// 3. 把k-v显示控制台</span><br>properties.list(System.out);<br><span class="hljs-comment">// 4. 根据k获取v</span><br>properties.getProperty(xxx);<br><br><span class="hljs-comment">// 5. 创建键值对</span><br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Peoperties</span>();<br>properties1.setProperty(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;kuhn&quot;</span>);<br><span class="hljs-comment">// 6. 保存</span><br>properties1.store(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;./mysql.properties&quot;</span>), <span class="hljs-string">&quot;注解&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>IO流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法模板Part Four - 数论</title>
    <link href="/2022/07/06/358e5a67e7ff.html"/>
    <url>/2022/07/06/358e5a67e7ff.html</url>
    
    <content type="html"><![CDATA[<h1 id="数论">数论</h1><h2 id="质数">质数</h2><p>质数是指在<strong>大于1</strong>的自然数中，除了1和它本身以外不再有其他因数的自然数。<span id="more"></span></p><h3 id="试除法判定质数">试除法判定质数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i ++ )<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优化</strong>: 若$ d|n $，则 $ {n d} | n $。 $ d n d$ ，<spanclass="math inline">\(d^2 \leq n\)</span> ，枚举到 <spanclass="math inline">\(d \leq \sqrt n\)</span></p><p>细节：<code>i * i</code> 有溢出风险，<code>i &lt;= n / i</code>这样写比较好。</p><p>时间复杂度： <span class="math inline">\(O(\sqrt n)\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i ++ )<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分解质因数">分解质因数</h3><p><span class="math display">\[n = p_1^{x_1} \times p_2^{x_2} \times \dots \times p_k^{x_k}\]</span></p><p>从小到大枚举所有数，若能整除就继续除。</p><p>细节：合数会被素数筛掉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <span class="hljs-comment">// i一定是质数</span><br>    &#123;<br>        <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            n /= i;<br>            s ++ ;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, i, s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优化</strong>：n中最多只包含一个大于 <spanclass="math inline">\(\sqrt n\)</span> 的质因子</p><p>时间复杂度：最慢 <span class="math inline">\(O(\sqrtn)\)</span>，最快 <span class="math inline">\(O(\log n)\)</span>，如<span class="math inline">\(n = 2^k\)</span> 时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i ++ )<br>    <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <span class="hljs-comment">// i一定是质数</span><br>    &#123;<br>        <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            n /= i;<br>            s ++ ;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, i, s);<br>    &#125;<br><br><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, n, <span class="hljs-number">1</span>); <span class="hljs-comment">// 单独处理最后一个数</span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="筛质数">筛质数</h3><p>先把从2开始到n的所有的数写到一个数表里，从前往后把每个数的倍数删掉。对于p而已，若它没被删掉，则说明2~p-1都不是其因子，故p是质数。</p><p>时间复杂度：<span class="math inline">\(O(n \log n)\)</span></p><p>i = 2，循环了 <span class="math inline">\(\frac n 2\)</span> 次； i=3， 循环了 <span class="math inline">\(\frac n 3\)</span> 次； ... <spanclass="math display">\[\frac n 2 + \frac n 3 + \dots + \frac n k = n(\frac 1 2 + \dots + \frac1 k) = n \ln n\]</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> primes[N], cnt;<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i])<br>        &#123;<br>            primes[cnt ++ ] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + i; j &lt;= n; j += i) st[j] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// true标记删除</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="埃氏筛法">埃氏筛法</h4><p>优化：并不需要把每个数的倍数删掉，只需要把质数的所有倍数删掉，2~p-1中的质数判断是不是p的约数即可。合数都可以通过比它小的质数表示出来，筛了质数的倍数自然而然合数也就被筛掉了。</p><p>质数定理：1~n中有 <span class="math inline">\(\frac n {\lnn}\)</span> 个质数</p><p>时间复杂度： <span class="math inline">\(O(n \log\log n)\)</span>例如<span class="math inline">\(n = 2^{32}\)</span> , <spanclass="math inline">\(\log {\log n} = 5\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> primes[N], cnt; <span class="hljs-comment">// cnt记录质数的个数</span><br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i])<br>        &#123;<br>            primes[cnt ++ ] = i; <span class="hljs-comment">// primes存质数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i * <span class="hljs-number">2</span>; j &lt;= n; j += i) st[j] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// true标记删除，可能会重复标记</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线性筛法">线性筛法</h4><p><strong>核心</strong>：合数 <span class="math inline">\(n\)</span>只会被它的最小质因子筛掉一次(线性)， 任何一个合数一定会被筛掉</p><p>时间复杂度：<span class="math inline">\(O(n)\)</span>， <spanclass="math inline">\(n = 10^7\)</span>时，比埃氏筛法约快一倍，<spanclass="math inline">\(n = 10^6\)</span>，两个差不多</p><p>因为从小到大枚举，<code>i % primes[j] == 0</code> 发生时，意味着primes[j] 一定是 i 的最小质因子，因此 primes[j] 也一定是<code>i*primes[j]</code> 最小质因子。当 <code>i % primes[j] != 0</code>，由于是从小到大枚举质数并且没有没有枚举到过 i 的任何一个质因子，说明primes[j] 一定小于 i 的任何一个质因子，因此 primes[j] 也一定是<code>i*primes[j]</code> 最小质因子。</p><p>任何一个合数一定会被筛掉：因为任何一个合数x，一定存在最小质因子，假设 <code>primes[j]</code>是x的最小质因子，当i枚举到 <code>x/primes[j]</code>的时候，x就被筛掉了。</p><p>没必要 <code>j &lt; cnt</code> ，因为如果说 i 是合数的话，当<code>primes[j]</code> 枚举到 i 的最小质因子的时候就一定会停下来；当 i是质数的时候 ，当<code>primes[j] == i</code> 的时候也会停下来。<code>primes[j] * i</code>是当前要筛的数，这个数是在n的范围内，就是小于等于n</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> primes[N], cnt;<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 第一个循环要枚举出1~n中的所有质数，所以要枚举到n，第二个循环要筛的数是 primes[j] * i，这个数不能超过n。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ ) <span class="hljs-comment">// j从小到大枚举所有质数</span><br>        &#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 每次把当前质数和i的乘积 (一个合数) 筛掉</span><br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 第一次枚举到i的质因子就break</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="约数">约数</h2><h3 id="试除法求约数">试除法求约数</h3><p>一个数的所有约数成对出现，边界 <code>i</code> 和 <code>n / i</code>相同话只加一个</p><p>时间复杂度：<span class="math inline">\(O(\sqrt n + \log n \log \logn)\)</span> = $O(n) $</p><p>约数的个数等于倍数的个数， 1~n中有 <span class="math inline">\(n +\frac n 2 + \frac n 3 + \dots = n\ln n\)</span> 个约数，期望每个数有$n$个约数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get_divisors</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n / i; i ++ )<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">if</span> (i != n / i) res.<span class="hljs-built_in">push_back</span>(n / i);<br>        &#125;<br>    <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//对约数排序</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="约数个数">约数个数</h3><p>对于<span class="math inline">\(n = p_1^{x_1} \times p_2^{x_2} \times\dots \times p_k^{x_k}\)</span>，约数个数为 <spanclass="math inline">\((x_1 + 1)(x_2 + 1) ... (x_k +1)\)</span>，因为n的任何一个约数<spanclass="math inline">\(d\)</span>都可以表示为 <spanclass="math inline">\(p_1^{\beta_1} \times p_2^{\beta_2} \times \dots\times p_k^{\beta_k}\)</span> , 其中 <span class="math inline">\(0 \leq\beta _i \leq x_i\)</span> 。每个 <spanclass="math inline">\(\beta\)</span> 的取法有 <spanclass="math inline">\(x+1\)</span> 种。</p><p>int 范围内，约数个数最多的数其约数大概有 1536 个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_cnt</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            n /= i;<br>            s ++ ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s) res = res * (s + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) res *= <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="约数之和">约数之和</h3><p><span class="math display">\[(p_1^0 + p_1^1 + \dots +p_1^{\alpha_1})(p_2^0 + p_2^1 + \dots+p_2^{\alpha_2})\dots(p_k^0 + p_k^1 + \dots +p_k^{\alpha_k}) = \prod_{i= 1}^{k} \frac {1 - p_i^{\alpha_i + 1}} {1 - p_i}\]</span></p><p>展开后就是约数之和，且取遍了每一个约数。</p><p>不用等比数列公式，因为会溢出，不好处理。 <spanclass="math display">\[t = p \times t + 1 \\t = 1,t = p + 1,t = p^2 + p + 1,...,t = p^{\alpha} + ... + p + 1\]</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; primes;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>&#123;<br><span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>)<br>    &#123;<br>        x /= i;<br>        primes[i] ++ ;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) primes[x] ++ ;<br>&#125;<br><br>LL res = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> prime : primes)<br>&#123;<br>    <span class="hljs-type">int</span> p = prime.first, a = prime.second;<br>    LL t = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (a -- ) t = (t * p + <span class="hljs-number">1</span>) % MOD; <span class="hljs-comment">// 秦九韶算法</span><br>    res = res * t % MOD;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最大公约数">最大公约数</h3><h4 id="欧几里得算法辗转相除法">欧几里得算法(辗转相除法)</h4><p>若d能整除a, 即 <span class="math inline">\(d | a\)</span>，且 <spanclass="math inline">\(d | b\)</span>，则 <span class="math inline">\(d |(ax + by)\)</span>。 a 和 b 的最大公约数等于 b 和 <spanclass="math inline">\(a\enspace mod \enspace b\)</span> 的最大公约数 。<span class="math display">\[(a, b) = (b, a\enspace mod \enspace b)\]</span>边界：0除以任何一个数都得0，可以整除。所有0和一个数的最大公约数是这个数本身，即 <span class="math inline">\(gcd(a, 0) =gcd(0, a)= a\)</span> 。</p><p>时间复杂度：<span class="math inline">\(O(\log n)\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b, a % b) : a;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="欧拉函数">欧拉函数</h2><p><span class="math inline">\(\varphi(n)\)</span>：1~n中与n互质的数的个数，互质即最大公约数为1 。</p><p>公式如下： <span class="math display">\[\varphi(N) = N (1 - \frac 1 {p_1})(1 - \frac 1 {p_2})\dots(1 - \frac 1{p_k})\]</span> 性质：若 <span class="math inline">\(a\)</span> 与 <spanclass="math inline">\(b\)</span> 互质，则 <spanclass="math inline">\(a^{\varphi(b)} \ \% \ b \equiv 1\)</span>。当b是质数p时，有费马小定理 <span class="math inline">\(a^{p - 1}\equiv 1 (mod \ p)\)</span> 。</p><p>展开等于容斥原理：</p><ol type="1"><li>从1~N中去掉<span class="math inline">\(p_1, p_2, ...p_k\)</span>的所有倍数</li><li>加上所有 <span class="math inline">\(p_i *p_j\)</span> 的倍数</li><li>减去所有<span class="math inline">\(p_i * p_j *p_k\)</span>的倍数，以此类推</li></ol><p><span class="math display">\[N - \frac N {p_1} - \frac N {p_2} - ... + \frac N {p_1*p_2} + ... -\frac N {p_1*p_2*p_3} - ... + ...\]</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_euler</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = a;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= a / i; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">while</span> (a % i == <span class="hljs-number">0</span>) <br>        &#123;<br>            res = res / i * (i - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 先除后乘</span><br>            a /= i; <span class="hljs-comment">// 分解质因数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">1</span>) res = res / a * (a - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="筛法求欧拉函数">筛法求欧拉函数</h4><p>若 <span class="math inline">\(p_j\)</span> 是 <spanclass="math inline">\(i\)</span> 的质因子：<spanclass="math inline">\(\varphi(p_j * i) = p_j\varphi(i)\)</span> 若 <spanclass="math inline">\(p_j\)</span> 不是 <spanclass="math inline">\(i\)</span> 的质因子：<spanclass="math inline">\(\varphi(p_j * i) = p_j(1-\frac 1{p_j})\varphi(i)=(p_j - 1)\varphi(i)\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">int</span> primes[N], cnt;<br><span class="hljs-type">int</span> phi[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function">LL <span class="hljs-title">get_eulers</span><span class="hljs-params">(x)</span></span><br><span class="hljs-function"></span>&#123;<br>phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) <br>        &#123;<br>            primes[cnt ++ ] = i;<br>            phi[i] = i - <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= x / i; j ++)<br>        &#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-comment">// primes[j]是i的质因子</span><br>            &#123;<br>                phi[primes[j] * i] = phi[i] * primes[j];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            phi[primes[j] * i] = phi[i] * (primes[j] - <span class="hljs-number">1</span>); <br>        &#125;<br>    &#125;<br>    LL res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= x; i ++ ) res += phi[i];<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速幂">快速幂</h2><p>快速求出 <span class="math inline">\(a^k\;mod \;p\)</span> 的结果<span class="math inline">\((1 \leq a, k, p \leq 10^9)\)</span></p><p>时间复杂度: <span class="math inline">\(O(\log k)\)</span></p><p>核心思路：反复平方法，预处理出 <span class="math inline">\(a^{2^0}mod {\ }p\)</span>，<span class="math inline">\(a^{2^1} mod {\}p\)</span>，<span class="math inline">\(a^{2^2} mod {\}p\)</span>，...，<span class="math inline">\(a^{2^{\log k}} mod \p\)</span>，每一个数都是前一个数的<strong>平方</strong>模 <spanclass="math inline">\(p\)</span> 。</p><p><span class="math inline">\(a^k = a^{2^i + 2^j + \dots + 2^t} =a^{2^i}\times a^{2^j} \times \dots \timesa^{2^t}\)</span>，k的二进制表示为1的位对应<spanclass="math inline">\(i,j, ...t\)</span>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-comment">// a^k % p</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span> % p; <span class="hljs-comment">// p = 1时, res = 0</span><br>    <span class="hljs-keyword">while</span> (k)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL)res * a % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>        a = (LL)a * a % p; <span class="hljs-comment">// 更新a</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>乘法逆元的定义</p><blockquote><p>若整数b，m互质，并且 <span class="math inline">\(b |a\)</span>，则存在一个整数 <span class="math inline">\(x\)</span> ，使得<span class="math inline">\(\frac a b = a \times x \;(mod \; m)\)</span>，则称 <span class="math inline">\(x\)</span> 为 <spanclass="math inline">\(b\)</span> 的模 <spanclass="math inline">\(m\)</span> 乘法逆元，记为 <spanclass="math inline">\(b^{−1}(\mod m)\)</span>。 <spanclass="math inline">\(b\)</span> 存在乘法逆元的充要条件是 <spanclass="math inline">\(b\)</span> 与模数 <spanclass="math inline">\(m\)</span> 互质。当模数 <spanclass="math inline">\(m\)</span> 为质数时，<spanclass="math inline">\(b^{m−2}\)</span> 即为 <spanclass="math inline">\(b\)</span> 的乘法逆元。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——线程</title>
    <link href="/2022/07/06/b708aef3b714.html"/>
    <url>/2022/07/06/b708aef3b714.html</url>
    
    <content type="html"><![CDATA[<h1 id="线程">线程</h1><h2 id="线程介绍">线程介绍</h2><p>进程：运行的程序线程：线程由进程创建，是进程的一个实体，一个进程可以拥有多个线程</p><p>单线程：同一时刻，只允许执行一个线程多线程：同一时刻，可以执行多个线程</p><p>并发：同一时刻，多个任务交替执行，造成一种”貌似同时“的错觉。单核 cpu实现的多任务就是并发。<span id="more"></span> 并行：同一时刻，多个任务同时执行。多核cpu 可以实现并行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runtime</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br><span class="hljs-comment">// 获取当前电脑的cpu数量</span><br><span class="hljs-type">int</span> <span class="hljs-variable">cpuNums</span> <span class="hljs-operator">=</span> reuntime.availableProcessors();<br></code></pre></td></tr></table></figure><h2 id="线程使用">线程使用</h2><ul><li>创建线程的两种方式</li></ul><ol type="1"><li>继承 <code>Thread</code> 类，重写 <code>run</code> 方法</li><li>实现 <code>Runnable</code> 接口，重写 <code>run</code> 方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company.thread_;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> nessaj</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/6/28 10:14</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">threadUse01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        cat.start(); <span class="hljs-comment">// 启动线程-&gt; 最终执行cat.run()</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 重写run方法，写具体的业务逻辑</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;cat ~~~ &quot;</span> + (++cnt));<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <span class="hljs-comment">// ctrl + alt + t</span><br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">10</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>java是单继承的，在某些情况下一个类可能已经继承了某个父类，这时再用继承Thread 类方法来创建线程显然不可能。此时可以通过实现 <code>Runable</code>接口来创建线程。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">threadUse02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        <span class="hljs-comment">// dog.start(); 无法调用</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(dog); <span class="hljs-comment">// 设计模式【静态代理模式】</span><br>        thread.start();<br>        <br>        <span class="hljs-comment">// 模拟Thread</span><br>        <span class="hljs-type">Tiger</span> <span class="hljs-variable">tiger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tiger</span>(); <span class="hljs-comment">// 实现Runnable接口</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadProxy</span>(tiger).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Tiger~~~&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 线程代理类，模拟Thread</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 属性， 类型是 Runnable</span><br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;<br>            target.run(); <span class="hljs-comment">// 动态绑定(运行类型Tiger)</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadProxy</span><span class="hljs-params">(Runnable target)</span> &#123; <span class="hljs-comment">// 构造器接收Runnable接口类型</span><br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        start0();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start0</span><span class="hljs-params">()</span> &#123;<br>        run();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 重写run方法，写具体的业务逻辑</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;dog ~~~ &quot;</span> + (++cnt));<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 休眠1s</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <span class="hljs-comment">// ctrl + alt + t</span><br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">10</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><imgsrc="https://cdn.jsdelivr.net/gh/nessaj7/ImageHost/img/202206281025675.png"alt="多线程机制" /> 当main线程启动一个子程序 Thread-0,主线程不会阻塞，会继续执行。 所有线程结束后，进程才会挂掉。<code>Thread.currentThread().getName()</code></p><p>使用命令 <code>jconsole</code>监控线程执行情况</p><p>Java 中实现真正的多线程是start()中的<code>start0()</code>方法(JVM调用)，<code>run()</code>方法只是一个普通方法 <imgsrc="https://cdn.jsdelivr.net/gh/nessaj7/ImageHost/img/202207101131287.png" /></p><h3 id="继承thread-vs-实现runnable的区别">继承Thread vs实现Runnable的区别</h3><ol type="1"><li>从java的设计来看，通过继承Thread或者实现Runnable接口来创建线程本质上没有区别，从jdk帮助文档可以看到Thread类本身就实现了Runnable接口</li><li>实现Runnable接口方式更加适合多个线程<strong>共享一个资源</strong>的情况并且避免了单继承的限制</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>(<span class="hljs-string">&quot;xxx&quot;</span>); <span class="hljs-comment">// 一个资源被两个线程共享</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t);<br>thread1.start();<br>thread2.start();<br></code></pre></td></tr></table></figure><h3 id="线程终止">线程终止</h3><ol type="1"><li>当线程完成任务后，自动退出；</li><li>通过<strong>使用变量</strong>来控制run方法退出的方式停止线程，即通知方式<code>setLoop = false;</code></li></ol><h2 id="线程方法">线程方法</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">setName <span class="hljs-regexp">//</span>设置线程名称,使之与参数name相同<br>getName  <span class="hljs-regexp">//</span>返回该线程的名称<br>start<span class="hljs-regexp">//</span>使该线程开始执行;Java虚拟机底层调用该线程的start0方法<br>run <span class="hljs-regexp">//</span>调用线程对象run方法<br>setPriority  <span class="hljs-regexp">//</span>更改线程的优先级  [<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>]<br>getPriority  <span class="hljs-regexp">//</span>获取线程的优先级<br>sleep <span class="hljs-regexp">//</span>在指定的毫秒数内让当前正在执行的线程休眠(暂停执行<br>interrupt  <span class="hljs-regexp">//</span>中断线程, 一般用于唤醒正在休眠的线程<br></code></pre></td></tr></table></figure><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">yield:</span> 线程的礼让。让出cpu,让其他线程执行，但礼让的时间不确定, 所以也不一定礼让成功<br><span class="hljs-symbol">join:</span>  线程的插队。插队的线程一旦插队成功, 则肯定先执行完插入的线程所有的任务<br></code></pre></td></tr></table></figure><h3 id="用户线程和守护线程">用户线程和守护线程</h3><ol type="1"><li>用户线程：也叫工作线程，当线程的任务执行完或通知方式结束</li><li>守护线程：一般是为工作线程服务的，当所有的用户线程执行结束，守护线程自动结束</li></ol><ul><li>常用的守护线程：垃圾回收机制</li><li>在 <code>start()</code> 前执行<code>线程名.setDaemen(true);</code></li></ul><h2 id="线程生命周期">线程生命周期</h2><ul><li>JDK 中用 <code>Thread.State</code> 枚举表示了线程的几种状态</li></ul><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">enum</span> Thread.State<br>extends <span class="hljs-keyword">Enum</span>&lt;Thread.state&gt;<br><br>线程状态。线程可以处于以下状态之一:<br><span class="hljs-keyword">NEW</span> 尚未启动的线程处于此状态。<br>RUNNABLE 在Java虚拟机中执行的线程处于此状态。<br>BLOCKED 被阻塞等待监视器锁定的线程处于此状态。<br>WAITING 正在等待另一个线程执行特定动作的线程处于此状态。<br>TIMED_WAITING 正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。<br>TERMINATED 已退出的线程处于此状态。<br></code></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/nessaj7/ImageHost/img/202207101549300.png" /></p><h2 id="synchronized">Synchronized</h2><h3 id="线程同步机制">线程同步机制</h3><ol type="1"><li>在多线程编程，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何同一时刻，最多有一个线程访问，以保证数据的完整性。</li><li>也可以这里理解：线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> 同步代码块<br><span class="hljs-keyword">synchronized</span> (对象) &#123; <span class="hljs-comment">// 得到对象的锁，才能操作同步代码</span><br>    <span class="hljs-comment">// 需要被同步的代码;</span><br>&#125;<br><br><span class="hljs-number">2.</span> <span class="hljs-keyword">synchronized</span> 还可以放在方法声明中，表示整个方法为-同步方法<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span> <span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-comment">// 需要被同步的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="互斥锁">互斥锁</h2><p><imgsrc="https://cdn.jsdelivr.net/gh/nessaj7/ImageHost/img/202207101606769.png" /></p><ol type="1"><li>Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。</li><li>每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。</li><li>关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问</li><li>同步的局限性：导致程序的执行效率要降低</li><li>同步方法(非静态的)的锁可以是<code>this</code>，也可以是其他对象(要求是<strong>同一个对象</strong>)</li><li>同步方法(static静态的)的锁为当前类本身 <code>类名.class</code>。</li></ol><h3 id="死锁">死锁</h3><p>多个线程都占用了对方的锁资源，但不肯相让，导致了死锁，在编程时一定要避免死锁的发生。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLock_</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 模拟死锁</span><br>        <span class="hljs-type">DeadlockDemo</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadlockDemo</span>(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">DeadlockDemo</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadlockDemo</span>(<span class="hljs-literal">false</span>);<br>        A.start();<br>        B.start();<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadlockDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">o1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">// 保证多线程共享一个对象，这里使用static</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">o2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">boolean</span> flag;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DeadlockDemo</span><span class="hljs-params">(<span class="hljs-type">boolean</span> flag)</span> &#123; <span class="hljs-comment">// 构造器</span><br>        <span class="hljs-built_in">this</span>.flag = flag;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (flag) &#123;<br><span class="hljs-keyword">synchronized</span> (o1) &#123; <span class="hljs-comment">// 对象互斥锁</span><br>                System.out.println(Thread.currenyThread().getName() + <span class="hljs-string">&quot; 进入1&quot;</span>);<br>       <span class="hljs-keyword">synchronized</span>(o2) &#123;<br>            System.out.println(Thread.currenyThread().getName() + <span class="hljs-string">&quot; 进入2&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (o2) &#123;<br>                System.out.println(Thread.currenyThread().getName() + <span class="hljs-string">&quot; 进入3&quot;</span>);<br>       <span class="hljs-keyword">synchronized</span>(o1) &#123;<br>            System.out.println(Thread.currenyThread().getName() + <span class="hljs-string">&quot; 进入4&quot;</span>);<br>        &#125;<br>    &#125;<br>        &#125;<br>    &#125;<br>&#125; <br><br></code></pre></td></tr></table></figure> ### 释放锁</p><ul><li>下面操作会释放锁</li></ul><ol type="1"><li>当前线程的同步方法、同步代码块执行结束</li><li>当前线程在同步代码块、同步方法中遇到 <code>break</code>、<code>return</code> 。</li><li>当前线程在同步代码块、同步方法中出现了未处理的 <code>Error</code> 或<code>Exception</code> ，导致异常结束</li><li>当前线程在同步代码块、同步方法中执行了线程对象的 <code>wait()</code>方法，当前线程暂停，并释放锁。</li></ol><ul><li>下面操作不会释放锁</li></ul><ol type="1"><li>线程执行同步代码块或同步方法时,程序调用<code>Thread.sleep()</code>、<code>Thread.yield()</code>方法暂停当前线程的执行，不会释放锁</li><li>线程执行同步代码块时，其他线程调用该线程的 <code>suspend()</code>方法将该线程挂起，该线程不会释放锁。</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——泛型</title>
    <link href="/2022/06/27/90e5794c173e.html"/>
    <url>/2022/06/27/90e5794c173e.html</url>
    
    <content type="html"><![CDATA[<h1 id="泛型-generic">泛型 Generic</h1><h2 id="泛型的理解和好处">泛型的理解和好处</h2><ul><li><p>使用传统方法的问题</p><ol type="1"><li>不能对加入到集合 <code>ArrayList</code>中的数据类型进行约束(不安全)</li><li>遍历的时候，需要进行类型转换，如果集合中的数据量较大，对效率有影响</li></ol></li><li><p>用泛型来解决</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Dog&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Dog&gt;(); <span class="hljs-comment">// 在数据类型后边加上泛型的标识</span><br></code></pre></td></tr></table></figure><ol type="1"><li>如果编译器发现添加的类型不满足要求，就会报错</li><li>在遍历的时候，可以直接取出Dog类型而不是Object，不用进行向下转型</li><li><code>public class ArrayList&lt;E&gt; &#123;&#125;</code> E称为泛型, 那么 Dog<span class="math inline">\(\rightarrow\)</span> E</li></ol><h2 id="泛型说明">泛型说明</h2><p>int a = 10; 泛(广泛)型(类型) E =&gt; Integer, String, Dog</p><ol type="1"><li>泛型又称参数化类型，是 Jdk5.0 出现的新特性, 解决数据类型的安全性问题【泛型可以理解为接收数据类型的数据类型】</li><li>在类声明或实例化时只要指定好需要的具体的类型即可。</li><li>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生<code>ClassCastException</code> 异常。同时，代码更加简洁、健壮</li><li>泛型的作用是:可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Person&lt;String&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>&lt;String&gt;(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&lt;E&gt; &#123;<br>    E s; <span class="hljs-comment">// E表示s的数据类型，该数据类型在定义Person对象的时候指定，即在编译期间就确定E是什么类型 getClass</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(E s)</span> &#123; <span class="hljs-comment">// 参数类型</span><br>        <span class="hljs-built_in">this</span>.s = s;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 返回类型</span><br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="泛型语法">泛型语法</h2><ul><li><p>泛型的声明<code>interface接口&lt;T&gt;和class类&lt;K,V&gt;&#123;&#125; //比如: List, ArrayList</code>说明:</p><ol type="1"><li>其中，T,K,V不代表值,而是表示类型。</li><li>任意字母都可以。常用T表示，是Type的缩写</li></ol></li><li><p>泛型的实例化 要在类名后面指定类型参数的值(类型)。如:</p><ol type="1"><li><code>List&lt;String&gt; strList = new ArrayList&lt;String&gt;();</code></li><li><code>Iterator&lt;Customer&gt; iterator = customers.iterator();</code></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generic01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// ==============HashSet================</span><br>        HashSet&lt;Stu&gt; stus = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">Stu</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stu</span>(<span class="hljs-string">&quot;jojo&quot;</span>, <span class="hljs-number">18</span>);<br>        <span class="hljs-type">Stu</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stu</span>(<span class="hljs-string">&quot;kiki&quot;</span>, <span class="hljs-number">5</span>);<br>        <span class="hljs-type">Stu</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stu</span>(<span class="hljs-string">&quot;lala&quot;</span>, <span class="hljs-number">8</span>);<br>        stus.add(s1);<br>        stus.add(s2);<br>        stus.add(s3);<br><br>        <span class="hljs-comment">// 1.1</span><br>        <span class="hljs-keyword">for</span> (Stu stu : stus) &#123;<br>            System.out.println(stu);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;+++++++++++++++++++&quot;</span>);<br>        <span class="hljs-comment">// 1.2</span><br>        Iterator&lt;Stu&gt; iterator = stus.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            System.out.println(iterator.next());<br>        &#125;<br><br>        <span class="hljs-comment">//==============HashMap==================</span><br>        HashMap&lt;String, Stu&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;jojo&quot;</span>, s1);<br>        map.put(<span class="hljs-string">&quot;kiki&quot;</span>, s2);<br>        map.put(<span class="hljs-string">&quot;lala&quot;</span>, s3);<br>        System.out.println(<span class="hljs-string">&quot;+++++++++++++++++++&quot;</span>);<br>        <span class="hljs-comment">// 2.1</span><br>        <span class="hljs-keyword">for</span> (String s : map.keySet()) &#123;<br>            System.out.println(s + <span class="hljs-string">&quot; - &quot;</span> + map.get(s));<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;+++++++++++++++++++&quot;</span>);<br>        <span class="hljs-comment">// 2.2</span><br>        Iterator&lt;Map.Entry&lt;String, Stu&gt;&gt; entryIterator = map.entrySet().iterator();<br>        <span class="hljs-keyword">while</span> (entryIterator.hasNext()) &#123;<br>            Map.Entry&lt;String, Stu&gt; next = entryIterator.next();<br>            System.out.println(next.getKey() + <span class="hljs-string">&quot; - &quot;</span> + next.getValue());<br><span class="hljs-comment">//            System.out.println(entryIterator.next());</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stu</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stu</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Stu&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型使用细节">泛型使用细节</h3><ol type="1"><li><code>interface List&lt;T&gt;&#123;&#125;, public class HashSet&lt;E&gt;&#123;&#125;</code>... 等等 说明: T, E 只能是引用类型 看看下面语句是否正确?</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(); <span class="hljs-comment">// OK</span><br>List&lt;<span class="hljs-type">int</span>&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-type">int</span>&gt;(); <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>在指定泛型具体类型后, 可以传入该类型或者其子类类型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Person&lt;A&gt; p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>());<br>Person&lt;A&gt; p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>());<br><br><span class="hljs-comment">//================</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&lt;E&gt; &#123;<br>E e;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(E e)</span> &#123;<br><span class="hljs-built_in">this</span>.e = e;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>泛型使用形式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list1 =<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>List&lt;Integer&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>[说明] 如果这样写 <code>List list3 = new ArrayList();</code>默认给它的泛型是[&lt;E&gt; E就是Object]</p><ul><li>练习</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// List 自定义排序 匿名内部类</span><br>List&lt;MyDate&gt; as = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>as.sort(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;MyDate&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(MyDate o1, MyDate o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> o1.getBirthday().compareTo(o2.getBirthday());<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// 在MyDate类实现Comparable接口，重写compareTo方法 【封装】</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;MyDate&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> year;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> month;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> day;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyDate</span><span class="hljs-params">(<span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day)</span> &#123;<br>        <span class="hljs-built_in">this</span>.year = year;<br>        <span class="hljs-built_in">this</span>.month = month;<br>        <span class="hljs-built_in">this</span>.day = day;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getYear</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> year;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setYear</span><span class="hljs-params">(<span class="hljs-type">int</span> year)</span> &#123;<br>        <span class="hljs-built_in">this</span>.year = year;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMonth</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> month;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMonth</span><span class="hljs-params">(<span class="hljs-type">int</span> month)</span> &#123;<br>        <span class="hljs-built_in">this</span>.month = month;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDay</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> day;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDay</span><span class="hljs-params">(<span class="hljs-type">int</span> day)</span> &#123;<br>        <span class="hljs-built_in">this</span>.day = day;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(MyDate o)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">yearMinus</span> <span class="hljs-operator">=</span> year - o.getYear();<br>        <span class="hljs-keyword">if</span> (yearMinus != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> yearMinus;<br>       <br>        <span class="hljs-comment">// 如果year相同就比较month</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">monthMinus</span> <span class="hljs-operator">=</span> month - o.getMonth();<br>        <span class="hljs-keyword">if</span> (monthMinus != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> monthMinus;<br>        <br>        <span class="hljs-keyword">return</span> day - o.getDay();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyDate&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;year=&quot;</span> + year +<br>                <span class="hljs-string">&quot;, month=&quot;</span> + month +<br>                <span class="hljs-string">&quot;, day=&quot;</span> + day +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自定义泛型">自定义泛型</h2><h3 id="泛型类">泛型类</h3><ul><li>基本语法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">class 类名&lt;T, R, M...&gt; &#123; <span class="hljs-comment">// ...表示可以有多个泛型</span><br>    成员<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意细节</li></ul><ol type="1"><li>普通成员(属性、方法)可以使用泛型</li><li>使用泛型的数组, 不能初始化 <code>T[] ts = new T[10];</code>没有确定类型不知道在内存开辟多大空间</li><li>静态方法、静态属性中不能使用类的泛型，因为静态是和类相关的，在类加载时，对象还没创建，无法确定类型</li><li>泛型类的类型，是在创建对象时确定的(因为创建对象时，需要指定确定类型)</li><li>如果在创建对象时, 没有指定类型, 默认为Object</li></ol><h3 id="泛型接口">泛型接口</h3><ul><li>基本语法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">interface 接口名&lt;T, R…&gt; &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意细节</li></ul><ol type="1"><li>接口中, 静态成员也不能使用泛型(这个和泛型类规定一样)</li><li>泛型接口的类型,在<strong>继承接口</strong>或者<strong>实现接口</strong>时确定</li><li>没有指定类型, 默认为Object</li></ol><h3 id="泛型方法">泛型方法</h3><ul><li>基本语法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 &lt;T,R..&gt; 返回类型 方法名(参数列表) &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意细节</li></ul><ol type="1"><li>泛型方法，可以定义在普通类中，也可以定义在泛型类中</li><li>当泛型方法被调用时，类型会确定</li><li><code>public void eat(E e) &#123;&#125;</code>, 修饰符后没有<code>&lt;T,R...&gt;</code> , eat方法不是泛型方法, 而是使用了泛型</li></ol><h2 id="泛型继承和通配符">泛型继承和通配符</h2><ol type="1"><li>泛型不具备继承性<code>List&lt;Object&gt; list = new ArrayList&lt;String&gt;();</code>x</li><li><code>&lt;?&gt;</code> : 支持任意泛型类型</li><li><code>&lt;? extends A&gt;</code>: 支持A类以及A类的子类,规定了泛型的上限</li><li><code>&lt;? super A&gt;</code>: 支持A类以及A类的父类,不限于直接父类，规定了泛型的下限</li></ol><h1 id="junit">JUnit</h1><ul><li>为什么需要JUnit</li></ul><ol type="1"><li>一个类有很多功能代码需要测试,为了测试,就需要写入到main方法中</li><li>如果有多个功能代码测试,就需要来回注销,切换很麻烦</li><li>JUnit 可以直接运行一个方法，并且可以给出相关信息, 方便很多</li></ol><ul><li>基本介绍</li></ul><ol type="1"><li>JUnit 是一个Java语言的单元测试框架</li><li>多数Java的开发环境都已经集成了 JUnit 作为单元测试的工具</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——集合</title>
    <link href="/2022/06/23/15735e119054.html"/>
    <url>/2022/06/23/15735e119054.html</url>
    
    <content type="html"><![CDATA[<h1 id="集合框架体系">集合框架体系</h1><h2 id="集合的理解和好处">集合的理解和好处</h2><ul><li>数组（缺点）</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">1) 长度开始时必须指定，而且一旦指定，不能更改<br>2) 保存的必须为同一类型的元素<br>3) 使用数组进行增加、删除元素比较麻烦<br></code></pre></td></tr></table></figure><ul><li>集合</li></ul><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span>) 可以动态保存任意多个对象，使用比较方便<br><span class="hljs-number">2</span>) 提供了一系列方便的操作对象的方法: add, <span class="hljs-comment">remove, set, get等</span><br><span class="hljs-number">3</span>) 使用集合添加，删除元素更简洁<br></code></pre></td></tr></table></figure><h2 id="集合框架">集合框架</h2><p><imgsrc="https://cdn.jsdelivr.net/gh/nessaj7/ImageHost/img/202206251038863.png" />Java的集合类很多，主要分为两大类：</p><ul><li>单列集合 <code>Collection</code> 接口有两个重要的子接口<code>List</code>， <code>Set</code>， 它们的实现子类都是单列集合</li><li>双列集合 <code>Map</code> 接口的实现子类是双列集合存放的key-value对</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Collection</span>&lt;<span class="hljs-symbol">E</span>&gt; <span class="hljs-symbol">extends</span> <span class="hljs-symbol">Iterable</span>&lt;<span class="hljs-symbol">E</span>&gt; &#123;&#125; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Map</span>&lt;<span class="hljs-symbol">K</span>, <span class="hljs-symbol">V</span>&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="集合的选择">集合的选择</h2><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">1) 先判断存储的类型(一组对象[单列]或一组键值对[双列])</span><br><span class="hljs-attribute">2) 一组对象[单列]</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Collection接口</span><br>    <span class="hljs-attribute">允许重复</span><span class="hljs-punctuation">:</span> <span class="hljs-string">List</span><br>    <span class="hljs-attribute">增删多</span><span class="hljs-punctuation">:</span> <span class="hljs-string">LinkedList [底层维护了一个双向链表]</span><br>    <span class="hljs-attribute">改查多</span><span class="hljs-punctuation">:</span> <span class="hljs-string">ArrayList [底层维护 Object 类型的可变数组]</span><br>    <span class="hljs-attribute">不允许重复</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Set</span><br>    <span class="hljs-attribute">无序</span><span class="hljs-punctuation">:</span> <span class="hljs-string">HashSet[底层是HashMap，维护了一个哈希表即(数组+链表+红黑树)J]</span><br>    <span class="hljs-attribute">排序</span><span class="hljs-punctuation">:</span> <span class="hljs-string">TreeSet</span><br>    <span class="hljs-attribute">插入和取出顺序一致</span><span class="hljs-punctuation">:</span> <span class="hljs-string">LinkedHashSet，维护数组+双向链表</span><br><span class="hljs-attribute">3)一组键值对[双列]</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Map</span><br><span class="hljs-attribute">键无序</span><span class="hljs-punctuation">:</span> <span class="hljs-string">HashMap [底层是:哈希表 jdk7: 数组+链表，jdk8: 数组+链表+红黑树]</span><br><span class="hljs-attribute">键排序</span><span class="hljs-punctuation">:</span> <span class="hljs-string">TreeMap</span><br><span class="hljs-attribute">键插入和取出顺序一致</span><span class="hljs-punctuation">:</span> <span class="hljs-string">LinkedHashMap</span><br><span class="hljs-attribute">读取文件</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Properties</span><br><br></code></pre></td></tr></table></figure><h1 id="collection-接口">Collection 接口</h1><ul><li>Collection 接口<strong>实现类</strong>的特点</li></ul><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-number">1.</span> collection实现子类可以存放多个元素，每个元素可以是Object<br><span class="hljs-number">2.</span> 有些<span class="hljs-keyword">Collection</span>的实现类可以存放重复的元素，有些不可以<br><span class="hljs-number">3.</span> 有些<span class="hljs-keyword">Collection</span>的实现类元素是有序的(List)，有些不是有序(<span class="hljs-keyword">Set</span>)<br><span class="hljs-number">4.</span> <span class="hljs-keyword">Collection</span>接口没有直接的实现子类，是通过它的子接口<span class="hljs-keyword">Set</span>和List来实现的<br></code></pre></td></tr></table></figure><ul><li>Collection 接口常用方法</li></ul><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span>. add: 添加单个元素<br><span class="hljs-number">2</span>. <span class="hljs-comment">remove: 删除指定元素</span><br><span class="hljs-number">3</span>. contains: 查找元素是否存在<br><span class="hljs-number">4</span>. size: 获取元素个数<br><span class="hljs-number">5</span>. isEmpty: 判断是否为空<br><span class="hljs-number">6</span>. <span class="hljs-keyword">clear</span>: 清空<br><span class="hljs-number">7</span>. addAll: 添加多个元素<br><span class="hljs-number">8</span>. containsAll: 查找多个元素是否都存在<br><span class="hljs-number">9</span>. <span class="hljs-comment">removeAll: 删除多个元素</span><br></code></pre></td></tr></table></figure><ul><li>Collection 接口遍历元素</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 方式1 - 使用Iterator（迭代器）</span><br><span class="hljs-number">1.</span> <span class="hljs-built_in">Iterator</span> 对象称为迭代器，主要用于遍历 Collection 集合中的元素。<br><span class="hljs-number">2.</span> 所有实现了 Collection 接口的集合类都有一个 iterator() 方法，用以返回一个实现了 <br>   <span class="hljs-built_in">Iterator</span> 接口的对象，即可以返回一个迭代器。<br><span class="hljs-number">3.</span> 结构: 接口<span class="hljs-built_in">Iterator</span>&lt;E&gt; <br><span class="hljs-number">4.</span> <span class="hljs-built_in">Iterator</span> 仅用于遍历集合，<span class="hljs-built_in">Iterator</span> 本身并不存放对象。<br><span class="hljs-number">5.</span> 基本语法<br>    <span class="hljs-built_in">Iterator</span> iterator = list.iterator();<br>    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>        <span class="hljs-built_in">Object</span> obj = iterator.next();<br>        System.out.println(<span class="hljs-string">&quot;obj = &quot;</span> + obj);<br>    &#125;<br><span class="hljs-number">6.</span> 快捷方式 itit<br><br><span class="hljs-comment">// 方式2 - for循环增强</span><br><span class="hljs-number">1.</span> 增强<span class="hljs-keyword">for</span>循环，可以代替iterator迭代器，特点：增强<span class="hljs-keyword">for</span>就是简化版的iterator，本质一样。<br>  只能用于遍历集合或数组。<br><span class="hljs-number">2.</span> 基本语法<br>    <span class="hljs-keyword">for</span> (元素类型 元素名 : 集合名或数组名) &#123;<br>        访问元素<br>    &#125;<br><span class="hljs-number">3.</span> 快捷方式 I, iter<br></code></pre></td></tr></table></figure><h2 id="list-接口">List 接口</h2><ul><li>基本介绍</li></ul><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">List</span> 接口是 <span class="hljs-variable">Collection</span> 接口的子接口<br><span class="hljs-number">1.</span> <span class="hljs-built_in">List</span>集合类中元素有序<span class="hljs-punctuation">(</span>即添加顺序和取出顺序一致<span class="hljs-punctuation">)</span>、且可重复<br><span class="hljs-number">2.</span> <span class="hljs-built_in">List</span>集合中的每个元素都有其对应的顺序索引，即支持索引<br><span class="hljs-number">3.</span> <span class="hljs-built_in">List</span>容器中的元素都对应一个整数型的序号记录其在容器中的位置，可以根据序号存取容器中的元素。<br><span class="hljs-number">4.</span> <span class="hljs-variable">JDK</span> <span class="hljs-variable">API</span> 中<span class="hljs-built_in">List</span>接口的实现类有：<span class="hljs-variable">ArrayList</span><span class="hljs-operator">,</span> <span class="hljs-variable">LinkedList</span><span class="hljs-operator">,</span> <span class="hljs-variable">Vector</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Stack</span><span class="hljs-operator">,</span> <span class="hljs-operator">...</span><br></code></pre></td></tr></table></figure><ul><li>List 接口常用方法</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">List 集合里添加了一些根据索引来操作集合元素的方法<br><span class="hljs-number">1.</span> <span class="hljs-type">void</span> <span class="hljs-keyword">add</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>, <span class="hljs-keyword">Object</span> ele): 在<span class="hljs-keyword">index</span>位置插入ele元素<br><span class="hljs-number">2.</span> <span class="hljs-type">boolean</span> addAll(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>, Collection eles): 从<span class="hljs-keyword">index</span>位置开始将eles中的所有元素添加进来<br><span class="hljs-number">3.</span> <span class="hljs-keyword">Object</span> <span class="hljs-keyword">get</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>): 获取指定<span class="hljs-keyword">index</span>位置的元素!<br><span class="hljs-number">4.</span> <span class="hljs-type">int</span> indexOf(<span class="hljs-keyword">Object</span> obj): 返回obj在集合中首次出现的位置<br><span class="hljs-number">5.</span> <span class="hljs-type">int</span> lastlndexOf(<span class="hljs-keyword">Object</span> obj): 返回obj在当前集合中未次出现的位置<br><span class="hljs-number">6.</span> <span class="hljs-keyword">Object</span> remove(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>): 移除指定<span class="hljs-keyword">index</span>位置的元素，并返回此元素<br><span class="hljs-number">7.</span> <span class="hljs-keyword">Object</span> <span class="hljs-keyword">set</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>, <span class="hljs-keyword">Object</span> ele): 设置指定<span class="hljs-keyword">index</span>位置的元素为ele, 相当于是替换<br><span class="hljs-number">8.</span> List subList(<span class="hljs-type">int</span> fromlndex, <span class="hljs-type">int</span> tolndex): 返回从fromIndex到tolndex位置的子集合 前闭后开<br></code></pre></td></tr></table></figure><ul><li>List 的三种遍历方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 前两种同Collection</span><br><span class="hljs-comment">// 方式三： 使用普通for</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i ++) &#123;<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> list.get(i); <span class="hljs-comment">// get()获取指定index位置的元素</span><br>System.out.println(obj);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="arraylist">ArrayList</h3><ul><li>ArrayList 的注意事项</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-number">1.</span> permits all elements, include <span class="hljs-literal">null</span>, <span class="hljs-built_in">ArrayList</span> 可以加入<span class="hljs-literal">null</span>, 并且多个<br><span class="hljs-number">2.</span> <span class="hljs-built_in">ArrayList</span> 是由数组来实现数据存储的<br><span class="hljs-number">3.</span> <span class="hljs-built_in">ArrayList</span> 基本等同于Vector, 除了<span class="hljs-built_in">ArrayList</span>是线程不安全(执行效率高), 在多线程情况下，不建议使用<span class="hljs-built_in">ArrayList</span><br></code></pre></td></tr></table></figure><ul><li>ArrayList 的底层操作机制(jdk1.8)</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-number">1.</span> <span class="hljs-built_in">ArrayList</span>中维护了一个<span class="hljs-built_in">Object</span>类型的数组elementData<br><span class="hljs-keyword">transient</span> <span class="hljs-built_in">Object</span>[] elementData; <span class="hljs-comment">// transient 表示该属性不会被序列化</span><br><span class="hljs-number">2.</span> 当创建<span class="hljs-built_in">ArrayList</span>对象时，如果使用的是无参构造器，则初始elementData容量为<span class="hljs-number">0</span>，第一次添加，<br>  则扩容elementData为<span class="hljs-number">10</span>, 如需要再次扩容，则扩容elementData为<span class="hljs-number">1.5</span>倍;<br><span class="hljs-number">3.</span> 如果使用的是指定大小的构造器，则初始elementData容量为指定大小, 如果需要扩容，<br>  则直接扩容elementData为<span class="hljs-number">1.5</span>倍;<br></code></pre></td></tr></table></figure><h3 id="linkedlist">LinkedList</h3><ul><li>LinkedList 底层结构</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown">// 说明<br><span class="hljs-bullet">1.</span> LinkedList实现了双向链表和双端队列特点<br><span class="hljs-bullet">2.</span> 可以添加任意元素(元素可重复), 包括null<br><span class="hljs-bullet">3.</span> 线程不安全, 没有实现同步<br><br>// 底层操作机制<br><span class="hljs-bullet">1.</span> LinkedList底层维护了一个双向链表<br><span class="hljs-bullet">2.</span> LinkedList中维护了两个属性first和last分别指向首节点和尾节点<br><span class="hljs-bullet">3.</span> 每个节点(Node对象), 里面又维护了prev, next, item三个属性<br><span class="hljs-bullet">4.</span> LinkedList的元素添加和删除，不是通过数组完成的，相对来说效率较高<br></code></pre></td></tr></table></figure><ul><li>LinkedList的增删改查</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LinkedList</span> <span class="hljs-variable">linkedList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span>; i++) &#123;<br>linkedList.add(i);<br>&#125;<br>linkedList.add(<span class="hljs-number">100</span>);<br>linkedList.add(<span class="hljs-number">100</span>);<br><span class="hljs-keyword">for</span> (Object o : linkedList) &#123;<br>System.out.println(o);<br>&#125;<br><br>linkedList.remove(<span class="hljs-number">0</span>);<br><br>linkedList.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;hello&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;++++++++++&quot;</span>);<br><span class="hljs-keyword">for</span> (Object o : linkedList) &#123;<br>System.out.println(o);<br>&#125;<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> linkedList.get(<span class="hljs-number">0</span>);<br>System.out.println(<span class="hljs-string">&quot;obj = &quot;</span> + obj);<br>System.out.println(linkedList.getFirst());<br>System.out.println(linkedList.getLast());<br></code></pre></td></tr></table></figure><ul><li>ArrayList 和 LinkedList 的比较</li></ul><table><thead><tr class="header"><th></th><th>底层结构</th><th>增删的效率</th><th>改查的效率</th></tr></thead><tbody><tr class="odd"><td>ArrayList</td><td>可变数组</td><td>较低(数组扩容)</td><td>较高</td></tr><tr class="even"><td>LinkedList</td><td>双向链表</td><td>较高(通过链表追加)</td><td>较低</td></tr></tbody></table><h3 id="vector">Vector</h3><ul><li>Vector 的基础介绍</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> 定义说明<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Vector</span>&lt;<span class="hljs-symbol">E</span>&gt; <span class="hljs-symbol">extends</span> <span class="hljs-symbol">AbstractList</span>&lt;<span class="hljs-symbol">E</span>&gt; <br><span class="hljs-symbol">implements</span> <span class="hljs-symbol">List</span>&lt;<span class="hljs-symbol">E</span>&gt;, <span class="hljs-symbol">RandomAccess, <span class="hljs-symbol">Cloneable</span>, <span class="hljs-symbol">Serializable</span></span> &#123;&#125;<br><span class="hljs-number">2.</span> Vector 底层也是一个对象数组, <span class="hljs-keyword">protected</span> Object[] elementData;<br><span class="hljs-number">3.</span> Vector 是线程同步的，即线程安全, Vector 类的操作方法带有 synchronized<br><span class="hljs-keyword">public</span> synchronized E <span class="hljs-keyword">get</span>(<span class="hljs-built_in">int</span> index) &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= elementCount)<br>            throw new ArrayIndexOutOfBoundsException(index);<br>        <span class="hljs-keyword">return</span> elementData(index);<br>    &#125;<br><span class="hljs-number">4.</span> 在开发中, 需要线程同步安全时，考虑使用Vector<br><span class="hljs-number">5.</span> 扩容机制与ArrayList不同之处在于前者<span class="hljs-number">2</span>倍，后者<span class="hljs-number">1.5</span>倍<br></code></pre></td></tr></table></figure><ul><li>Vector 和 ArrayList 的比较</li></ul><table><thead><tr class="header"><th></th><th>底层结构</th><th>版本</th><th>线程安全(同步)效率</th><th>扩容倍数</th></tr></thead><tbody><tr class="odd"><td>ArrayList</td><td>可变数组</td><td>jdk1.2</td><td>不安全，效率高</td><td>如果使用有参构造器，按照1.5倍扩容；<br />如果使用无参构造器：1.第一次扩容10，2.从第二次开始按照1.5倍</td></tr><tr class="even"><td>Vector</td><td>可变数组</td><td>jdk1.0</td><td>安全，效率高</td><td>如果无参构造器，默认初始10，满后按照2倍扩容；<br />如果是指定大小创建Vector,则每次按照2倍扩容</td></tr></tbody></table><h2 id="set-接口">Set 接口</h2><ul><li>基本介绍</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 无序(添加和取出的顺序不一致), 没有索引 【但是取出顺序固定】<br><span class="hljs-bullet">2.</span> 不允许重复元素, 所以最对包含一个null<br><span class="hljs-bullet">3.</span> JDK API中Set接口的实现类：HashSet, LinkedHashSet, TreeSet, ...<br><span class="hljs-bullet">4.</span> Set接口是Collection的子接口，常用方法和其一样<br><span class="hljs-bullet">5.</span> 遍历方式：a.迭代器; b.增强for (不能使用索引)<br></code></pre></td></tr></table></figure><h3 id="hashset">HashSet</h3><ul><li>HashSet的全面说明</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-number">1.</span> HashSet实现了Set接口<br><span class="hljs-number">2.</span> HashSet实际上是<span class="hljs-function">HashMap</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span>()</span> &#123;<br>map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>&#125;<br><span class="hljs-number">3.</span> 可以存放<span class="hljs-literal">null</span>值，但是只能有一个<span class="hljs-literal">null</span><br><span class="hljs-number">4.</span> HashSet不保证元素是有序的，取决于hash后，再确定索引的结果<br><span class="hljs-number">5.</span> 不能有重复元素、对象<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Set</span> <span class="hljs-variable">set</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;kim&quot;</span>)); <span class="hljs-comment">// T</span><br>set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;kim&quot;</span>)); <span class="hljs-comment">// T</span><br><br>set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>)); <span class="hljs-comment">// T</span><br>set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>)); <span class="hljs-comment">// F  String重写了equals()</span><br><span class="hljs-comment">/** ---HashMap.java---</span><br><span class="hljs-comment"> *// 找到索引位置，若对象相同或对象不同但对象的equals相同，则不能插入，把p(头结点)赋给e进行下一步操作</span><br><span class="hljs-comment"> *  if(p.hash == hash &amp;&amp; ((k = p.key) == key) || (key != null &amp;&amp; key.equals(k))) </span><br><span class="hljs-comment"> *  e = p;</span><br><span class="hljs-comment"> *  else if (p instanceof TreeNode)</span><br><span class="hljs-comment"> * e = ((TreeNode&lt;K, V&gt;)p).putTreeVal(this, tab, hash, key, value));</span><br><span class="hljs-comment"> *else &#123; // 如果table对应索引位置已经是一个链表，就使用for循环依次比较</span><br><span class="hljs-comment"> *   // (1) 依次和该链表的每一个元素比较后，都不相同则加入到该链表的尾部</span><br><span class="hljs-comment"> * for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="hljs-comment"> *        if ((e = p.next) == null) &#123;</span><br><span class="hljs-comment"> *             p.next = newNode(hash, key, value, null); // 新结点插入链表尾部</span><br><span class="hljs-comment"> *                if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="hljs-comment"> *                     treeifyBin(tab, hash); // 达8个结点 考虑是否要树化</span><br><span class="hljs-comment"> *                break;</span><br><span class="hljs-comment"> *           &#125;</span><br><span class="hljs-comment"> *           if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="hljs-comment"> *                break;</span><br><span class="hljs-comment"> *           p = e; // p后移, e = p.next (双指针)</span><br><span class="hljs-comment"> *       &#125;</span><br><span class="hljs-comment"> *   &#125;</span><br><span class="hljs-comment"> /</span><br></code></pre></td></tr></table></figure><ul><li>HashSet 底层机制</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown">HashSet底层是HashMap，HashMap底层是(数组 + 链表 + 红黑树)<br><span class="hljs-bullet">1.</span> 先获取元素的哈希值(hashCode方法， 一般来说不同对象hash值不同)<br><span class="hljs-bullet">2.</span> 对哈希值进行运算，得到一个索引值即为要存放在哈希表中的位置<br><span class="hljs-bullet">3.</span> 如果位置上没有其他元素，则直接存放；如果该位置上已经有其他元素，则需要进行equals判断，<br>  如果相等，则不再添加。如果不相等，则以链表的方式添加<br><span class="hljs-bullet">4.</span> 第一次添加时, table数组扩容到16，临界值(threshold)是16<span class="hljs-emphasis">*加载因子(loadfactor)是0.75 = 12</span><br><span class="hljs-emphasis">   (新Node就算, 不论加在table还是接在链表); 如果table数组使用到达临界值12, 就会扩容到16*</span>2 = 32, <br>   新的临界值是32<span class="hljs-emphasis">*0.75 = 24, 依次类推</span><br><span class="hljs-emphasis">5. 在Java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD(默认是8)，并且table的</span><br><span class="hljs-emphasis"> 大小&gt;=MIN TREEIFY CAPACITY(默认64). 就会进行树化(红黑树), 否则仍采取数组扩容机制</span><br></code></pre></td></tr></table></figure><ul><li>exercise 1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义一个Employee类, 当name和age的值相同时，认为时相同对象，不重复添加在HashSet中</span><br><span class="hljs-comment">// 方法: 重写 hashCode() 和 equals()</span><br><span class="hljs-keyword">package</span> com.company.collection_.set_;<br><br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Objects;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashSetExercise</span> &#123;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HashSet</span> <span class="hljs-variable">hashSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>        hashSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;Kim&quot;</span>, <span class="hljs-number">34</span>));<br>        hashSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;Lalo&quot;</span>, <span class="hljs-number">42</span>));<br>        hashSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;Kim&quot;</span>, <span class="hljs-number">34</span>));<br><br>        System.out.println(<span class="hljs-string">&quot;hashset = &quot;</span> + hashSet);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> (Employee) o;<br>        <span class="hljs-keyword">return</span> age == employee.age &amp;&amp; Objects.equals(name, employee.name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, age);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Employee&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&#x27;&quot;</span> + age + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 当name和birthday(MyDate类型)的值相同，则认为是同一员工</span><br><span class="hljs-keyword">package</span> com.company.collection_.set_;<br><br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashSetExercise</span> &#123;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HashSet</span> <span class="hljs-variable">hashSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>        <span class="hljs-type">MyDate</span> <span class="hljs-variable">myDate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyDate</span>(<span class="hljs-number">1998</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">MyDate</span> <span class="hljs-variable">myDate1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyDate</span>(<span class="hljs-number">1998</span>, <span class="hljs-number">12</span>, <span class="hljs-number">25</span>);<br>        hashSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;kim&quot;</span>, <span class="hljs-number">4000.0</span>, myDate));<br>        hashSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;kim&quot;</span>, <span class="hljs-number">4500.0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyDate</span>(<span class="hljs-number">1998</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>)));<br>        hashSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;jimmy&quot;</span>, <span class="hljs-number">4000.0</span>, myDate1));<br>        System.out.println(<span class="hljs-string">&quot;hashSet = &quot;</span> + hashSet);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Double sal;<br>    <span class="hljs-keyword">private</span> MyDate birthday;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">(String name, Double sal, MyDate birthday)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.sal = sal;<br>        <span class="hljs-built_in">this</span>.birthday = birthday;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> (Employee) o;<br>        <span class="hljs-keyword">return</span> Objects.equals(name, employee.name) &amp;&amp; Objects.equals(birthday, employee.birthday);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, birthday);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Employee&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, sal=&quot;</span> + sal +<br>                <span class="hljs-string">&quot;, birthday=&quot;</span> + birthday +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDate</span> &#123;<br>    <span class="hljs-type">int</span> year;<br>    <span class="hljs-type">int</span> month;<br>    <span class="hljs-type">int</span> day;<br><br>    MyDate(<span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day) &#123;<br>        <span class="hljs-built_in">this</span>.year = year;<br>        <span class="hljs-built_in">this</span>.month = (<span class="hljs-type">short</span>) month;<br>        <span class="hljs-built_in">this</span>.day = (<span class="hljs-type">short</span>) day;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">MyDate</span> <span class="hljs-variable">myDate</span> <span class="hljs-operator">=</span> (MyDate) o;<br>        <span class="hljs-keyword">return</span> year == myDate.year &amp;&amp; month == myDate.month &amp;&amp; day == myDate.day;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(year, month, day);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyDate&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;year=&quot;</span> + year +<br>                <span class="hljs-string">&quot;, month=&quot;</span> + month +<br>                <span class="hljs-string">&quot;, day=&quot;</span> + day +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>exercise 2</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 重写hashCode和equals方法会影响remove方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashSetEx</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HashSet</span> <span class="hljs-variable">set</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;morty&quot;</span>, <span class="hljs-number">16</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;rick&quot;</span>, <span class="hljs-number">50</span>);<br>        set.add(p1);<br>        set.add(p2);<br>        System.out.println(set);<br>        p1.id = <span class="hljs-number">20</span>; <span class="hljs-comment">// 更改p1的id会影响其hash值，进而影响其在table中新的索引位置</span><br>        set.remove(p1); <span class="hljs-comment">// 在table中删除失败</span><br>        System.out.println(set);<br><br>        set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;morty&quot;</span>, <span class="hljs-number">16</span>));<br>        System.out.println(set);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) o;<br>        <span class="hljs-keyword">return</span> id == person.id &amp;&amp; Objects.equals(name, person.name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, id);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\nPerson&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, id=&quot;</span> + id +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="linkedhashset">LinkedHashSet</h3><ul><li>LinkedHashSet的全面说明</li></ul><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-number">1</span>. LinkedHashSet是HashSet的子类(LinkedHashSet<span class="hljs-built_in">有head</span><span class="hljs-built_in">和tail</span>)<br><span class="hljs-number">2</span>. LinkedHashSet底层是一个LinkedHashMap, 底层维护了一个 数组 + 双向链表(before, after); <br>  添加第一个元素时，将数组table(类型HashMap<span class="hljs-variable">$Node</span>)扩容到<span class="hljs-number">16</span>, 存放的结点类型是LinkedHashMap<span class="hljs-variable">$Entry</span><br>   (继承自Node, 继承关系发生在内部类)<br><span class="hljs-number">3</span>. LinkedHashSet 根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，<br>   这使得元素看起来是以插入顺序保存的。<br><span class="hljs-built_in">tail</span>.<span class="hljs-keyword">next</span> = newElement, newElement.pre =<span class="hljs-built_in"> tail</span>,<span class="hljs-built_in"> tail</span> = newElement;<br><span class="hljs-number">4</span>. LinkedHashSet不允许添加重复元素<br></code></pre></td></tr></table></figure><h3 id="treeset">TreeSet</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-number">1.</span> <span class="hljs-title class_">TreeSet</span> 底层是 <span class="hljs-title class_">TreeMap</span>, 有序<br><span class="hljs-number">2.</span> 无参构造器默认按字典序排序<br><span class="hljs-comment">// TreeMap提供一个有参构造器传入一个比较器(匿名内部类)并指定排序规则</span><br><span class="hljs-title class_">TreeSet</span> treeSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>() &#123; <br>    <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> int <span class="hljs-title function_">compare</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> o1, <span class="hljs-built_in">Object</span> o2</span>) &#123;<br>        <span class="hljs-comment">// 调用Sting的compareTo方法进行字符串大小比较</span><br>    <span class="hljs-keyword">return</span> ((<span class="hljs-title class_">String</span>) o2).<span class="hljs-title function_">compareTo</span>((<span class="hljs-title class_">String</span>) o1); <span class="hljs-comment">// o2和o1比较 字典序逆序</span><br>    <span class="hljs-comment">// return ((String) o1)).length() - ((String) o2)).length(); // 按长度排序, 相同长度则不会被添加</span><br>    &#125;<br>    &#125;);<br><span class="hljs-number">3.</span> i. 构造器把传入的比较器对象赋给<span class="hljs-title class_">TreeSet</span>的底层的<span class="hljs-title class_">TreeMap</span>的属性<span class="hljs-variable language_">this</span>.<span class="hljs-property">comparator</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">TreeMap</span>(<span class="hljs-title class_">Comparator</span>&lt;? <span class="hljs-variable language_">super</span> K comparator) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">comparator</span> = comparator;<br>&#125;<br>   ii. 在调用tree.<span class="hljs-title function_">add</span>()时, 会执行<span class="hljs-keyword">return</span> m.<span class="hljs-title function_">put</span>(e, <span class="hljs-variable constant_">PRESENT</span>) == <span class="hljs-literal">null</span>, 底层：<br>    <span class="hljs-keyword">if</span> (cpr != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// cpr就是匿名内部类(对象)</span><br>    <span class="hljs-keyword">do</span> &#123;<br>    parent = t;<br>    cmp = cpr.<span class="hljs-title function_">compare</span>(key, t.<span class="hljs-property">key</span>); <span class="hljs-comment">// 动态绑定到匿名内部类(对象)compare</span><br>    <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>)<br>    t = t.<span class="hljs-property">left</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>)<br>    t = t.<span class="hljs-property">right</span>;<br>    <span class="hljs-keyword">else</span>  <span class="hljs-comment">// 如果相等, 即返回0, 这个key就没有加入</span><br>    <span class="hljs-keyword">return</span> t.<span class="hljs-title function_">setValue</span>(value);<br>    &#125; <span class="hljs-keyword">while</span> (t != <span class="hljs-literal">null</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>分析 <code>HashSet</code> 和 <code>TreeSet</code>分别是如何实现去重的</li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(1)</span> HashSet的去重机制: hashCode<span class="hljs-comment">()</span> + equals<span class="hljs-comment">()</span>, 底层先通过存入对象, 进行运算得到一个hash值，<br>通过hash值得到对应的索引，如果发现table索引所在的位置，没有数据，就直接存放, 如果有数据，就进行<br>equals比较[遍历比较]，如果比较后，不相同就加入，否则就不加入.<br><span class="hljs-comment">(2)</span> TreeSet的去重机制: 如果你传入了一个Comparator匿名对象，就使用实现的compare去重，如果方法返回<span class="hljs-number">0</span>, <br>就认为是相同的元素/数据，就不添加，如果没有传入一个Comparator匿名对象, 则以添加对象实现的Compareable<br>接口的compareTo去重.[若对象没有实现Compareable则添加对象会抛出异常] <br>源码: Comparable&lt;? super K&gt; k = <span class="hljs-comment">(Comparable&lt;? super K&gt;)</span> key; <span class="hljs-comment">// 向上转型</span><br></code></pre></td></tr></table></figure><h1 id="map-接口">Map 接口</h1><ul><li>Map接口实现类的特点(jdk8)</li></ul><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-number">1</span>) <span class="hljs-built_in">Map</span>与Collection并列存在。用于保存具有映射关系的数据:Key<span class="hljs-params">-Value</span><br><span class="hljs-number">2</span>) <span class="hljs-built_in">Map</span>中的key和value可以是任何引用类型的数据, 会封装到HashMap$Node对象中<br>HashMap$Node node = <span class="hljs-literal">new</span> Node(hash, key, value, <span class="hljs-built_in">null</span>)<br>k<span class="hljs-params">-v</span>为了遍历方便，还会创建EntrySet集合，该集合存放的元素类型Entry，而一个Entry对象就有<br>k,v EntrySet&lt;Entry&lt;K,V&gt;&gt; 即： transient <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">Map</span>.Entry&lt;K,V&gt;&gt; entrySet;<br><span class="hljs-number">3</span>) <span class="hljs-built_in">Map</span>中的key不允许重复，原因和HashSet一样.<br><span class="hljs-number">4</span>) <span class="hljs-built_in">Map</span>中的value可以重复【<span class="hljs-built_in">Set</span>继承自<span class="hljs-built_in">Map</span>, 其value全为常量PRESENT = <span class="hljs-literal">New</span> Object()】<br><span class="hljs-number">5</span>) <span class="hljs-built_in">Map</span>的key可以为<span class="hljs-built_in">null</span>, value也可以为<span class="hljs-built_in">null</span>，注意 key为<span class="hljs-built_in">null</span>, 只能有一个, value为<span class="hljs-built_in">null</span>,可以多个.<br><span class="hljs-number">6</span>) 常用<span class="hljs-built_in">String</span>类作为<span class="hljs-built_in">Map</span>的key<br><span class="hljs-number">7</span>) key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value<br></code></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/nessaj7/ImageHost/img/202206251127359.png" /></p><p>Set和Collection中 <code>HashMap$EntrySet</code> 都是指向<code>HashMap$Node</code> 的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hash</span>.Map();<br>map.put(<span class="hljs-string">&quot;no1&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>);<br>map.put(<span class="hljs-string">&quot;no2&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br><br><span class="hljs-type">Set</span> <span class="hljs-variable">set</span> <span class="hljs-operator">=</span> map.entrySet();<br>System.out.println(set.getClass()); <span class="hljs-comment">// HashMap$EntrySet</span><br><span class="hljs-keyword">for</span> (Object obj : set) &#123;<br>System.out.println(obj.getClass()); <span class="hljs-comment">// HashMap$Node</span><br>    Map.<span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> (Map.Entry) obj; <span class="hljs-comment">// 向下转型</span><br>    System.out.println(entry.getKey() + <span class="hljs-string">&quot; - &quot;</span> + entry.getValue());<br>&#125;<br><span class="hljs-comment">// entrySet中，定义类型是Map.Entry，但实际存放还是HashMap$Node</span><br><span class="hljs-comment">// 因为源码 static class Node&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; &#123;&#125;</span><br><span class="hljs-comment">// 当把HashMap$Node对象存放在entrySet后就方便我们遍历，因为后者提供了K getKey()和V getValue()方法, 取出的类型都是Object</span><br><br><span class="hljs-type">Set</span> <span class="hljs-variable">set1</span> <span class="hljs-operator">=</span> map.keySet();<br>System.out.println(set1.getClass()); <span class="hljs-comment">// Set的实现类KeySet</span><br><span class="hljs-type">Collection</span> <span class="hljs-variable">values</span> <span class="hljs-operator">=</span> map.values();<br>System.out.println(values.getClass()); <span class="hljs-comment">// Collection的实现类Values</span><br></code></pre></td></tr></table></figure><ul><li>Map接口常用方法</li></ul><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span>. <span class="hljs-keyword">put</span>(k, v): 添加<br><span class="hljs-number">2</span>. <span class="hljs-keyword">get</span>: 根据键获取值 【与<span class="hljs-keyword">List</span>的区别】<br><span class="hljs-number">3</span>. <span class="hljs-comment">remove: 根据键删除映射关系</span><br><span class="hljs-number">4</span>. putAll: 添加多个<br><span class="hljs-number">5</span>. clean: 清空<br><span class="hljs-number">6</span>. containsKey: 查找键是否存在<br><span class="hljs-number">7</span>. containsValue: 查找值是否存在<br><span class="hljs-number">8</span>. size: 获取元素个数<br><span class="hljs-number">9</span>. isEmpty: 判断是否为空<br></code></pre></td></tr></table></figure><ul><li>Map接口遍历方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 第一组 keySet: 获取所有的键, 通过key取出对应的value</span><br><span class="hljs-type">Set</span> <span class="hljs-variable">keyset</span> <span class="hljs-operator">=</span> map.keySet();<br><span class="hljs-comment">// (1) 增强for [最简单]</span><br><span class="hljs-keyword">for</span> (Object key : keyset) &#123;<br>System.out.println(key + <span class="hljs-string">&quot; - &quot;</span> + map.get(key));<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;---------------------&quot;</span>);<br><span class="hljs-comment">// (2) iterator</span><br><span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> keyset.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br><span class="hljs-type">Object</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span>  iterator.next();<br>System.out.println(key + <span class="hljs-string">&quot; - &quot;</span> + map.get(key));<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;---------------------&quot;</span>);<br><br><span class="hljs-comment">// 第二组 values: 获取所有的值</span><br><span class="hljs-type">Collection</span> <span class="hljs-variable">values</span> <span class="hljs-operator">=</span> map.values();<br><span class="hljs-comment">// (1) 增强for</span><br><span class="hljs-keyword">for</span> (Object value : values) &#123;<br>    System.out.println(value);<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;---------------------&quot;</span>);<br><span class="hljs-comment">// (2) iterator</span><br><span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator1</span> <span class="hljs-operator">=</span> values.iterator();<br><span class="hljs-keyword">while</span> (iterator1.hasNext()) &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> iterator1.next();<br>    System.out.println(value);<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;---------------------&quot;</span>);<br><br><span class="hljs-comment">// 第三组 entrySet: 获取所有关系</span><br><span class="hljs-type">Set</span> <span class="hljs-variable">entryset</span> <span class="hljs-operator">=</span> map.entrySet();<br><span class="hljs-comment">// (1) 增强for</span><br><span class="hljs-keyword">for</span> (Object kv : entryset) &#123;<br>    Map.<span class="hljs-type">Entry</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> (Map.Entry) kv; <span class="hljs-comment">// 向下转型 以使用Map.Entry的方法</span><br>    System.out.println(item.getKey() + <span class="hljs-string">&quot; - &quot;</span> + item.getValue());<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;---------------------&quot;</span>);<br><span class="hljs-comment">// (2) iterator</span><br><span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator2</span> <span class="hljs-operator">=</span> entryset.iterator();<br><span class="hljs-keyword">while</span> (iterator2.hasNext()) &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">kv</span> <span class="hljs-operator">=</span> iterator2.next(); <span class="hljs-comment">// kv的编译类型是Object, 运行类型是HashMap$Node</span><br>    Map.<span class="hljs-type">Entry</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> (Map.Entry) kv; <span class="hljs-comment">// 向下转型</span><br>    System.out.println(item.getKey() + <span class="hljs-string">&quot; - &quot;</span> + item.getValue());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="hashmap">HashMap</h2><ul><li>HashMap概要</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-number">1.</span> <span class="hljs-built_in">HashMap</span>是Map接口使用频率最高的实现类<br><span class="hljs-number">2.</span> <span class="hljs-built_in">HashMap</span>是以<span class="hljs-built_in">key</span>-value对的方式来存储数据<br><span class="hljs-number">3.</span> <span class="hljs-built_in">key</span>不能重复，但是值可以重复，允许使用<span class="hljs-literal">null</span>键和<span class="hljs-literal">null</span>值<br><span class="hljs-number">4.</span> 如果添加相同的<span class="hljs-built_in">key</span>, 则会覆盖原来的<span class="hljs-built_in">key</span>-value, 等同于修改<br>   <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>   V oldValue = e.<span class="hljs-property">value</span>;<br>   <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>   e.<span class="hljs-property">value</span> = value; <span class="hljs-comment">// 源码中替换的关键代码</span><br>   <span class="hljs-title function_">afterNodeAccess</span>(e);<br>   <span class="hljs-keyword">return</span> oldValue;<br>   &#125;<br><span class="hljs-number">5.</span> 与HashSet一样, 不保证映射的顺序，因为底层是以hash表的方式来存储的<br><span class="hljs-number">6.</span> <span class="hljs-built_in">HashMap</span>没有实现同步，因此是线程不安全的<br></code></pre></td></tr></table></figure><ul><li>HashMap底层机制</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs livescript">- (k,v)是一个Node实现了<span class="hljs-built_in">Map</span>.Entry&lt;K,V&gt;, 查看 HashMap的源码可以看到.<br>- jdk7.<span class="hljs-number">0</span>的hashmap底层实现[数组+链表], jdk8.<span class="hljs-number">0</span>底层[数组+链表+红黑树]<br><br>扩容机制和HashSet完全一致<br><span class="hljs-number">1</span>) HashMap底层维护了Node类型的数组table，默认为<span class="hljs-literal">null</span><br><span class="hljs-number">2</span>) 当创建对象时，将加载因子(loadfactor)初始化为<span class="hljs-number">0.75</span>.<br><span class="hljs-number">3</span>) 当添加key-val时，通过key的哈希值得到在table的索引。然后判断该索引处是否有元素, 如果没有元素直接添加。<br>  如果该索引处有元素，继续判断该元素的key和准备加入的key相是否等,如果相等，则直接替换val; <br>    如果不相等需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要扩容resize()。<br><span class="hljs-number">4</span>) 第<span class="hljs-number">1</span>次添加，则需要扩容table容量为<span class="hljs-number">16</span>，临界值(threshold)为<span class="hljs-number">12</span> (<span class="hljs-number">16</span>*<span class="hljs-number">0.75</span>)<br><span class="hljs-number">5</span>) 以后再扩容，则需要扩容table容量为原来的<span class="hljs-number">2</span>倍(<span class="hljs-number">32</span>),临界值为原来的<span class="hljs-number">2</span>倍,即<span class="hljs-number">24</span>, 依次类推【注意：扩容table后，hash值会变化】<br><span class="hljs-number">0</span> -&gt; <span class="hljs-number">16</span><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">12</span>)</span> -&gt;</span> <span class="hljs-number">32</span><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">24</span>)</span> -&gt;</span> <span class="hljs-number">64</span><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">48</span>)</span> -&gt;</span> <span class="hljs-number">128</span><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">96</span>)</span> -&gt;</span> ...<br><span class="hljs-number">6</span>) 在Java8中,如果一条链表的元素个数超过TREEIFY_THRESHOLD(默认是<span class="hljs-number">8</span>)，并且table的大小 &gt;= MIN_TREEIFY_CAPACITY(默认<span class="hljs-number">64</span>),<br>  就会进行树化(红黑树)<br></code></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/nessaj7/ImageHost/img/202206252128232.png" /></p><ul><li>源码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 1. 执行构造器 new HashMap()</span><br><span class="hljs-comment">   初始化加载因子 loadfactor = 0.75 */</span><br>   HashMap$Node[] table = <span class="hljs-literal">null</span><br><span class="hljs-comment">/* 2. 执行put调用hash方法，计算key的hash值 (h = key.hashCode(0)) ^ (h &gt;&gt;&gt; 16) */</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br><span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-comment">/* 3. 执行putVal() */</span><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent, <span class="hljs-type">boolean</span> evict)</span> &#123;<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i; <span class="hljs-comment">// 辅助变量</span><br>        <span class="hljs-comment">// 如果底层的table数组为空，或者length=0，就扩容到16</span><br>        <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            n = (tab = resize()).length;<br>        <span class="hljs-comment">// 取出hash值对应的table的索引位置的Node, 如果为null, 就直接把加入的k-v创建成一个Node, 加入该位置即可</span><br>        <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>            tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            Node&lt;K,V&gt; e; K k; <span class="hljs-comment">// 辅助变量</span><br>            <span class="hljs-comment">// 如果table的索引位置的key的hash相同和新的key的hash值相同，</span><br>            <span class="hljs-comment">// 并满足(table现有的结点的key和准备添加的key是同一个对象 || equals返回真)</span><br>            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                e = p; <br>            <span class="hljs-comment">// 如果当前的table的已有的Node是红黑树，就按照红黑树的方式处理</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果找到的结点，后面是链表，就循环比较</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 如果整个链表没有和它相同，就加到该链表的最后</span><br>                        p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                        <span class="hljs-comment">// 加入后，判断当前链表的长度是否已经到8个，如果到了就调用treeifyBin方法进行红黑树的转换</span><br>                        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                            treeifyBin(tab, hash); <br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// 如果在循环比较过程中，发现有相同就break, 后边只是替换key对应的value</span><br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                        <span class="hljs-keyword">break</span>;<br>                    p = e;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>                <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>                <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>) e.value = value; <span class="hljs-comment">// 替换，key对应的value</span><br>                afterNodeAccess(e);<br>                <span class="hljs-keyword">return</span> oldValue;<br>            &#125;<br>        &#125;<br>        ++modCount; <span class="hljs-comment">// 每增加一个Node, 就size++</span><br>        <span class="hljs-keyword">if</span> (++size &gt; threshold) resize(); <span class="hljs-comment">// 如果size大于临界值 [12, 24, 48, ...]</span><br>        afterNodeInsertion(evict);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><span class="hljs-comment">/* 4. 关于树化 */</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> hash)</span> &#123;<br>        <span class="hljs-type">int</span> n, index; Node&lt;K,V&gt; e;<br>        <span class="hljs-comment">// 如果table为null, 或者大小还没到64，就暂时不树化，而是进行扩容</span><br>        <span class="hljs-comment">// 否则才会真正的树化 -&gt; 剪枝</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>            resize();<br>        ...<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="hashtable">Hashtable</h2><ul><li>Hashtable的基本介绍</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-number">1</span>) 存放的元素是键值对: 即<span class="hljs-type">K</span>-<span class="hljs-type">V</span><br><span class="hljs-number">2</span>) hashtable的键和值都不能为<span class="hljs-literal">null</span>, 否则会抛出<span class="hljs-type">NullPointerException</span><br><span class="hljs-number">3</span>) hashTable使用方法基本上和<span class="hljs-type">HashMap</span>一样<br><span class="hljs-number">4</span>) hashTable是线程安全的(synchronized)，hashMap是线程不安全的<br><span class="hljs-number">5</span>) 底层结构<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hashtable&lt;K</span>,<span class="hljs-title">V&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Dictionary&lt;K</span>,<span class="hljs-title">V&gt;</span> </span><br>implements <span class="hljs-type">Map</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt;, <span class="hljs-type">Cloneable</span>, java.io.<span class="hljs-type">Serializable</span> &#123; ... &#125;<br>   i. 底层有数组 <span class="hljs-type">Hashtable</span>$<span class="hljs-type">Entry</span>[] 初始化大小为<span class="hljs-number">11</span>, threshold为<span class="hljs-number">8</span> = <span class="hljs-number">11</span> * <span class="hljs-number">0.75</span><br>   ii. 当count &gt;= threshold时, 扩容 <span class="hljs-number">11</span>(<span class="hljs-number">8</span>) -&gt; <span class="hljs-number">23</span>(<span class="hljs-number">17</span>) -&gt; ... <span class="hljs-number">2</span>n + <span class="hljs-number">1</span>()<br>   iii. 执行方法 addEntry(hash, key, value, index) 添加<span class="hljs-type">K</span>-<span class="hljs-type">V</span> 封装到tabkle<br><br></code></pre></td></tr></table></figure><ul><li>Hashtable 和 HashMap 对比</li></ul><table><thead><tr class="header"><th></th><th>版本</th><th>线程安全(同步)</th><th>效率</th><th>允许null键null值</th></tr></thead><tbody><tr class="odd"><td>HashMap</td><td>1.2</td><td>不安全</td><td>高</td><td>可以</td></tr><tr class="even"><td>Hashtable</td><td>1.0</td><td>安全</td><td>较低</td><td>不可以</td></tr></tbody></table><h2 id="treemap">TreeMap</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maxima">同TreeSet<br><span class="hljs-number">1</span>. 构造器 Comparator<br><span class="hljs-number">2</span>. 调用<span class="hljs-built_in">put</span>()方法<br><span class="hljs-number">2.1</span> 第一次添加，把k-v封装到Entry对象，放入root<br><span class="hljs-number">2.2</span> 之后添加， 要和前面的对象比较 cmp = cpr.<span class="hljs-built_in">compare</span>(<span class="hljs-built_in">key</span>, t.<span class="hljs-built_in">key</span>); 动态绑定到重写的内部类<span class="hljs-built_in">compare</span>方法<br><span class="hljs-number">3</span>. 若按字符串长度比较，相同长度的字符串就添加不进去了，但是后者的value会更新前者的value<br></code></pre></td></tr></table></figure><h2 id="properties">Properties</h2><ul><li>基本介绍</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> Properties类继承自Hashtable类并且实现了Map接口，也是使用一种键值对的形式来保存数据。<br><span class="hljs-bullet">2.</span> 他的使用特点和Hashtable类似<br><span class="hljs-bullet">3.</span> Properties还可以用于从 xxxx.properties文件中，加载数据到Properties类对象,并进行读取和修改<br><span class="hljs-bullet">4.</span> 说明: xxx.properties文件通常作为配置文件, 在IO流中会用到<br></code></pre></td></tr></table></figure><ul><li>方法</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs maxima">Properties <span class="hljs-built_in">properties</span> = <span class="hljs-built_in">new</span> Properties();<br><span class="hljs-built_in">properties</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">100</span>); // 增加<br><br><span class="hljs-built_in">properties</span>.<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;hello&quot;</span>); // 通过<span class="hljs-built_in">key</span>获取对应值 <span class="hljs-built_in">get</span>继承自Hashtable，并声明返回Object.<br><br>Properties pro1 = <span class="hljs-built_in">new</span> Properties(<span class="hljs-built_in">properties</span>); <br>pro1.getProperties(<span class="hljs-string">&quot;hello&quot;</span>); // getProperty 由Properties 引入，声明返回String.<br><br><span class="hljs-built_in">properties</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">88</span>); // 修改<br><span class="hljs-built_in">properties</span>.<span class="hljs-built_in">remove</span>(<span class="hljs-string">&quot;hello&quot;</span>); // 删除<br></code></pre></td></tr></table></figure><h1 id="collections-工具类">Collections 工具类</h1><ul><li>Collections工具类介绍</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-number">1</span>) Collections是一个操作 Set、List和Map等集合的工具类<br><span class="hljs-number">2</span>) Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作<br><br>排序操作: (均为<span class="hljs-keyword">static</span>方法)<br><span class="hljs-number">1</span>) <span class="hljs-built_in">reverse</span>(List): 反转 List 中元素的顺序<br><span class="hljs-number">2</span>) <span class="hljs-title function_">shuffle</span>(List): 对 List 集合元素进行随机排序<br><span class="hljs-number">3</span>) <span class="hljs-built_in">sort</span>(List): 根据元素的自然顺序对指定 List 集合元素按升序排序<br><span class="hljs-number">4</span>) <span class="hljs-built_in">sort</span>(List, Comparator): 根据指定的 Comparator 产生的顺序对 List 集合元素进行排序<br><span class="hljs-number">5</span>) <span class="hljs-title function_">swap</span>(List, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>): 将指定 List 集合中的i处元素和j处元素进行交换<br><br>查找, 排序操作：<br><span class="hljs-number">1</span>) <span class="hljs-built_in">Object</span> <span class="hljs-built_in">max</span>(Collection): 根据元素的自然顺序，返回给定集合中的最大元素<br><span class="hljs-number">2</span>) <span class="hljs-built_in">Object</span> <span class="hljs-built_in">max</span>(Collection, Comparator): 根据Comparator指定的顺序,返回给定集合中的最大元素<br><span class="hljs-number">3</span>) <span class="hljs-built_in">Object</span> <span class="hljs-built_in">min</span>(Collection)<br><span class="hljs-number">4</span>) <span class="hljs-built_in">Object</span> <span class="hljs-built_in">min</span>(Collection, Comparator)<br><span class="hljs-number">5</span>) <span class="hljs-type">int</span> <span class="hljs-title function_">frequency</span>(Collection, <span class="hljs-built_in">Object</span>): 返回指定集合中指定元素的出现次数<br><span class="hljs-number">6</span>) <span class="hljs-keyword">void</span> <span class="hljs-built_in">copy</span>(List dest, List src): 将src中的内容复制到dest中<br><span class="hljs-number">7</span>) <span class="hljs-type">boolean</span> <span class="hljs-title function_">replaceAll</span>(List list, <span class="hljs-built_in">Object</span> oldVal, <span class="hljs-built_in">Object</span> newVal): 使用新值替换List 对象的所有旧值<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——常用类</title>
    <link href="/2022/06/17/1e13e3ebda05.html"/>
    <url>/2022/06/17/1e13e3ebda05.html</url>
    
    <content type="html"><![CDATA[<h2 id="包装类-wrapper">包装类 Wrapper</h2><h3 id="包装类的分类">包装类的分类</h3><ol type="1"><li>针对八种基本数据类型相应的<strong>引用类型</strong>——包装类</li><li>有了类的特点，就可以调用类中的方法</li></ol><table><thead><tr class="header"><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr class="odd"><td><code>boolean</code></td><td><code>Boolean</code></td></tr><tr class="even"><td><code>char</code></td><td><code>Character</code></td></tr><tr class="odd"><td><code>byte</code></td><td><code>Byte</code></td></tr><tr class="even"><td><code>short</code></td><td><code>Short</code></td></tr><tr class="odd"><td><code>int</code></td><td><code>Integer</code></td></tr><tr class="even"><td><code>long</code></td><td><code>Long</code></td></tr><tr class="odd"><td><code>float</code></td><td><code>Float</code></td></tr><tr class="even"><td><code>double</code></td><td><code>Double</code></td></tr></tbody></table><p>前两种包装类，实现 <code>Comparable</code> 和<code>Serializable</code> 接口</p><p>后六种包装类的父类为 <code>Number</code>， 这些包装类自身实现<code>Comparable</code> 接口, <code>Number</code> 实现<code>Serializable</code> 接口</p><h3 id="包装类和基本数据类型的转换">包装类和基本数据类型的转换</h3><ol type="1"><li>jdk5前的手动装箱和拆箱方式，装箱：基本类型 <spanclass="math inline">\(\rightarrow\)</span> 包装类型，反之，拆箱</li><li>jdk5以后(含jdk5)的自动装箱和拆箱方式</li><li>自动装箱底层调用的是 <code>valueOf</code> 方法，比如<code>Integer.valueOf()</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 手动装箱和拆箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(n1); <span class="hljs-comment">// 装箱1</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer1</span> <span class="hljs-operator">=</span> Integer.valueOf(n1); <span class="hljs-comment">// 装箱2</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> integer.intValue(); <span class="hljs-comment">// 拆箱</span><br><br><span class="hljs-comment">// 自动</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer2</span> <span class="hljs-operator">=</span> n2;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> integer2; <br></code></pre></td></tr></table></figure><h4 id="exercise">exercise</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>(<span class="hljs-number">2.0</span>);<br>System.out.println(obj1); <span class="hljs-comment">// 1.0</span><br></code></pre></td></tr></table></figure><p>三元运算符看作一个整体，提升精度</p><h3 id="包装类型和-string-类型的相互转换">包装类型和 String类型的相互转换</h3><p>以 <code>Integer</code> 和 <code>String</code> 转换为例，其它类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 包装类型 -&gt; String类型</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 方式1</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> i.toString();<br><span class="hljs-comment">// 方式2</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> String.valueOf(i);<br><span class="hljs-comment">// 方式3</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> i + <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-comment">// String 类型 -&gt; 包转类型</span><br><span class="hljs-comment">// 方式1</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(s1);<br><span class="hljs-comment">// 方式2</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">j2</span> <span class="hljs-operator">=</span> Integer.valueOf(s2);<br><br><span class="hljs-comment">// int类型 -&gt; String类型 (效率从高到低)</span><br>Integer.toString(<span class="hljs-type">int</span> i);<br>String.valueOf(<span class="hljs-type">int</span> i);<br>i + <span class="hljs-string">&quot;&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="integer-类和-character-类的常用方法">Integer 类和 Character类的常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer.MIN_VALUE  <span class="hljs-comment">// 返回最小值</span><br>Integer.MAX_VALUE  <span class="hljs-comment">// 返回最大值</span><br>    <br>Character.isDigit(<span class="hljs-string">&#x27;a&#x27;</span>)  <span class="hljs-comment">// 判断是不是数字</span><br>Character.isLetter(<span class="hljs-string">&#x27;a&#x27;</span>)  <span class="hljs-comment">// 判断是不是字母</span><br>Character.isUpperCase(<span class="hljs-string">&#x27;a&#x27;</span>);  <span class="hljs-comment">// 判断是不是大写</span><br>Character.isLowerCase(<span class="hljs-string">&#x27;a&#x27;</span>);<span class="hljs-comment">// 判断是不是小写</span><br><br>Character.isWhitespace(<span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-comment">// 判断是不是空格</span><br>Character.toUpperCase(<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-comment">// 转成大写</span><br>Character.toLowerCase(<span class="hljs-string">&#x27;A&#x27;</span>) <span class="hljs-comment">// 转成小写</span><br><br></code></pre></td></tr></table></figure><h4 id="exercise-1">exercise</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>);<br>    System.out.println(i == j);  <span class="hljs-comment">// false</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 自动装箱 Integer.valueOf(1);</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    System.out.println(m == n); <span class="hljs-comment">// true</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>    System.out.println(x == y); <span class="hljs-comment">// false</span><br>&#125;<br><br><span class="hljs-comment">// valueOf() 看范围， -128~127就直接返回，否则new Integer对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)  <span class="hljs-comment">// low = -128, high = 127</span><br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)]; <span class="hljs-comment">// 缓存数组 0 ~ 255</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>System.out.println(x == y); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 只要有基本数据类型，则判断值是否相等！</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>System.out.println(m == n); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="string-类">String 类</h2><p><imgsrc="https://cdn.jsdelivr.net/gh/nessaj7/ImageHost/img/202206162150923.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 源码 节选</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence,<br>               Constable, ConstantDesc &#123;<br><span class="hljs-comment">// 实现Serializable接口， 说明String可以串行化，网络传输</span><br>    <span class="hljs-comment">// 实现Comparable接口，说明String对象可以比较</span><br>    <br>    <span class="hljs-meta">@Stable</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] value;<br>    <span class="hljs-comment">// ...               </span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="string-类的理解和创建对象">String 类的理解和创建对象</h3><ol type="1"><li><code>String</code> 对象用于保存字符串，也就是一组字符序列；</li><li>字符串常量对象是用双引号括起的字符序列，例如：<code>"你好"</code>、<code>"12.97"</code>、<code>"girl"</code>；</li><li>字符串的字符使用Unicode字符编码，一个字符（不区分字母还是汉字）占两个字节；</li><li><code>String</code> 类较常用构造器：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(String original);<br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-type">char</span>[] a);<br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-type">char</span>[] a, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> count);<br><span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-type">byte</span>[] b);<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li><code>String</code> 类实现了Serializable接口，和Comparable接口，作用见上边注释；</li><li><code>String</code> 是 <code>final</code>类，不能被其他的类继承</li><li><code>String</code> 有属性 <code>private final byte[] value;</code>用于存放字符串内容（jdk8及以前是<code>char</code>），value 是一个<code>final</code>类型，<strong>地址</strong>不可修改，即value不可指向新的地址，但是单个字符内容是可以修改的。</li></ol><h3 id="创建-string-对象的两种方式">创建 String 对象的两种方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方式一：直接赋值</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><br><span class="hljs-comment">// 方式二：调用构造器</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>两种创建 String 对象的区别：<ul><li>方法一：先从常量池查看是否有"hello"数据空间，如果有，直接指向；如果没有则重新创建，然后指向。s最终指向常量池的空间地址；</li><li>方式二：先从堆中创建空间，里面维护了value属性，指向常量池的"hello"空间。如果常量池没有"hello"，重新创建，如果有，直接通过value指向。s最终指向的是堆中的空间地址；</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/nessaj7/ImageHost/img/202206171044473.png" width="500" div align="middle" ></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// exercise 1</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>System.out.println(a.equals(b)); <span class="hljs-comment">// T  String的equals被重写过</span><br>System.out.println(a == b); <span class="hljs-comment">// T 内存中指向同一地址</span><br><br><span class="hljs-comment">// exercise 2</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>System.out.println(a.equals(b)); <span class="hljs-comment">// T  String的equals被重写过</span><br>System.out.println(a == b); <span class="hljs-comment">// F 内存中指向不同地址</span><br><br><span class="hljs-comment">// exercise 3</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xyz&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;xyz&quot;</span>);<br>System.out.println(a == <span class="hljs-string">&quot;xyz&quot;</span>); <span class="hljs-comment">// T</span><br>System.out.println(a == b.intern()); <span class="hljs-comment">// T  b.intern()返回常量池的地址(对象)</span><br>System.out.println(b == b.intern()); <span class="hljs-comment">// F  堆地址 != 常量池地址</span><br></code></pre></td></tr></table></figure><p>当调用<code>intern</code>方法时，如果池已经包含一个等于此<code>String</code> 对象的字符串 （用 <code>equals(Object)</code>方法确定），则返回池中的字符串。否则，将此 <code>String</code>对象添加到池中，并返回此 <code>String</code> 对象的引用。 ####exercise</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;java&quot;</span>;   <span class="hljs-comment">// 栈 -&gt; 常量池1</span><br><span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(s1);  <span class="hljs-comment">// 栈 -&gt; 堆1 -&gt; 常量池1</span><br><span class="hljs-type">Animal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(s1);  <span class="hljs-comment">// 栈 -&gt; 堆2 -&gt; 常量池1</span><br>System.out.println(a == b);  <span class="hljs-comment">// F a和b指向不同对象</span><br>System.out.println(a.equals(b)); <span class="hljs-comment">// F  Animal类的equals没有被重写， equals仍然判断a和b是否是同一个对象</span><br>System.out.println(a.name == b.name); <span class="hljs-comment">// T a.name和b.name指向同一对象</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;java&quot;</span>); <span class="hljs-comment">// 栈 -&gt; 堆(value) -&gt; 常量池1</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;java&quot;</span>; <span class="hljs-comment">// 栈 -&gt; 常量池1</span><br>System.out.println(s1 == s4); <span class="hljs-comment">// F</span><br>System.out.println(s4 == s5); <span class="hljs-comment">// F</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span> + s1;  <span class="hljs-comment">// 引用拼接会调用new String   栈 -&gt; 堆(value) -&gt; 常量池2</span><br><span class="hljs-type">String</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hellojava&quot;</span>;   <span class="hljs-comment">// 栈 -&gt; 常量池2</span><br>System.out.println(t1.intern() == t2);  <span class="hljs-comment">// T   .intern()指向常量池</span><br></code></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/nessaj7/ImageHost/img/202206221137416.png" /></p><h3 id="字符串对象的特性">字符串对象的特性</h3><ol type="1"><li><code>String</code> 是一个 <code>final</code>类，代表不可变的字符序列</li><li>字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的。</li></ol><h4 id="exercise-2">exercise</h4><p>1）以下语句创建了几个对象？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>s1 = <span class="hljs-string">&quot;hhh&quot;</span>;<br><span class="hljs-comment">// 常量池创建了两个对象 s1先指向&quot;hello&quot;, 后指向&quot;hhh&quot;，而非直接修改&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p>2）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-comment">// 创建一个对象，编译器优化 判断创建的常量池对象，是否有引用指向</span><br><span class="hljs-comment">// 上述语句等价于 String a = &quot;helloabc&quot;;</span><br></code></pre></td></tr></table></figure><p>3）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 创建a对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;  <span class="hljs-comment">// 创建b对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;  <span class="hljs-comment">// c指向堆，堆指向常量池</span><br><span class="hljs-comment">// 创建三个String对象</span><br><span class="hljs-comment">/**jdk8</span><br><span class="hljs-comment">1. 先创建一个 StringBuilder 对象 sb</span><br><span class="hljs-comment">2. 执行 sb.append(&quot;hello&quot;); </span><br><span class="hljs-comment">3. 执行sb.append(&quot;abc&quot;);</span><br><span class="hljs-comment">4. 执行 String c = sb.toString();  // toString()里执行new String()</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 验证</span><br><span class="hljs-type">String</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot;abc&quot;</span>;<br>System.out.println(c == d); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>4）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;world&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;helloworld&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> (s1 + s2).intern();<br>System.out.println(s3 == s4); <span class="hljs-comment">// true</span><br>System.out.println(s3.equals(s4)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>5）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] ch = &#123;<span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(String str, <span class="hljs-type">char</span> ch[])</span> &#123;<br>        str = <span class="hljs-string">&quot;java&quot;</span>;<br>        ch[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;h&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Test1</span> <span class="hljs-variable">ex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>();<br>        ex.change(ex.str, ex.ch);<br>        System.out.print(ex.str + <span class="hljs-string">&quot; and &quot;</span>);  <span class="hljs-comment">// &quot;hello and &quot;</span><br>        System.out.println(ex.ch); <span class="hljs-comment">// hava</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/nessaj7/ImageHost/img/202206172047758.png" /></p><h3 id="string-类的常见方法">String 类的常见方法</h3><p><code>String</code>类是保存字符串常量的。每次更新都需要重新开辟空间，效率较低，因此Java设计者还提供了<code>StringBuilder</code> 和 <code>StringBuffer</code> 来增强<code>String</code> 的功能，并且提高效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">80000</span>; i ++ ) &#123;<br>    s += <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 拼接 每次都要常量池开辟空间</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>常见方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">equals <span class="hljs-comment">// 判断内容是否相等</span><br>equalsIgnoreCase <span class="hljs-comment">// 忽略大小写判断内容是否相等</span><br>length  <span class="hljs-comment">// 获取字符个数，即字符串的长度</span><br>indexOf  <span class="hljs-comment">// 获取字符在字符串中第一次出现的索引，索引从0开始，如果找不到则返回 -1</span><br>lastIndexOf  <span class="hljs-comment">// 获取字符在字符串中最后一次出现的索引，索引从0开始，如果找不到则返回 -1</span><br>substring  <span class="hljs-comment">// 截取指定范围的子串</span><br>trim  <span class="hljs-comment">// 去掉前后空格</span><br>charAt <span class="hljs-comment">// 获取某索引处的字符，注意String str = &quot;hello&quot;,不可使用str[idx]; 正确用法str.chatAt(idx)</span><br>    <br>toUpperCase  <span class="hljs-comment">// 转成大写</span><br>toLowerCase  <span class="hljs-comment">// 转成小写</span><br>concat  <span class="hljs-comment">// 拼接</span><br>replace <span class="hljs-comment">// 代替字符串中的字符， 注意：返回的对象被替换，原字符串没变！</span><br>split  <span class="hljs-comment">// 分割字符串，对于某些字符需要转义</span><br>compareTo <span class="hljs-comment">// 比较两个字符串的大小</span><br>toCharArray <span class="hljs-comment">// 转成字符数组</span><br>format  <span class="hljs-comment">// 格式化字符串， 占位符 %s字符串 %c字符 %d整数 %.2f浮点数</span><br></code></pre></td></tr></table></figure><h4 id="exercise-1-1">exercise 1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company.string_;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> nessaj</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/6/21 21:53</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringExercise</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdef&quot;</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            str = reverse(str, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 要接收</span><br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>            System.out.println(e.getMessage());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;交换后： &quot;</span> + str);<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">reverse</span><span class="hljs-params">(String str, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!(str != <span class="hljs-literal">null</span> &amp;&amp; start &gt;= <span class="hljs-number">0</span> &amp;&amp; end &lt; str.length() &amp;&amp; start &lt; end)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;参数不正确&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-type">char</span>[] chars = str.toCharArray(); <span class="hljs-comment">// String不可交换，先转成char[]</span><br>        <span class="hljs-type">char</span> tmp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start, j = end; i &lt; j; i++, j--) &#123;<br>            tmp = chars[i];<br>            chars[i] = chars[j];<br>            chars[j] = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br><span class="hljs-comment">//        return String.valueOf(chars);</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="exercise-2-1">exercise 2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company.string_;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> nessaj</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/6/22 10:38</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringExercise02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;kuhn&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">pwd</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123445&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">email</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;c_kudos@163.com&quot;</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            userRegister(name, pwd, email);<br>            System.out.println(<span class="hljs-string">&quot;正常运行...&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(e.getMessage());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 校验信息是否异常</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">userRegister</span><span class="hljs-params">(String name, String pwd, String email)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!(name != <span class="hljs-literal">null</span> &amp;&amp; pwd != <span class="hljs-literal">null</span> &amp;&amp; email != <span class="hljs-literal">null</span>)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;参数不能为空&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> name.length();<br>        <span class="hljs-keyword">if</span> (!(len &gt;= <span class="hljs-number">2</span> &amp;&amp; len &lt;= <span class="hljs-number">4</span>)) &#123;<br>            <span class="hljs-keyword">throw</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;用户名长度2~4&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!(pwd.length() &gt;= <span class="hljs-number">6</span> &amp;&amp; isDigital(pwd))) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;密码长度大于等于6，且全为数字&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx1</span> <span class="hljs-operator">=</span> email.indexOf(<span class="hljs-string">&#x27;@&#x27;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx2</span> <span class="hljs-operator">=</span> email.indexOf(<span class="hljs-string">&#x27;.&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (!(idx1 &gt; <span class="hljs-number">0</span> &amp;&amp; idx2 &gt; idx1)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;邮箱不合规范&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDigital</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-type">char</span>[] chars = str.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> aChar : chars) &#123;<br>            <span class="hljs-keyword">if</span> (aChar &lt; <span class="hljs-string">&#x27;0&#x27;</span> || aChar &gt; <span class="hljs-string">&#x27;9&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="stringbuffer-类">StringBuffer 类</h2><p><code>java.lang.StringBuffer</code>代表可变的字符序列，可以对字符串内容进行增删；很多方法与<code>String</code> 相同，但 <code>StringBuffer</code> 是可变长度的；<code>StringBuffer</code> 是一个容器。</p><p><imgsrc="https://cdn.jsdelivr.net/gh/nessaj7/ImageHost/img/202206172143280.png" /></p><p>在父类中， <code>AbstractStringBuilder</code> 有属性<code>byte[] value</code>，不是 <code>final</code>，该<code>value</code> 数组存放字符内容，存放在堆中而非常量池中。</p><p><code>StringBuffer</code> 是一个 <code>final</code>类，不能被继承。</p><h3 id="string-vs-stringbuffer">String VS StringBuffer</h3><ol type="1"><li><p><code>String</code> 保存的是字符串常量，里面的值不能更改，每次<code>String</code> 类的更新实际上就是更改地址，效率较低</p><p><code>private final byte value[];</code></p></li><li><p><code>StringBuffer</code>保存的是字符串变量，里面的值可以更改，每次<code>StringBuffer</code>的更新实际上可以更新内容，<strong>不用每次更新地址</strong>，效率较高</p><p><code>byte[] value; //这个放在堆中</code></p></li></ol><h3 id="stringbuffer-的构造器">StringBuffer 的构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">StringBuffer() <span class="hljs-comment">// 构造一个不带字符的字符串缓冲区，其初始容量为16个字符</span><br><br>StringBuffer(CharSequence seq)  <span class="hljs-comment">// 构造一个字符串缓冲区，包含与指定的CharSequence相同的字符</span><br>    <br>StringBuffer(<span class="hljs-type">int</span> capacity) <span class="hljs-comment">// 构造一个不带字符, 但具有指定初始容量的字符串缓冲区，即对 char[]/byte[] 大小进行指定</span><br>    <br>StringBuffer(String str)  <span class="hljs-comment">// 构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容</span><br><span class="hljs-comment">// str.length + 16</span><br></code></pre></td></tr></table></figure><h3 id="string-和-stringbuffer-相互转换">String 和 StringBuffer相互转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// String -&gt; StringBuffer</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-comment">// 方式1</span><br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(s);<br><span class="hljs-comment">// 方式2</span><br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>b2.append(s);<br><br><span class="hljs-comment">// StringBuffer -&gt; String</span><br><span class="hljs-comment">// 方式1</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> b1.toString(); <br><span class="hljs-comment">// 方式2</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(b1);<br></code></pre></td></tr></table></figure><h3 id="stringbuffer-类的常见方法">StringBuffer 类的常见方法</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">1.</span> 增 append<br><span class="hljs-number">2.</span> 删 <span class="hljs-built_in">delete</span>(<span class="hljs-built_in">start</span>, <span class="hljs-keyword">end</span>)<br><span class="hljs-number">3.</span> 改 <span class="hljs-built_in">replace</span>(<span class="hljs-built_in">start</span>, <span class="hljs-keyword">end</span>, <span class="hljs-keyword">string</span>)<span class="hljs-comment"> // 前开后闭</span><br><span class="hljs-number">4.</span> 查 indexOf<span class="hljs-comment"> // 返回索引位置</span><br><span class="hljs-number">5.</span> 插 insert<br><span class="hljs-number">6.</span> 获取长度 <span class="hljs-built_in">length</span>()<br></code></pre></td></tr></table></figure><h4 id="exercise-3">Exercise</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">String</span> str = <span class="hljs-keyword">null</span>;<br><span class="hljs-built_in">StringBuffer</span> sb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuffer</span>();<br>sb.append(str); <span class="hljs-comment">// 查看源码，底层调用AbstractStringBuilder的appendNull</span><br>System.out.println(sb.length()); <span class="hljs-comment">// 4</span><br><br>System.out.println(sb); <span class="hljs-comment">// &quot;null&quot;</span><br><span class="hljs-comment">// 下面构造器会抛出空指针异常</span><br><span class="hljs-built_in">StringBuffer</span> sb1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuffer</span>(str); <span class="hljs-comment">// 查看源码， super(str.length() + 16); </span><br>System.out.println(sb1);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;8123456.59&quot;</span>;<br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(price);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> sb.LastIndexOf(<span class="hljs-string">&quot;.&quot;</span>) - <span class="hljs-number">3</span>; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-number">3</span>) &#123; <span class="hljs-comment">// 先减3再判断插入</span><br>    sb = sb.insert(i, <span class="hljs-string">&quot;,&quot;</span>);<br>&#125;<br>System.out.println(sb); <span class="hljs-comment">// 8,123,456.59</span><br></code></pre></td></tr></table></figure><h2 id="stringbuilder-类">StringBuilder 类</h2><ol type="1"><li>一个可变的字符序列。此类提供一个与<code>StringBuffer</code>兼容的<code>API</code>，但不保证同步（<code>StringBuilder</code>不是线程安全）。该类被设计用作<code>StringBuffer</code>的一个简易替换，用在字符串缓冲区被<strong>单个线程</strong>使用的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比<code>StringBuffer</code> 要快。</li><li>在 <code>StringBuilder</code> 上的主要操作是 <code>append</code> 和<code>insert</code> 方法，可重载这些方法，以接受任意类型的数据。</li></ol><p><imgsrc="https://cdn.jsdelivr.net/gh/nessaj7/ImageHost/img/202206181635089.png" /></p><ul><li><p>串行化（对象可以网络传输，也可以保存到文件）</p></li><li><p><code>StringBuilder</code> 是 <code>final</code>类，不能被继承</p></li><li><p><code>StringBuilder</code> 对象字符序列仍然存放在其父类<code>AbstractStringBuilder</code>的 <code>byte[] value;</code>因此字符序列是在堆中</p></li><li><p><code>StringBuilder</code> 的方法没有做互斥处理，即没有<code>synchronized</code> 关键字</p></li></ul><h3 id="stringstringbuffer-和-stringbuilder-的比较">String、StringBuffer和 StringBuilder 的比较</h3><ol type="1"><li><p><code>StringBuilder</code> 和 <code>StringBuffer</code>非常类似，均代表可变的字符序列，而且方法也一样</p></li><li><p><code>String</code>：不可变字符序列，效率低，但是复用率高</p></li><li><p><code>StringBuffer</code>：可变字符序列、效率较高(增删)、线程安全</p></li><li><p><code>StringBuilder</code>：可变字符序列、效率最高、线程不安全</p></li><li><p>String使用注意说明:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<span class="hljs-comment">//创建了一个字符串</span><br>s += <span class="hljs-string">&quot;b&quot;</span>;<br><span class="hljs-comment">// 实际上原来的&quot;a&quot;字符串对象已经丢弃了，现在又产生了一个字符串s+&quot;b&quot;(也就是&quot;ab&quot;)。</span><br><span class="hljs-comment">// 如果多次执行这些改变串内容的操作,会导致大量副本字符串对象存留在内存中，降低效率。</span><br><span class="hljs-comment">// 如果这样的操作放到循环中，会极大影响程序的性能</span><br><span class="hljs-comment">// =&gt;结论:如果我们对String做大量修改，不要使用String</span><br></code></pre></td></tr></table></figure></li></ol><p>使用的原则，结论:</p><ol type="1"><li>如果字符串存在大量的修改操作，一般使用 <code>StringBuffer</code> 或<code>StringBuilder</code></li><li>如果字符串存在大量的修改操作，并在单线程的情况，使用<code>StringBuilder</code></li><li>如果字符串存在大量的修改操作，并在多线程的情况，使用<code>StringBuffer</code></li><li>如果我们字符串很少修改，被多个对象引用，使用<code>String</code>，比如配置信息等</li></ol><h2 id="math-类">Math 类</h2><p><code>Math</code>类包含用于执行基本数学运算的方法，如初等指数，对数，平方根和三角函数。都是静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">abs <span class="hljs-comment">// 绝对值</span><br>pow  <span class="hljs-comment">// 求幂</span><br>ceil <span class="hljs-comment">// 对一个数进行上舍入，返回值大于或等于给定的参数</span><br>floor <span class="hljs-comment">// 向下取整</span><br>round <span class="hljs-comment">// 四舍五入</span><br>sqrt  <span class="hljs-comment">// 开方</span><br>random  <span class="hljs-comment">// 随机数 [0,1)   (int)(a + Math.random() * (b - a + 1))</span><br>max <span class="hljs-comment">// 返回两个数最大值</span><br>min <span class="hljs-comment">// 返回两个数最小者</span><br></code></pre></td></tr></table></figure><h2 id="arrays-类">Arrays 类</h2><p><code>Arrays</code>里面包含了一系列静态方法，用于管理或操作数组(比如排序和搜索)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> toString 返回数组的字符串形式<br>Integer[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>Arrays.toString(arr) <span class="hljs-comment">// [1, 2, 3]</span><br><span class="hljs-number">2.</span> sort 排序 (自然排序和定制排序)<br>Integer arr[] = &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">89</span>&#125;;<br>Arrays.sort(arr); <span class="hljs-comment">// 因为数组是引用类型，所以通过sort排序会直接实参</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* sort重载，也可传入一个接口 Comparator 实现定制排序</span><br><span class="hljs-comment">* 实现Comparator接口的匿名内部类，要求实现 compare 方法</span><br><span class="hljs-comment">* compare 的返回值&gt;0 还是 &lt;0 影响底层二分排序的的选择，导致排序结果的变化</span><br><span class="hljs-comment">* 体现 接口编程 + 动态绑定机制 + 匿名内部类的综合使用</span><br><span class="hljs-comment">*/</span><br>Arrays.sort(arr, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object o1, Object o2)</span> &#123;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> (Integer) o1; <span class="hljs-comment">// 先下转型</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> (Integer) o2;<br><span class="hljs-keyword">return</span> i2 - i1; <span class="hljs-comment">// 逆序 底层：二分</span><br>&#125;<br>&#125;);<br><span class="hljs-number">3.</span> binarySearch 通过二分搜索法进行查, 要求必须排好序<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> Arrays.binarySearch(arr, <span class="hljs-number">3</span>); <span class="hljs-comment">// 不存在 则返回 -(应该在的位置 + 1)</span><br><span class="hljs-number">4.</span> copyOf 数组元素的复制<br>Integer[] newArr = Arrays.copyOf(arr, arr.length);<br><span class="hljs-number">5.</span> fill 数组元素的填充<br>Integer[] num = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;;<br>Arrays.fill(num, <span class="hljs-number">99</span>);<br><span class="hljs-number">6.</span> equals 比较两个数组元素内容是否完全一致<br><span class="hljs-type">boolean</span> <span class="hljs-variable">equals</span> <span class="hljs-operator">=</span> Arrays.equals(arr, arr2);<br><span class="hljs-number">7.</span> asList 将一组值，转换成list集合<br>    <span class="hljs-comment">// List接口</span><br>List&lt;Integer&gt; asList = Arrays.asList(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>);<br>System.out.println(<span class="hljs-string">&quot;asList = &quot;</span> + asList); <span class="hljs-comment">// [2, 3, 4, 5, 6, 1]</span><br>System.out.println(<span class="hljs-string">&quot;运行类型：&quot;</span>, + asList.getClass());  <span class="hljs-comment">// java.util.Arrays$ArrayList 静态内部类</span><br><br></code></pre></td></tr></table></figure><h3 id="模拟排序">模拟排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company.arrays_;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> nessaj</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/6/18 22:03</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArraysSortCustom</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">81</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">25</span>&#125;;<br>        bubble02(arr, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object o1, Object o2)</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> (Integer) o1; <span class="hljs-comment">// 自动拆箱</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> (Integer) o2;<br>                <span class="hljs-keyword">return</span> i2 - i1;  <span class="hljs-comment">// return i1 - i2;</span><br>            &#125;<br>        &#125;);<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br>    <br>    <span class="hljs-comment">// 冒泡</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubble</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[j];<br>                    arr[j] = arr[j + <span class="hljs-number">1</span>];<br>                    arr[j + <span class="hljs-number">1</span>] = tmp;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 结合 冒泡 + 定制</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubble02</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, Comparator c)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (c.compare(arr[j], arr[j + <span class="hljs-number">1</span>]) &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[j];<br>                    arr[j] = arr[j + <span class="hljs-number">1</span>];<br>                    arr[j + <span class="hljs-number">1</span>] = tmp;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="system">System</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>. <span class="hljs-keyword">exit</span> 退出当前程序<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>) 表示退出状态<br><span class="hljs-number">2</span>. arraycopy：复制数组元素，比较适合底层调用，一般使用Array.copyOf完成复制数组<br>int[] src = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>int[] dest = new int[<span class="hljs-number">3</span>]; <span class="hljs-regexp">//</span> dest 当前是 &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;<br>System.arraycopy(src, <span class="hljs-number">0</span>, dest, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);  <span class="hljs-regexp">//</span> <span class="hljs-number">3</span> 表示length<br><span class="hljs-number">3</span>. currentTimeMillens: 返回当前时间距离 <span class="hljs-number">1970</span>-<span class="hljs-number">1</span>-<span class="hljs-number">1</span> 的毫秒数<br><span class="hljs-number">4</span>. gc: 运行垃圾回收机制 System.gc();<br></code></pre></td></tr></table></figure><h2 id="bigintegerbigdecimal">BigInteger、BigDecimal</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 应用场景<br><span class="hljs-bullet">1.</span> BigInteger 适合保存比较大的整数<br><span class="hljs-bullet">2.</span> BigDecimal 适合保存精读更高的浮点数<br><br><span class="hljs-bullet">-</span> 常见方法<br><span class="hljs-bullet">1.</span> add 加<br><span class="hljs-bullet">2.</span> subtract 减<br><span class="hljs-bullet">3.</span> multiply 乘<br><span class="hljs-bullet">4.</span> divide 除 // bigDecimal.divide(x, BigDecimal.ROUND<span class="hljs-emphasis">_CELING); 指定精度，以防抛出异常</span><br></code></pre></td></tr></table></figure><h2 id="日期类">日期类</h2><h3 id="第一代日期类">第一代日期类</h3><ol type="1"><li><code>Date</code> 精确到毫秒，表示特定的瞬间</li><li><code>SimpleDateFormat</code> 格式和解析日期的类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company.date_;<br><br><span class="hljs-keyword">import</span> java.text.ParseException;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> nessaj</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/6/21 20:47</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Date01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException &#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(); <span class="hljs-comment">// 获取当前系统时间</span><br>        System.out.println(<span class="hljs-string">&quot;当前日期: &quot;</span> + d1);<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">9234567</span>); <span class="hljs-comment">// 通过指定毫秒数得到时间</span><br>        System.out.println(d1.getTime());  <span class="hljs-comment">// 获取某个时间对应的毫秒数</span><br><br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年MM月dd日 hh:mm:ss E&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> sdf.format(d1);<br>        System.out.println(format);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1996年01月01日 10:20:30 星期一&quot;</span>;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">parse</span> <span class="hljs-operator">=</span> sdf.parse(s);<br>        System.out.println(parse);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第二代日期类">第二代日期类</h3><ol type="1"><li><code>Calendar</code> 类（日历）</li><li><code>Calendar</code> 类是一个抽象类，它为特定瞬间与一组诸如 YEAR,MONTH, DAY_OF_MONTH, HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calendar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>, Cloneable, Comparable&lt;Calendar&gt; &#123;...&#125;<br><span class="hljs-comment">// 构造器protected，通过getInstance()获取实例</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calendar</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>System.out.println(c); <span class="hljs-comment">// 包含大量字段</span><br>System.out.println(c.get(Calendar.YEAR));<br>System.out.println(c.get(Calendar.MONTH) + <span class="hljs-number">1</span>);<br>System.out.println(c.get(Calendar.DAY_OF_MONTH));<br>System.out.println(c.get(Calendar.HOUR));   <span class="hljs-comment">// HOUR_OF_DAY 24时制</span><br>System.out.println(c.get(Calendar.MINUTE));<br>System.out.println(c.get(Calendar.SECOND));<br></code></pre></td></tr></table></figure><h3 id="第三代日期类">第三代日期类</h3><blockquote><p>前面两代日期类的不足分析 JDK1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK1.1引入Calendar类之后被弃用了。</p><p>而Calendar也存在问题是:</p><ol type="1"><li>可变性:像日期和时间这样的类应该是不可变的。</li><li>偏移性:Date中的年份是从1900开始的,而月份都从0开始。3)格式化:格式化只对Date有用，Calendar则不行。</li><li>此外，它们也不是线程安全的;不能处理闰秒等(每隔2天，多出1s)。</li></ol></blockquote><ol type="1"><li><code>LocalDate</code>（日期）、<code>LocalTime</code>（时间）、<code>LocalDateTime</code> （日期时间） jdk8加入</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">ldt</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>System.out.println(ldt);<br>ldt.getYear();<br>ldt.getMonthValue(); <br>ldt.getDayOfMonth(); <br>ldt.getHour();<br>ldt.getMinute();<br>ldt.getSecond();<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><code>DateTimeFormatter</code> 格式日期类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 类似于 SimpleDateFormat</span><br><span class="hljs-type">DateTimeFormat</span> <span class="hljs-variable">dtf</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(格式); <span class="hljs-comment">// YYYY-MM-DD hh:mm:ss</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> dtf.format(日期对象);<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><code>Instant</code> 时间戳</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Instant</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> Instant.now();<br>System.out.println(now);<br><br><span class="hljs-comment">// Instant -&gt; Date</span><br><span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> Date.from(now);<br><span class="hljs-comment">// Date -&gt;Instant</span><br><span class="hljs-type">Instant</span> <span class="hljs-variable">instant</span> <span class="hljs-operator">=</span> date.toInstant();<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>第三代日期类更多方法</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle">LocalLocalDateTime类<br>MonthDay类: 检查重复事件<br>是否是闰年<br>增加日期的某个部分<br>使用<span class="hljs-keyword">plus</span>方法测试增加时间的某个部分<br>使用<span class="hljs-keyword">minus</span>方法测试查看一年前和一年后的日期<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven 自动化的构建工具</title>
    <link href="/2022/05/28/c0a138f779af.html"/>
    <url>/2022/05/28/c0a138f779af.html</url>
    
    <content type="html"><![CDATA[<h1 id="maven-自动化的构建工具">Maven 自动化的构建工具</h1><h1 id="第一章-maven简介">第一章 Maven简介</h1><h2 id="软件开发中的阶段">1.1 软件开发中的阶段</h2><p>需要分析： 分析项目具体完成的功能，有什么要求， 具体怎么实现。</p><p>设计阶段：根据分析的结果， 设计项目的使用什么技术， 解决难点。</p><p>开发阶段：编码实现功能。 编译代码。自我测试</p><p>测试阶段：专业的测试人员，测整个项目的功能十分符合设计要求。出一个测试报告。</p><p>项目的打包，发布阶段： 给用户安装项目</p><span id="more"></span><h2 id="maven能做什么">1.2 Maven能做什么</h2><p>1）项目的自动构建，帮助开发人员做项目代码的编译，测试，打包，安装，部署等工作。</p><p>2）管理依赖（管理项目中使用的各种jar包）。</p><pre><code class="hljs">  依赖：项目中需要使用的其他资源，  常见的是jar 。 比如项目要使用mysql驱动。我们就说项目依赖mysql驱动。</code></pre><h2 id="没有使用maven怎么管理依赖">1.3 没有使用maven怎么管理依赖</h2><p>管理jar ，需要从网络中单独下载某个jar</p><p>需要选择正确版本</p><p>手工处理jar文件之间的依赖。 a.jar里面要使用b.jar的类。</p><h2 id="什么是maven">1.4 什么是maven</h2><p>maven是apache基金会的开源项目，使用java语法开发。 Maven这个单词的本意是：专家，内行。读音是['meɪv(ə)n] 或 ['mevn]。</p><p>maven是项目的自动化构建工具。 管理项目的依赖。</p><h2 id="maven中的概念">1.5 maven中的概念</h2><p>①POM ②约定的目录结构 ③坐标 ④依赖管理 ⑤仓库管理 ⑥生命周期 ⑦插件和目标⑧继承 ⑨聚合</p><h2 id="maven工具的获取和安装">1.6 maven工具的获取和安装</h2><p>地址： http://maven.apache.org/ 从中下载 .zip文件。 使用的apache-maven-3.3.9-bin.zip</p><p>安装：</p><ol type="1"><li><p>确定JAVA_HOME 指定jdk的安装目录， 如果没有JAVA_HOME，需要在windows的环境变量中创建JAVA_HOME, 它的值是jdk的安装目录</p></li><li><p>解压缩 apache-maven-3.3.9-bin.zip，把解压后的文件放到一个目录中。</p><p>目录的路径不要有中文， 不要有空格。</p></li><li><p>把maven安装目录中下的bin的路径添加到path中</p></li><li><p>测试maven的安装。 在命令行执行 <code>mvn -v</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">C:\Users\NING MEI&gt;mvn -v<br>Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)<br>Maven home: D:\tools\apache-maven-3.3.9\bin\..<br>Java version: 1.8.0_101, vendor: Oracle Corporation<br>Java home: C:\Program Files\Java\jdk1.8.0_101\jre<br>Default locale: zh_CN, platform encoding: GBK<br>OS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;dos&quot;<br></code></pre></td></tr></table></figure></li></ol><p>maven解压后的目录结构</p><figure><img src="Maven-自动化的构建工具/image-20201015162301261.png"alt="image-20201015162301261" /><figcaption aria-hidden="true">image-20201015162301261</figcaption></figure><p>maven的其他安装方式：</p><ol type="1"><li><p>确定JAVA_HOME是否有效</p></li><li><p>在环境变量中，创建一个叫做M2_HOME (或者MAVEN_HOME)，它的值是maven的安装目录</p><p>M2_HOME=D:-maven-3.3.9</p></li><li><p>在path环境变量中，加入 %M2_HOME%</p></li><li><p>测试maven的安装，在命令行执行 <code>mvn -v</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">C:\Users\NING MEI&gt;mvn -v<br>Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)<br>Maven home: D:\tools\apache-maven-3.3.9\bin\..<br>Java version: 1.8.0_101, vendor: Oracle Corporation<br>Java home: C:\Program Files\Java\jdk1.8.0_101\jre<br>Default locale: zh_CN, platform encoding: GBK<br>OS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;dos&quot;<br></code></pre></td></tr></table></figure></li></ol><h1 id="第二章maven的核心概念">第二章Maven的核心概念</h1><h2 id="约定的目录结构">2.1 约定的目录结构</h2><p>maven项目使用的大多人 遵循的目录结构。 叫做约定的目录结构。</p><p>一个maven项目是一个文件夹。 比如项目叫做Hello</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Hello 项目文件夹<br>    \src<br>    \main叫做主程序目录（完成项目功能的代码和配置文件）<br>             \java          源代码（包和相关的类定义）<br>     \resources    配置文件<br>    \test               放置测试程序代码的（开发人员自己写的测试代码）<br>     \java          测试代码的（junit）<br>     \resources     测试程序需要的配置文件<br>    \pom.xml                maven的配置文件， 核心文件<br></code></pre></td></tr></table></figure><p>maven的使用方式：</p><p>1）maven可以独立使用：创建项目，编译代码，测试程序，打包，部署等等</p><p>2）maven和idea一起使用：通过idea借助maven，实现编码，测试，打包等等</p><h2 id="pom">2.2 POM</h2><p>POM： Project Object Model 项目对象模型， maven把项目当做模型处理。操作这个模型就是操作项目。</p><p>maven通过pom.xml文件实现 项目的构建和依赖的管理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><br><span class="hljs-comment">&lt;!-- project是根标签， 后面的是约束文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <br>    <br>  <span class="hljs-comment">&lt;!-- pom模型的版本， 就是4.0.0 --&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 坐标 --&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.bjpowernode<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ch01-maven<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="坐标">2.3 坐标</h2><p>坐标组成是 groupid, artifiactId, version。 坐标概念来自数学。·</p><p>坐标作用：确定资源的，是资源的唯一标识。在maven中，每个资源都是坐标。 坐标值是唯一的。简称叫gav</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.bjpowernode<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ch01-maven<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>groupId: 组织名称，代码。 公司，团体或者单位的标识。 这个值常使用的公司域名的倒写。<br>         例如：学校的网站 www.bjpowernode.com, groupId: com.bjpowernode<br><br>         如果项目规模比较大， 也可以是 域名倒写+大项目名称。<br>     例如： www.baidu.com ,  无人车： com.baidu.appollo<br>artifactId:项目名称， 如果groupId中有项目， 此时当前的值就是子项目名。 项目名称是唯一的。<br>version：版本， 项目的版本号， 使用的数字。 三位组成。 例如 主版本号.次版本号.小版本号， 例如： 5.2.5。<br>         注意：版本号中有-SNAPSHOT， 表示快照，不是稳定的版本。      <br>   <br>packaging 项目打包的类型， 有jar ，war， ear， pom等等 默认是jar<br></code></pre></td></tr></table></figure><p>项目使用gav：</p><p>1.每个maven项目，都需要有一个自己的gav</p><p>2.管理依赖，需要使用其他的jar ，也需要使用gav作为标识。</p><p>搜索坐标的地址： https://mvnrepository.com/</p><h2 id="依赖-dependency">2.4 依赖 dependency</h2><p>依赖：项目中要使用的其他资源（jar）。</p><p>需要使用maven表示依赖，管理依赖。通过使用dependency和gav一起完成依赖的使用</p><p>需要在pom.xml文件中，使用dependencies 和dependency， 还有gav完成依赖的说明。</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <br>    <span class="hljs-comment">&lt;!-- 日志 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- mysql驱动 --&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span> <br><br>maven使用gav作为标识，从互联网下载依赖的jar。 下载到你的本机上。  由maven管理项目使用的这些jar<br></code></pre></td></tr></table></figure><h2 id="仓库">2.5 仓库</h2><p>仓库是存东西的，maven的仓库存放的是：</p><ol type="1"><li><p>maven工具自己的jar包。</p></li><li><p>第三方的其他jar， 比如项目中要使用mysql驱动。</p></li><li><p>自己写的程序，可以打包为jar 。 存放到仓库。</p></li></ol><p>仓库的分类：</p><ol type="1"><li><p>本地仓库（本机仓库）： 位于你自己的计算机，它是磁盘中的某个目录。</p><p>本地仓库：默认路径，是你登录操作系统的账号的目录中/.m2/repository</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">C:\Users\NING MEI\.m2\repository<br></code></pre></td></tr></table></figure><p>修改本地仓库的位置：修改maven工具的配置文件（maven的安装路径.xml）</p><p>步骤：</p><p>1）创建一个目录，作为仓库使用。 目录不要有中文和空格。目录不要太深。</p><pre><code class="hljs">    例如： D:\openrepository</code></pre><p>2）修改setting.xml文件，指定 D:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:/openrepository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">3) 把我给你提供的 仓库的资源 拷贝到 D:/openrepository</code></pre></li><li><p>远程仓库： 需要通过联网访问的</p><p>1）中央仓库： 一个ftp服务器， 存放了所有的资源。</p><p>2）中央仓库的镜像： 就是中央仓库的拷贝。 在各大主要城市都有镜像。</p><p>3）私服：在局域网中使用的。 私服就是自己的仓库服务器。在公司内部使用的。</p></li></ol><p>maven使用仓库： maven自动使用仓库， 当项目启动后，执行了maven的命令， maven首先访问的是本地仓库， 从仓库中获取所需的jar，如果本地仓库没有 ，需要访问私服或者中央仓库或者镜像。</p><figure><img src="Maven-自动化的构建工具/image-20201016114322189.png"alt="image-20201016114322189" /><figcaption aria-hidden="true">image-20201016114322189</figcaption></figure><h2 id="maven的生命周期插件和命令">2.6 maven的生命周期，插件和命令</h2><p>maven的生命周期： 项目构建的各个阶段。 包括 清理， 编译，测试，报告，打包，安装，部署</p><p>插件：要完成构建项目的各个阶段，要使用maven的命令，执行命令的功能是通过插件完成的。插件就是jar，一些类。</p><p>命令： 执行maven功能是 由命令发出的。 比如<code>mvn compile</code></p><p>单元测试（junit）：</p><p>junit是一个单元测试的工具， 在java中经常使用。</p><p>单元：在java中指的是方法。 一个方法就是一个单元，方法是测试的最小单位。</p><p>作用：使用junit去测试方法是否完成了要求。 开发人员自测。</p><p>使用单元测试：</p><p>1）加入junit的依赖（一些类和方法）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>2)在src/test/java 目录中创建测试类文件。 写测试代码</p><p>单元测试使用的建议：</p><pre><code class="hljs">1.测试类的定义， 名称一般是Test+要测试的类名称2.测试类它的包名和要测试的类包名一样。3.在类中定义方法，要测试代码。   方法的定义：public方法，                            没有返回值                           方法名称自定义（建议 Test+测试的方法名称）                           方法没有参数</code></pre><p>4.在测试类中的方法，可以单独执行。 测试类也可以单独执行</p><p>5.在方法的上面加入@Test</p><p>命令：</p><p>1） mvn clean: 清理命令， 作用删除以前生成的数据，删除target目录。</p><pre><code class="hljs">  插件： maven-clean-plugin   ， 版本是 2.5</code></pre><p>2）mvn compile:编译命令，执行的代码编译，把src/main/java目录中的java代码编译为class文件。</p><pre><code class="hljs"> 同时把class文件拷贝到 target/classes目录。 这个目录classes是存放类文件的根目录（也叫做类路径，classpath）插件： maven-compiler-plugin 版本3.1。  编译代码的插件            maven-resources-plugin 版本2.6 。 资源插件， 处理文件的。 作用是把src/main/resources目录中的                                                                         文件拷贝target/classes目录中。</code></pre><p>3）mvn test-compile: 编译命令， 编译src/test/java目录中的源文件，把生成的class拷贝到target/test-classes目录。同时把src/test/resources目录中的文件拷贝到test-clasess目录</p><pre><code class="hljs">插件： maven-compiler-plugin 版本3.1。  编译代码的插件            maven-resources-plugin 版本2.6 。 资源插件， 处理文件的</code></pre><p>4）mvn test:测试命令， 作用执行 test-classes目录的程序，测试src/main/java目录中的主程序代码是否符合要求。</p><pre><code class="hljs"> 插件： maven-surefire-plugin 版本 2.12.4</code></pre><p>5）mvnpackage:打包，作用是把项目中的资源class文件和配置文件都放到一个压缩文件中，默认压缩文件是jar类型的。 web应用是war类型， 扩展是jar，war的。</p><pre><code class="hljs">插件：maven-jar-plugin 版本 2.4。 执行打包处理。 生成一个jar扩展的文件， 放在target目录下.           打包的文件包含的是 src/main目录中的所有的生成的class和配置文件和test无关。生成的是 ch01-maven-1.0-SNAPSHOT.jar</code></pre><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.bjpowernode<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ch01-maven<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br>打包的文件名： artifactId-version.packaging<br></code></pre></td></tr></table></figure><p>6）mvn install : 把生成的打包的文件 ，安装到maven仓库。</p><pre><code class="hljs"> 插件： maven-install-plugin 版本 2.4 。 把生成的jar文件安装到本地仓库。 查看查看中的jar文件：</code></pre><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.bjpowernode<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ch01-maven<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>groupId中的值， 如果有 &quot;.&quot; 前和后都是独立的文件夹。 com\bjpowernode<br>artifactId, 独立的文件夹<br>version，独立的文件夹<br></code></pre></td></tr></table></figure><p>## 2.7 自定义配置插件</p><p>在pom.xml文件中， build标签中。设置插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 设置构建项目相关的内容 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 设置插件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span> <span class="hljs-comment">&lt;!-- 指定编译代码的jdk版本 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span> <span class="hljs-comment">&lt;!-- 运行java程序使用的jdk版本--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span> <br></code></pre></td></tr></table></figure><h1 id="第三章-maven和idea的集成">第三章 Maven和idea的集成</h1><h2 id="idea中集成maven">3.1 idea中集成maven</h2><p>idea中有一个自带的maven。 我们要让idea使用自己安装的maven。</p><ol type="1"><li>选择File- Settings</li></ol><figure><img src="Maven-自动化的构建工具/image-20201016151034872.png"alt="image-20201016151034872" /><figcaption aria-hidden="true">image-20201016151034872</figcaption></figure><figure><img src="Maven-自动化的构建工具/image-20201016151528678.png"alt="image-20201016151528678" /><figcaption aria-hidden="true">image-20201016151528678</figcaption></figure><p>设置项： <code>-DarchetypeCatalog=internal</code></p><p>2） File - Other Settings</p><figure><img src="Maven-自动化的构建工具/image-20201016151823967.png"alt="image-20201016151823967" /><figcaption aria-hidden="true">image-20201016151823967</figcaption></figure><p>同上的设置</p><h2 id="创建基于maven的普通java项目">3.2创建基于maven的普通java项目</h2><figure><img src="Maven-自动化的构建工具/image-20201016161028977.png"alt="image-20201016161028977" /><figcaption aria-hidden="true">image-20201016161028977</figcaption></figure><h2 id="创建web项目">3.3 创建web项目</h2><figure><img src="Maven-自动化的构建工具/image-20201016170153694.png"alt="image-20201016170153694" /><figcaption aria-hidden="true">image-20201016170153694</figcaption></figure><h2 id="导入module到idea">3.4 导入module到idea</h2><figure><img src="Maven-自动化的构建工具/image-20201017085816226.png"alt="image-20201017085816226" /><figcaption aria-hidden="true">image-20201017085816226</figcaption></figure><h1 id="第四章-依赖管理">第四章 依赖管理</h1><p>依赖范围：使用scope表示依赖的范围。</p><p>依赖范围表示：这个依赖（jar和里面类）在项目构建的哪个阶段起作用。</p><p>依赖范围scope ：</p><div class="note note-primary">            <p>compile:默认， 参与构建项目的所有阶段</p><p>test：测试，在测试阶段使用， 比如执行mvn test会使用junit 。</p><p>provided: 提供者。 项目在部署到服务器时，不需要提供这个依赖的jar ，而是由服务器这个依赖的jar包 明显的是servlet 和jsp 依赖</p>          </div><h1 id="第五章-常用设置">第五章 常用设置</h1><p>1)讲的是properties它里面的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span> 源码编译 jdk 版本<br><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span> 运行代码的 jdk 版本<br><span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span> 项目<br>构建使用的编码，避免中文乱码<br><span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<br><span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span> 生成报告的编码<br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>全局变量</li></ol><div class="note note-success">            <p>在properties定义标签，这个标签就是一个变量， 标签的文本就是变量的值。使用全局变量表示 多个依赖使用的版本号。</p>          </div><p>使用步骤：</p><p>1.在properties标签中，定义一个标签，指定版本的值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--自定义变量--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">spring.version</span>&gt;</span>5.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">junit.version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">junit.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>使用全局变量， 语法 ${变量名}</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3）使用资源插件</p><p>处理的配置文件的信息， maven默认处理配置文件</p><p>①：maven会把src/main/resources目录中的文件，拷贝到target/classes目录下</p><p>②：maven只处理src/main/java目录中的.java文件，把这些java文件编译为class，拷贝到 target/classes目录中。不处理其他文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--资源插件</span><br><span class="hljs-comment">      告诉maven把 src/main/java目录中的 指定扩展名的文件 拷贝到 target/classes目录中。</span><br><span class="hljs-comment">  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><span class="hljs-comment">&lt;!--所在的目录--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--包括目录下的.properties,.xml 文件都会扫描到--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  filtering 选项 false 不启用过滤器， *.property 已经起到过</span><br><span class="hljs-comment">        滤的作用了 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis学习笔记</title>
    <link href="/2022/05/25/01eae4a5ec0d.html"/>
    <url>/2022/05/25/01eae4a5ec0d.html</url>
    
    <content type="html"><![CDATA[<h2 id="mybatis概述">Mybatis概述</h2><h3 id="mybatis概念">Mybatis概念</h3><div class="note note-success">            <ul><li>MyBatis 是一款优秀的持久层框架，用于简化 JDBC 开发</li><li>MyBatis 本是 Apache 的一个开源项目iBatis, 2010年这个项目由apachesoftware foundation 迁移到了google code，并且改名为MyBatis。2013年11月迁移到Github</li><li>官网：https://mybatis.org/mybatis-3/zh/getting-started.html</li></ul>          </div><span id="more"></span><p><strong>持久层</strong>： - 负责将数据到保存到数据库的那一层代码。以后开发会将操作数据库的Java代码作为持久层。而Mybatis就是对jdbc代码进行了封装。- JavaEE三层架构：表现层、业务层、持久层</p><p><strong>框架</strong>： -框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型 -在框架的基础之上构建软件编写更加高效、规范、通用、可扩展</p><h3 id="jdbc-缺点">JDBC 缺点</h3><ul><li>硬编码<ul><li>注册驱动、获取连接上图标1的代码有很多字符串，而这些是连接数据库的四个基本信息，以后如果要将Mysql数据库换成其他的关系型数据库的话，这四个地方都需要修改，如果放在此处就意味着要修改我们的源代码。</li><li>SQL语句如果表结构发生变化，SQL语句就要进行更改。这也不方便后期的维护。</li></ul></li><li>操作繁琐<ul><li>手动设置参数</li><li>手动封装结果集对查询到的数据进行封装，而这部分代码是没有什么技术含量，而且特别耗费时间的。</li></ul></li></ul><h2 id="参考">参考：</h2><p><ahref="https://blog.csdn.net/qq_19387933/article/details/123256034">MyBatis笔记_苍茗的博客</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Singularity代替Docker</title>
    <link href="/2022/05/20/5a3de975bb65.html"/>
    <url>/2022/05/20/5a3de975bb65.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>Singularity是一种<strong>容器技术</strong>，用户可以在本地将软件打包成镜像，上传到服务器上运行。因为用户在本地计算机上拥有root权限，在制作软件的容器镜像时也拥有root权限，在部署安装应用的时候更加灵活。</p><p>在使用实验室服务器时，因为不是<code>root</code>用户，也没有<code>sudo</code>权限，一些环境的部署很是蛋疼。无意中了解到，使用Singularity刚好可以成为Docker的替代方案，故而开个坑。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/nessaj7/ImageHost/img/202205270108494.gif"alt="cat.gif" /><figcaption aria-hidden="true">cat.gif</figcaption></figure><h2 id="下载已存在镜像">下载已存在镜像</h2><p>和Docker类似，要运行 Singularity 也需要先获取镜像，Singularity可以从Singularity Hub 或者 Docker Hub来获取预编译的镜像，或者编译新镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 获取预编译镜像 （会在当前目录下下载 ubuntu_&lt;tag&gt;.sif 文件）</span><br>$ singularity pull ubuntu<br>$ singularity pull docker://ubuntu<br><br><span class="hljs-comment"># 从 Singularity Hub build 镜像</span><br>$ singularity -d build lolcow.simg shub://GodloveD/lolcow<br><br><span class="hljs-comment"># 从 Docker Hub build 镜像</span><br>$ singularity -d build lolcow.simg docker://godlovedc/lolcow<br>$ singularity -d build centos.simg docker://centos<br>$ singularity -d build ubuntu.simg docker://ubuntu<br></code></pre></td></tr></table></figure><h2 id="交互模式运行">交互模式运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ singularity shell --nv ubuntu.simg <span class="hljs-comment"># 启用 Nvidia GPU 支持 [ --nv ]</span><br>Singularity: Invoking an interactive shell within container...<br><br>Singularity ubuntu.simg:~&gt; <span class="hljs-built_in">pwd</span><br>/home/kuhn<br>Singularity ubuntu.simg:~&gt; <span class="hljs-built_in">id</span><br>uid=1000(admin) gid=1000(admin) <span class="hljs-built_in">groups</span>=1000(admin),10(wheel)<br><br>$ singularity <span class="hljs-built_in">exec</span> torch.sif python --version<br>Python 3.8.12<br></code></pre></td></tr></table></figure><h2 id="运行退出一个容器">运行&amp;退出一个容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">(base)kuhn@amax-59:~$ singularity run ubuntu.simg<br>kuhn@amax-59:~$ <span class="hljs-built_in">exit</span><br><span class="hljs-built_in">exit</span><br>(base)kuhn@amax-59:~$<br></code></pre></td></tr></table></figure><h2 id="后台运行容器实例">后台运行容器实例</h2><h3 id="启动实例">启动实例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ singularity instance start ubuntu.simg test1<br>$ singularity instance start ubuntu.simg test2<br></code></pre></td></tr></table></figure><h3 id="查看实例">查看实例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ singularity instance list<br>DAEMON NAME      PID      CONTAINER IMAGE<br>test1            14172    /home/admin/ubuntu.simg<br>test2            14239    /home/admin/ubuntu.simg<br></code></pre></td></tr></table></figure><h3 id="操作实例">操作实例</h3><p>可以通过 <code>shell</code>, <code>exec</code>, <code>run</code>命令来连到容器中运行命令</p><ul><li>使用 shell 命令连入容器</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ singularity shell instance://test1<br>Singularity ubuntu.simg:~&gt; ps -ef<br>UID        PID  PPID  C STIME TTY          TIME CMD<br>admin      1     0  0 03:14 ?        00:00:00 singularity-instance: admin [test1]<br>admin      3     0  3 03:14 pts/0    00:00:00 /bin/bash --norc<br>admin      4     3  0 03:14 pts/0    00:00:00 ps -ef<br></code></pre></td></tr></table></figure><ul><li>使用 exec 执行命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ singularity <span class="hljs-built_in">exec</span> instance://test1 ps -ef<br>UID        PID  PPID  C STIME TTY          TIME CMD<br>admin      1     0  0 03:14 ?        00:00:00 singularity-instance: admin[test1]<br>admin      6     0  0 03:15 pts/0    00:00:00 ps -ef<br></code></pre></td></tr></table></figure><h3 id="停止实例">停止实例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ singularity instance stop test1<br>$ singularity instance stop test2<br></code></pre></td></tr></table></figure><h2 id="reference">Reference</h2><p><ahref="https://sylabs.io/guides/3.9/user-guide/index.html">SingularityCEUser Guide Documentation</a></p><p><ahref="https://blog.csdn.net/CODE_RabbitV/article/details/120440819?ops_request_misc=%7B%22request%5Fid%22%3A%22165303096816781483780627%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=165303096816781483780627&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-120440819-null-null.142%5Ev10%5Epc_search_result_control_group,157%5Ev4%5Econtrol&amp;utm_term=singularity&amp;spm=1018.2226.3001.4187">Singularity快速上手, 带你飞</a></p><p><ahref="http://docs.hpc.whu.edu.cn/files/whuhpcdocs.wiki/sbatch/singularity.html">运行Singularity · GitBook (whu.edu.cn)</a></p><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Singularity</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell学习笔记</title>
    <link href="/2022/05/14/f13d77394742.html"/>
    <url>/2022/05/14/f13d77394742.html</url>
    
    <content type="html"><![CDATA[<h2 id="概论">概论</h2><p>shell是我们通过命令行与操作系统沟通的语言。</p><p>shell脚本可以直接在命令行中执行，也可以将一套逻辑组织成一个文件，方便复用。</p><p>Linux中常见的shell脚本有很多种，常见的有： - BourneShell(/usr/bin/sh或/bin/sh)</p><ul><li><p>Bourne Again Shell(/bin/bash)</p></li><li><p>C Shell(/usr/bin/csh)</p></li><li><p>K Shell(/usr/bin/ksh)</p></li><li><p>zsh</p></li><li><p>…<br /><span id="more"></span></p></li></ul><p>Linux系统中一般默认使用bash，文件开头需要写<code>#! /bin/bash</code>，指明bash为脚本解释器。</p><h3 id="脚本示例">脚本示例</h3><p>新建一个<code>test.sh</code>文件，内容如下： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello World!&quot;</span><br></code></pre></td></tr></table></figure> ###运行方式 作为可执行文件 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">chmod</span> +x test.sh <span class="hljs-comment"># 使脚本具有可执行权限</span><br>$ ./test.sh <span class="hljs-comment"># 当前路径下执行</span><br>Hello World!  <span class="hljs-comment"># 脚本输出</span><br></code></pre></td></tr></table></figure></p><p>用解释器执行 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ bash test.sh<br>Hello World!  <span class="hljs-comment"># 脚本输出</span><br></code></pre></td></tr></table></figure></p><h2 id="注释">注释</h2><h3 id="单行注释">单行注释</h3><p>每行中<code>#</code>之后的内容均是注释。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这是一行注释</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Hello World&#x27;</span>  <span class="hljs-comment"># 这也是注释</span><br></code></pre></td></tr></table></figure></p><h3 id="多行注释">多行注释</h3><p>格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">:&lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">第一行注释</span><br><span class="hljs-string">第二行注释</span><br><span class="hljs-string">第三行注释</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><p>其中<code>EOF</code>可以换成其它任意字符串。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">:&lt;&lt;<span class="hljs-string">abc</span><br><span class="hljs-string">第一行注释</span><br><span class="hljs-string">第二行注释</span><br><span class="hljs-string">第三行注释</span><br><span class="hljs-string">abc</span><br><br>:&lt;&lt;!<br>第一行注释<br>第二行注释<br>第三行注释<br>!<br></code></pre></td></tr></table></figure><h2 id="变量">变量</h2><h3 id="定义变量">定义变量</h3><p>定义变量，不需要加<code>$</code>符号，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">name1=<span class="hljs-string">&#x27;yxc&#x27;</span>  <span class="hljs-comment"># 单引号定义字符串</span><br>name2=<span class="hljs-string">&quot;yxc&quot;</span>  <span class="hljs-comment"># 双引号定义字符串</span><br>name3=yxc    <span class="hljs-comment"># 也可以不加引号，同样表示字符串</span><br></code></pre></td></tr></table></figure><h3 id="使用变量">使用变量</h3><p>使用变量，需要加上<code>$</code>符号，或者<code>$&#123;&#125;</code>符号。花括号是可选的，主要为了帮助解释器识别变量边界。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">name=yxc<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span>  <span class="hljs-comment"># 输出yxc</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;name&#125;</span>  <span class="hljs-comment"># 输出yxc</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;name&#125;</span>acwing  <span class="hljs-comment"># 输出yxcacwing</span><br></code></pre></td></tr></table></figure><h3 id="只读变量">只读变量</h3><p>使用<code>readonly</code>或者<code>declare</code>可以将变量变为只读。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">name=yxc<br><span class="hljs-built_in">readonly</span> name<br><span class="hljs-built_in">declare</span> -r name  <span class="hljs-comment"># 两种写法均可</span><br><br>name=abc  <span class="hljs-comment"># 会报错，因为此时name只读</span><br></code></pre></td></tr></table></figure><h3 id="删除变量">删除变量</h3><p><code>unset</code>可以删除变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">name=yxc<br><span class="hljs-built_in">unset</span> name<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span>  <span class="hljs-comment"># 输出空行</span><br></code></pre></td></tr></table></figure><h3 id="变量类型">变量类型</h3><ol type="1"><li>自定义变量(局部变量)：子进程不能访问的变量</li><li>环境变量(全局变量)：子进程可以访问的变量</li></ol><p>自定义变量改成环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ name=yxc  <span class="hljs-comment"># 定义变量</span><br>$ <span class="hljs-built_in">export</span> name  <span class="hljs-comment"># 第一种方法</span><br>$ <span class="hljs-built_in">declare</span> -x name  <span class="hljs-comment"># 第二种方法</span><br></code></pre></td></tr></table></figure><p>环境变量改为自定义变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">export</span> name=yxc  <span class="hljs-comment"># 定义环境变量</span><br>$ <span class="hljs-built_in">declare</span> +x name  <span class="hljs-comment"># 改为自定义变量</span><br></code></pre></td></tr></table></figure><h3 id="字符串">字符串</h3><p>字符串可以用单引号，也可以用双引号，也可以不用引号。</p><p>单引号与双引号的区别：</p><ul><li>单引号中的内容会原样输出，不会执行、不会取变量；</li><li>双引号中的内容可以执行、可以取变量；</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">name=yxc  <span class="hljs-comment"># 不用引号</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;hello, $name \&quot;hh\&quot;&#x27;</span>  <span class="hljs-comment"># 单引号字符串，输出 hello, $name \&quot;hh\&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello, <span class="hljs-variable">$name</span> \&quot;hh\&quot;&quot;</span>  <span class="hljs-comment"># 双引号字符串，输出 hello, yxc &quot;hh&quot;</span><br></code></pre></td></tr></table></figure><p><strong>获取字符串长度</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">name=<span class="hljs-string">&quot;yxc&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;#name&#125;</span>  <span class="hljs-comment"># 输出3</span><br></code></pre></td></tr></table></figure><p>提取子串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">name=<span class="hljs-string">&quot;hello, yxc&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;name:0:5&#125;</span>  <span class="hljs-comment"># 提取从0开始的5个字符</span><br></code></pre></td></tr></table></figure><h2 id="默认变量">默认变量</h2><h3 id="文件参数变量">文件参数变量</h3><p>在执行shell脚本时，可以向脚本传递参数。<code>$1</code>是第一个参数，<code>$2</code>是第二个参数，以此类推。特殊的，<code>$0</code>是文件名（包含路径）。例如：创建文件<code>test.sh</code>: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;文件名：&quot;</span><span class="hljs-variable">$0</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第一个参数：&quot;</span><span class="hljs-variable">$1</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第二个参数：&quot;</span><span class="hljs-variable">$2</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第三个参数：&quot;</span><span class="hljs-variable">$3</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第四个参数：&quot;</span><span class="hljs-variable">$4</span><br></code></pre></td></tr></table></figure> 然后执行该脚本：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">chmod</span> +x test.sh <br>$ ./test.sh 1 2 3 4<br>文件名：./test.sh<br>第一个参数：1<br>第二个参数：2<br>第三个参数：3<br>第四个参数：4<br></code></pre></td></tr></table></figure></p><h3 id="其它参数相关变量">其它参数相关变量</h3><table><thead><tr class="header"><th style="text-align: left;">参数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>$#</code></td><td>代表文件传入的参数个数，如上例中值为4</td></tr><tr class="even"><td style="text-align: left;"><code>$*</code></td><td>由所有参数构成的用空格隔开的字符串，如上例中值为<code>"$1 $2 $3 $4"</code></td></tr><tr class="odd"><td style="text-align: left;"><code>$@</code></td><td>每个参数分别用双引号括起来的字符串，如上例中值为<code>"$1" "$2" "$3" "$4"</code></td></tr><tr class="even"><td style="text-align: left;"><code>$$</code></td><td>脚本当前运行的进程ID</td></tr><tr class="odd"><td style="text-align: left;"><code>$?</code></td><td>上一条命令的退出状态（注意不是<code>stdout</code>，而是<code>exit code</code>）。0表示正常退出，其他值表示错误</td></tr><tr class="even"><td style="text-align: left;"><code>$(command)</code></td><td>返回<code>command</code>这条命令的<code>stdout</code>（可嵌套）</td></tr><tr class="odd"><td style="text-align: left;">`command`</td><td>返回<code>command</code>这条命令的<code>stdout</code>（不可嵌套）</td></tr></tbody></table><h2 id="数组">数组</h2><p>数组中可以存放多个不同类型的值，只支持一维数组，初始化时不需要指明数组大小。<strong>数组下标从0开始。</strong></p><h3 id="定义">定义</h3><p>数组用小括号表示，元素之间用空格隔开。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">array=(1 abc <span class="hljs-string">&quot;def&quot;</span> yxc)<br></code></pre></td></tr></table></figure><p>也可以直接定义数组中某个元素的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">array[0]=1<br>array[1]=abc<br>array[2]=<span class="hljs-string">&quot;def&quot;</span><br>array[3]=yxc<br></code></pre></td></tr></table></figure><h3 id="读取数组中某个元素的值">读取数组中某个元素的值</h3><p>格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$&#123;array[index]&#125;</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">array=(1 abc <span class="hljs-string">&quot;def&quot;</span> yxc)<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array[0]&#125;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array[1]&#125;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array[2]&#125;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array[3]&#125;</span><br></code></pre></td></tr></table></figure><h3 id="读取整个数组">读取整个数组</h3><p>格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$&#123;array[@]&#125;</span>  <span class="hljs-comment"># 第一种写法</span><br><span class="hljs-variable">$&#123;array[*]&#125;</span>  <span class="hljs-comment"># 第二种写法</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">array=(1 abc <span class="hljs-string">&quot;def&quot;</span> yxc)<br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array[@]&#125;</span>  <span class="hljs-comment"># 第一种写法</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array[*]&#125;</span>  <span class="hljs-comment"># 第二种写法</span><br></code></pre></td></tr></table></figure><h3 id="数组长度">数组长度</h3><p>类似于字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$&#123;#array[@]&#125;</span>  <span class="hljs-comment"># 第一种写法</span><br><span class="hljs-variable">$&#123;#array[*]&#125;</span>  <span class="hljs-comment"># 第二种写法</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">array=(1 abc <span class="hljs-string">&quot;def&quot;</span> yxc)<br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;#array[@]&#125;</span>  <span class="hljs-comment"># 第一种写法</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;#array[*]&#125;</span>  <span class="hljs-comment"># 第二种写法</span><br></code></pre></td></tr></table></figure><h2 id="expr-命令">expr 命令</h2><p><code>expr</code>命令用于求表达式的值，格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">expr</span> 表达式<br></code></pre></td></tr></table></figure><p>表达式说明： - 用空格隔开每一项 -用反斜杠放在shell特定的字符前面（发现表达式运行错误时，可以试试转义） -对包含空格和其他特殊字符的字符串要用引号括起来 -<code>expr</code>会在<code>stdout</code>中输出结果。如果为逻辑关系表达式，则结果为真，<code>stdout</code>为1，否则为0。-<code>expr</code>的<code>exit code</code>：如果为逻辑关系表达式，则结果为真，<code>exit code</code>为0，否则为1。</p><h3 id="字符串表达式">字符串表达式</h3><ul><li><code>length STRING</code> 返回<code>STRING</code>的长度</li><li><code>index STRING CHARSET</code><code>CHARSET</code>中任意单个字符在<code>STRING</code>中最前面的字符位置，下标从1开始。如果在<code>STRING</code>中完全不存在<code>CHARSET</code>中的字符，则返回0。</li><li><code>substr STRING POSITION LENGTH</code>返回<code>STRING</code>字符串中从<code>POSITION</code>开始，长度最大为<code>LENGTH</code>的子串。如果<code>POSITION</code>或<code>LENGTH</code>为负数，0或非数值，则返回空字符串。</li></ul><p>示例： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">str=<span class="hljs-string">&quot;Hello World!&quot;</span><br><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> length <span class="hljs-string">&quot;<span class="hljs-variable">$str</span>&quot;</span>`  <span class="hljs-comment"># ``不是单引号，表示执行该命令，输出12</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> index <span class="hljs-string">&quot;<span class="hljs-variable">$str</span>&quot;</span> aWd`  <span class="hljs-comment"># 输出7，下标从1开始</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> substr <span class="hljs-string">&quot;<span class="hljs-variable">$str</span>&quot;</span> 2 3`  <span class="hljs-comment"># 输出 ell</span><br></code></pre></td></tr></table></figure> ### 整数表达式<code>expr</code>支持普通的算术操作，算术表达式优先级低于字符串表达式，高于逻辑关系表达式。</p><ul><li><p><code>+ -</code>加减运算。两端参数会转换为整数，如果转换失败则报错。</p></li><li><p><code>* / %</code>乘，除，取模运算。两端参数会转换为整数，如果转换失败则报错。</p></li><li><p><code>()</code> 可以该表优先级，但需要用反斜杠转义</p></li></ul><p>示例： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">a=3<br>b=4<br><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> + <span class="hljs-variable">$b</span>`  <span class="hljs-comment"># 输出7</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> - <span class="hljs-variable">$b</span>`  <span class="hljs-comment"># 输出-1</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> \* <span class="hljs-variable">$b</span>`  <span class="hljs-comment"># 输出12，*需要转义</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> / <span class="hljs-variable">$b</span>`  <span class="hljs-comment"># 输出0，整除</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> % <span class="hljs-variable">$b</span>` <span class="hljs-comment"># 输出3</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> \( <span class="hljs-variable">$a</span> + 1 \) \* \( <span class="hljs-variable">$b</span> + 1 \)`  <span class="hljs-comment"># 输出20，值为(a + 1) * (b + 1)</span><br></code></pre></td></tr></table></figure></p><h3 id="逻辑关系表达式">逻辑关系表达式</h3><ul><li><p><code>|</code>如果第一个参数非空且非0，则返回第一个参数的值，否则返回第二个参数的值，但要求第二个参数的值也是非空或非0，否则返回0。如果第一个参数是非空或非0时，不会计算第二个参数。</p></li><li><p><code>&amp;</code>如果两个参数都非空且非0，则返回第一个参数，否则返回0。如果第一个参为0或为空，则不会计算第二个参数。</p></li><li><p><code>&lt; &lt;= = == != &gt;= &gt;</code>比较两端的参数，如果为true，则返回1，否则返回0。”==”是”=”的同义词。”expr”首先尝试将两端参数转换为整数，并做算术比较，如果转换失败，则按字符集排序规则做字符比较。</p></li><li><p><code>()</code> 可以该表优先级，但需要用反斜杠转义</p></li></ul><p>示例： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">a=3<br>b=4<br><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> \&gt; <span class="hljs-variable">$b</span>`  <span class="hljs-comment"># 输出0，&gt;需要转义</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> <span class="hljs-string">&#x27;&lt;&#x27;</span> <span class="hljs-variable">$b</span>`  <span class="hljs-comment"># 输出1，也可以将特殊字符用引号引起来</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> <span class="hljs-string">&#x27;&gt;=&#x27;</span> <span class="hljs-variable">$b</span>`  <span class="hljs-comment"># 输出0</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> \&lt;\= <span class="hljs-variable">$b</span>`  <span class="hljs-comment"># 输出1</span><br><br>c=0<br>d=5<br><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$c</span> \&amp; <span class="hljs-variable">$d</span>`  <span class="hljs-comment"># 输出0</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> \&amp; <span class="hljs-variable">$b</span>`  <span class="hljs-comment"># 输出3</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$c</span> \| <span class="hljs-variable">$d</span>`  <span class="hljs-comment"># 输出5</span><br><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">expr</span> <span class="hljs-variable">$a</span> \| <span class="hljs-variable">$b</span>`  <span class="hljs-comment"># 输出3</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux速查笔记</title>
    <link href="/2022/05/13/28b4feaabaab.html"/>
    <url>/2022/05/13/28b4feaabaab.html</url>
    
    <content type="html"><![CDATA[<h2 id="常用命令">常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">(1) ctrl c: 取消命令，并且换行<br>(2) ctrl u: 清空本行命令<br>(3) tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项<br>(4) <span class="hljs-built_in">ls</span>: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件<br>    <span class="hljs-built_in">ls</span> -a -l:  -a 显示隐藏文件， -l 显示完整信息<br>(5) <span class="hljs-built_in">pwd</span>: 显示当前路径<br>(6) <span class="hljs-built_in">cd</span> XXX: 进入XXX目录下, <span class="hljs-built_in">cd</span> .. 返回上层目录<br>(7) <span class="hljs-built_in">cp</span> XXX YYY: 将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如../dir_c/a.txt，表示上层目录下的dir_c文件夹下的文件a.txt<br>(8) <span class="hljs-built_in">mkdir</span> XXX: 创建目录XXX<br>(9) <span class="hljs-built_in">rm</span> XXX: 删除普通文件;  <span class="hljs-built_in">rm</span> XXX -r: 删除文件夹<br>(10) <span class="hljs-built_in">mv</span> XXX YYY: 将XXX文件移动到YYY，和<span class="hljs-built_in">cp</span>命令一样，XXX和YYY可以是一个路径；重命名也是用这个命令<br>(11) <span class="hljs-built_in">touch</span> XXX: 创建一个文件<br>(12) <span class="hljs-built_in">cat</span> XXX: 展示文件XXX中的内容<br>(13) 复制文本<br>    windows/Linux下：Ctrl + insert，Mac下：<span class="hljs-built_in">command</span> + c<br>(14) 粘贴文本<br>    windows/Linux下：Shift + insert，Mac下：<span class="hljs-built_in">command</span> + v<br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="tmux-命令">tmux 命令</h2><h3 id="功能">功能</h3><ol type="1"><li>分屏。</li><li>允许断开Terminal连接后，继续运行进程。 ### 结构一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。实例：</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart">tmux:<br>    session <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">window</span> <span class="hljs-number">0</span>:<br>            pane <span class="hljs-number">0</span><br>            pane <span class="hljs-number">1</span><br>            pane <span class="hljs-number">2</span><br>            ...<br>        <span class="hljs-built_in">window</span> <span class="hljs-number">1</span><br>        <span class="hljs-built_in">window</span> <span class="hljs-number">2</span><br>        ...<br>    session <span class="hljs-number">1</span><br>    session <span class="hljs-number">2</span><br>    ...<br></code></pre></td></tr></table></figure><h3 id="操作">操作</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs stata">(1) tmux：新建一个session，其中包含一个<span class="hljs-keyword">window</span>，<span class="hljs-keyword">window</span>中包含一个pane，pane里打开了一个<span class="hljs-keyword">shell</span>对话框。<br>(2) 按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。<br>(3) 按下Ctrl + a后手指松开，然后按&quot;：将当前pane上下平分成两个pane。<br>(4) Ctrl + <span class="hljs-keyword">d</span>：关闭当前pane；如果当前<span class="hljs-keyword">window</span>的所有pane均已关闭，则自动关闭<span class="hljs-keyword">window</span>；如果当前session的所有<span class="hljs-keyword">window</span>均已关闭，则自动关闭session。<br>(5) 鼠标点击可以选pane。<br>(6) 按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。<br>(7) 鼠标拖动pane之间的分割线，可以调整分割线的位置。<br>(8) 按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。<br>(9) 按下ctrl + a后手指松开，然后按z：将当前pane全屏/取消全屏。<br>(10) 按下ctrl + a后手指松开，然后按<span class="hljs-keyword">d</span>：挂起当前session。<br>(11) tmux a：打开之前挂起的session。<br>(12) 按下ctrl + a后手指松开，然后按s：选择其它session。<br>方向键 —— 上：选择上一项 session/<span class="hljs-keyword">window</span>/pane<br>方向键 —— 下：选择下一项 session/<span class="hljs-keyword">window</span>/pane<br>方向键 —— 右：展开当前项 session/<span class="hljs-keyword">window</span><br>方向键 —— 左：闭合当前项 session/<span class="hljs-keyword">window</span><br>(13) 按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的<span class="hljs-keyword">window</span>。<br>(14) 按下Ctrl + a后手指松开，然后按w：选择其他<span class="hljs-keyword">window</span>，操作方法与(12)完全相同。<br>(15) 按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。<br>(16) 鼠标滚轮：翻阅当前pane内的内容。<br>(17) 在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持<span class="hljs-keyword">Mac</span>）<br>(18) tmux中复制/粘贴文本的通用方式：<br>(1) 按下Ctrl + a后松开手指，然后按[<br>(2) 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板<br>(3) 按下Ctrl + a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处<br></code></pre></td></tr></table></figure><h2 id="vim-命令">vim 命令</h2><h3 id="功能-1">功能</h3><ol type="1"><li>命令行模式下的文本编辑器。</li><li>根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。</li><li>使用方式：<code>vim filename</code> 如果已有该文件，则打开它。如果没有该文件，则打开个一个新的文件，并命名为filename</li></ol><h3 id="模式">模式</h3><ol type="1"><li>一般命令模式默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。</li><li>编辑模式 在一般命令模式里按下i，会进入编辑模式。按下ESC会退出编辑模式，返回到一般命令模式。</li><li>命令行模式在一般命令模式里按下<code>:/?</code>三个字符中的任意一个，会进入命令行模式。命令行在最下面。可以查找、替换、保存、退出、配置编辑器等。</li></ol><h3 id="操作-1">操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs bash">(1) i：进入编辑模式<br>(2) ESC：进入一般命令模式<br>(3) h 或 左箭头键：光标向左移动一个字符<br>(4) j 或 向下箭头：光标向下移动一个字符<br>(5) k 或 向上箭头：光标向上移动一个字符<br>(6) l 或 向右箭头：光标向右移动一个字符<br>(7) n&lt;Space&gt;：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符<br>(8) 0 或 功能键[Home]：光标移动到本行开头<br>(9) $ 或 功能键[End]：光标移动到本行末尾<br>(10) G：光标移动到最后一行<br>(11) :n 或 nG：n为数字，光标移动到第n行<br>(12) gg：光标移动到第一行，相当于1G<br>(13) n&lt;Enter&gt;：n为数字，光标向下移动n行<br>(14) /word：向光标之下寻找第一个值为word的字符串。<br>(15) ?word：向光标之上寻找第一个值为word的字符串。<br>(16) n：重复前一个查找操作<br>(17) N：反向重复前一个查找操作<br>(18) :n1,n2s/word1/word2/g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2<br>(19) :1,<span class="hljs-variable">$s</span>/word1/word2/g：将全文的word1替换为word2<br>(20) :1,<span class="hljs-variable">$s</span>/word1/word2/gc：将全文的word1替换为word2，且在替换前要求用户确认。<br>(21) v：选中文本<br>(22) d：删除选中的文本<br>(23) <span class="hljs-built_in">dd</span>: 删除当前行<br>(24) y：复制选中的文本<br>(25) yy: 复制当前行<br>(26) p: 将复制的数据在光标的下一行/下一个位置粘贴<br>(27) u：撤销<br>(28) Ctrl + r：取消撤销<br>(29) 大于号 &gt;：将选中的文本整体向右缩进一次<br>(30) 小于号 &lt;：将选中的文本整体向左缩进一次<br>(31) :w 保存<br>(32) :w! 强制保存<br>(33) :q 退出<br>(34) :q! 强制退出<br>(35) :wq 保存并退出<br>(36) :<span class="hljs-built_in">set</span> <span class="hljs-built_in">paste</span> 设置成粘贴模式，取消代码自动缩进<br>(37) :<span class="hljs-built_in">set</span> nopaste 取消粘贴模式，开启代码自动缩进<br>(38) :<span class="hljs-built_in">set</span> nu 显示行号<br>(39) :<span class="hljs-built_in">set</span> nonu 隐藏行号<br>(40) gg=G：将全文代码格式化<br>(41) :noh 关闭查找关键词高亮<br>(42) Ctrl + q：当vim卡死时，可以取消当前正在执行的命令<br>异常处理：<br>每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。<br>如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：<br>(1) 找到正在打开该文件的程序，并退出<br>(2) 直接删掉该swp文件即可<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Vim</tag>
      
      <tag>tmux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>租云服务器及配docker环境</title>
    <link href="/2022/05/13/38bd162365d1.html"/>
    <url>/2022/05/13/38bd162365d1.html</url>
    
    <content type="html"><![CDATA[<h2 id="新租ecs服务器初始设置">新租ECS服务器初始设置</h2><p>以阿里云服务器为例： <ahref="https://ecs.console.aliyun.com/#/home">云服务器管理控制台(aliyun.com)</a></p><p>用终端ssh远程连接 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh root@47.113.219.85<br></code></pre></td></tr></table></figure></p><p>看内存和cpu信息 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ free -h<br>$ <span class="hljs-built_in">cat</span> /proc/cpuinfo<br></code></pre></td></tr></table></figure></p><p>root用户权限太大，能对系统文件进行操作。<span id="more"></span>以防万一，一般使用新建用户<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ adduser acs<br>$ <span class="hljs-comment"># 输入新用户密码</span><br></code></pre></td></tr></table></figure></p><p>给用户acs分配sudo权限 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ usermod -aG sudo acs<br></code></pre></td></tr></table></figure></p><h2 id="配置免密登录">配置免密登录</h2><ol type="1"><li><p>在本地终端创建配置文件<code>~/.ssh/config</code>然后在文件中输入： <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">Host aliyun<br>   HostName IP地址或域名<br>   User 用户名<br></code></pre></td></tr></table></figure>之后再使用服务器时，可以直接使用别名<code>aliyun</code>。</p></li><li><p>创建密钥 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen<br></code></pre></td></tr></table></figure> 然后一直回车即可。执行结束后，~/.ssh/目录下会多两个文件：</p><ul><li><code>id_rsa</code>：私钥</li><li><code>id_rsa.pub</code>：公钥</li></ul></li></ol><p>之后想免密码登录哪个服务器，就将公钥传给哪个服务器即可。</p><p>使用如下命令一键添加公钥： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-copy-id aliyun<br></code></pre></td></tr></table></figure> 3. 登录 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh aliyun <span class="hljs-comment"># ssh 别名，直接登录</span><br></code></pre></td></tr></table></figure> 4.断开连接 <code>ctrl + d</code></p><h2 id="配置毛坯环境">配置毛坯环境</h2><p>使用scp配置其他服务器的vim和tmux 直接将祖传文件<code>.bashrc</code>,<code>.vimrc</code>, <code>.tmux.conf</code>传到服务器用户目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">scp .bashrc .vimrc .tmux.conf aliyun:/home/acs/</span><br></code></pre></td></tr></table></figure><h2 id="安装tmux">安装tmux</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt-get update<br>$ sudo apt-get install tmux<br></code></pre></td></tr></table></figure><h2 id="安装-docker">安装 Docker</h2><p><a href="https://docs.docker.com/engine/install/ubuntu/">InstallDocker Engine on Ubuntu | Docker Documentation</a> <imgsrc="https://s2.loli.net/2022/05/13/xzFesXbyBEntIVg.png" />docker的主要优点是方便迁移。 ### Set up the repository 1. Update the<code>apt</code> package index and install packages to allow<code>apt</code> to use a repository over HTTPS: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt-get update<br></code></pre></td></tr></table></figure> 2. AddDocker’s official GPG key: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt-get install ca-certificates curl gnupg lsb-release<br></code></pre></td></tr></table></figure> 3. Use the following commandto set up the <strong>stable</strong> repository. To add the<strong>nightly</strong> or <strong>test</strong> repository, add theword <code>nightly</code> or <code>test</code> (or both) after the word<code>stable</code> in the commands below. <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb [arch=<span class="hljs-subst">$(dpkg --print-architecture)</span> signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></code></pre></td></tr></table></figure></p><h3 id="install-docker-engine">Install Docker Engine</h3><p>Update the <code>apt</code> package index, and install the <em>latestversion</em> of Docker Engine, containerd, and Docker Compose<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>tmux</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用tree生成目录树结构</title>
    <link href="/2022/05/11/88384542fd78.html"/>
    <url>/2022/05/11/88384542fd78.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>有时候想要展示一个项目的目录结构，对该项目进行文档描述性说明，用于解释其项目中各个目录以及文件代表的含义。在readme文档中逐行手写显然有些笨了。在Windows的Dos终端下有<code>tree</code>命令，不过其参数有限，无法过滤特定的文件；而且在Linux和gitbash终端下，也无法直接使用。 <span id="more"></span></p><h2 id="apt-安装方式-推荐">apt 安装方式 (推荐)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install tree<br></code></pre></td></tr></table></figure><h2 id="基于tree-node-cli">基于tree-node-cli</h2><p>类似树的格式列出目录的内容，类似于Linux树命令。提供了CLI和Node API安装: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g tree-node-cli<br></code></pre></td></tr></table></figure>tree的命令使用帮助文档:终端下输入<code>tree --help</code>时，终端下就会输出tree命令使用的一些参数<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage: tree [options]<br><br>Options:<br>  -V, --version             output the version number<br>  -a, --all-files           All files, include hidden files, are printed.<br>  --dirs-first              List directories before files.<br>  -d, --dirs-only           List directories only.<br>  -s, --sizes               Print the size of each file <span class="hljs-keyword">in</span> bytes along with the<br>                            name.<br>  -I, --exclude [patterns]  Exclude files that match the pattern. | separates<br>                            alternate patterns. Wrap your entire pattern <span class="hljs-keyword">in</span><br>                            double quotes. E.g. `<span class="hljs-string">&quot;node_modules|coverage&quot;</span>.<br>  -L, --max-depth &lt;n&gt;       Max display depth of the directory tree.<br>  -r, --reverse             Sort the output <span class="hljs-keyword">in</span> reverse alphabetic order.<br>  -F, --trailing-slash      Append a <span class="hljs-string">&#x27;/&#x27;</span> <span class="hljs-keyword">for</span> directories.<br>  -S, --line-ascii          Turn on ASCII line graphics.<br>  -h, --<span class="hljs-built_in">help</span>                display <span class="hljs-built_in">help</span> <span class="hljs-keyword">for</span> <span class="hljs-built_in">command</span><br></code></pre></td></tr></table></figure> - <code>tree -L n</code>显示项目的层级。n表示层级数。比如你想要显示项目的2层结构，可以用tree -l2 - <code>tree -I pattern</code>用于过滤不想要显示的文件或者文件夹。比如你想要过滤项目中的node_modules文件夹，可以使用<code>tree -I "node_modules"</code>，如果想要过滤多个目录文件,也可以<code>tree -I "node_modules|public|test_*"</code>，最后一个使用到正则匹配，这样以test_开头的文件夹都不会被显示出来，目录与目录之间用竖线隔开，中间不要有空格- <code>tree &gt; tree.md</code>将项目结构输出到tree.md这个文件与在windowsDOS的tree命令是一样的，但是在DOS终端下无法使用类似Linux下的一些参数,进行过滤操作</p><p>如果我们要显示某个项目下2层的所有文件结构，同时又过滤node_modules文件夹，可以这么写<code>tree -L 2 -I "要过滤的文件名"</code>，注意根据文档的参数,这是区分大小写的，而且要过滤的文件名必须得用双引号或者单引号包裹起来，在Linux命令行里,参数的大小写含义是有别的，上面文档的参数是什么，就应该是什么的，这点与windows是不一样的，Windows下的dos命令是不区分大小写的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tree -L 2 -I <span class="hljs-string">&quot;node_modules&quot;</span><br>Blog<br>├── _config.landscape.yml<br>├── _config.yml<br>├── db.json<br>├── package-lock.json<br>├── package.json<br>├── public<br>│   ├── 2021<br>│   ├── 2022<br>│   ├── about<br>│   ├── archives<br>│   ├── categories<br>│   ├── css<br>│   ├── images<br>│   ├── index.html<br>│   ├── js<br>│   ├── page<br>│   ├── search.xml<br>│   ├── shuoshuo<br>│   └── tags<br>├── scaffolds<br>│   ├── draft.md<br>│   ├── page.md<br>│   └── post.md<br>├── <span class="hljs-built_in">source</span><br>│   ├── _posts<br>│   ├── about<br>│   ├── categories<br>│   ├── shuoshuo<br>│   └── tags<br>└── themes<br>    └── landscape<br><br></code></pre></td></tr></table></figure><p>输出到tree.md，可以这么写:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tree -L 3 -I <span class="hljs-string">&quot;node_modules&quot;</span> &gt; tree.md<br></code></pre></td></tr></table></figure><h2 id="参考">参考</h2><p>https://juejin.cn/post/6844903861254094862</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven学习笔记</title>
    <link href="/2022/05/10/4b441c2f6e8e.html"/>
    <url>/2022/05/10/4b441c2f6e8e.html</url>
    
    <content type="html"><![CDATA[<p>Maven是专门用于管理和构建 Java 项目的工具,它的主要功能有： -提供了一套标准化的项目结构 -提供了一套标准化的构建流程（编译，测试，打包，发布...） -提供了一套依赖管理机制 <span id="more"></span></p><p>标准化的项目结构： <imgsrc="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/202204292017545.png" /></p><p>标准化的构建流程： <imgsrc="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/202204292020747.png" />依赖管理：管理项目所依赖的第三方资源(jar包、插件...) <imgsrc="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/202204292024062.png" /></p><h2 id="maven-简介">Maven 简介</h2><ul><li>Apache Maven是一个项目管理和构建工具，它基于项目对象模型(POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档</li></ul><p><imgsrc="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/202204292033517.png"alt="Maven模型" /> - 仓库分类 - 本地仓库：自己计算机上的一个目录 -中央仓库：有Maven团队维护的全球唯一的仓库 <ahref="https://repo1.maven.org/maven2/">Central Repository:(maven.org)</a> - 远程仓库(私服)：一般由公司团队搭建的私有仓库 -当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包：- 如果有，则在项目直接引用； -如果没有，则去中央仓库中下载对应的jar包到本地仓库 -还可以搭建远程仓库，将来jar包的查找顺序则变为： -本地仓库-&gt;远程仓库-&gt;中央仓库</p><h2 id="maven-安装配置">Maven 安装配置</h2><p><imgsrc="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/202204292047176.png" /></p><h2 id="maven-基本使用">Maven 基本使用</h2><h3 id="maven-常用命令">Maven 常用命令</h3><ul><li>compile</li><li>clean</li><li>test</li><li>package</li><li>install ### Maven 生命周期</li><li>Maven 构建项目生命周期描述的是一次构建过程经历了多少事件</li><li>Maven 对项目构建的生命周期划分为3套<ul><li>clean：清理工作</li><li>default：核心工作，例如编译，测试，打包，安装等</li><li>site：产生报告，发布站点等<br /><imgsrc="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/202204292119021.png" /></li></ul></li></ul><h2 id="idea-配置-maven">IDEA 配置 Maven</h2><h3 id="idea-配置-maven-环境">IDEA 配置 Maven 环境</h3><ol type="1"><li>选择IDEA中File --&gt; Settings</li><li>搜索maven</li><li>设置IDEA使用本地安装的Maven，并修改配置文件路径</li></ol><h3 id="maven-坐标详解">Maven 坐标详解</h3><p><imgsrc="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/202204292127361.png" /></p><h3 id="idea-创建-maven-项目">IDEA 创建 Maven 项目</h3><ol type="1"><li>创建模块，选择Maven，点击Next</li><li>填写模块名称，坐标信息，点击finish，创建完成</li><li>编写代码并运行</li></ol><h3 id="idea-导入-maven-项目">IDEA 导入 Maven 项目</h3><ol type="1"><li>选择右侧 Maven 面板，点击 + 号</li><li>选中对应项目的 pom.xml 文件，双击即可</li><li>如果没有 Maven 面板，选择 View <spanclass="math inline">\(\rightarrow\)</span> Appearance <spanclass="math inline">\(\rightarrow\)</span> Tool Window Bars</li></ol><h3 id="配置-maven-helper-插件">配置 Maven-Helper 插件</h3><ol type="1"><li>选择IDEA中 File <span class="math inline">\(\rightarrow\)</span>Settings</li><li>选择 Plugins</li><li>搜索 Maven，选择第一个 Maven Helper，点击 Install安装，弹出面板中点击 Accept</li><li>重启 IDEA ## 依赖管理 ### 使用坐标导入jar包</li><li>在 pom.xml 中编写 <dependencies> 标签</li><li>在 <dependencies> 标签中使用 <dependence> 引入坐标</li><li>定义坐标的 groupId, artifactId, version</li><li>点击刷新按钮，使坐标生效</li></ol><h3 id="快捷导入">快捷导入</h3><ol type="1"><li>在 pom.xml 中按 alt + insert，选择 Dependence</li><li>在弹出面板中搜索对应坐标，双击选中对应坐标</li><li>点击刷新使按钮，使坐标生效</li></ol><h3 id="依赖范围">依赖范围</h3><ul><li>通过设置坐标的依赖范围(scope)，可以设置对应jar包的作用范围：编译环境、测试环境、运行环境</li><li><scope>默认值：compile</li></ul><p><img src="https://s2.loli.net/2022/05/10/wDkNPuUFjH5bgX4.png" /></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用Markdown语法</title>
    <link href="/2022/05/07/cbe39cb234b9.html"/>
    <url>/2022/05/07/cbe39cb234b9.html</url>
    
    <content type="html"><![CDATA[<h1 id="标题">标题</h1><p>一级标题<code>#</code> 二级标题<code>##</code>三级标题<code>###</code> <span id="more"></span></p><h1 id="段落格式">段落格式</h1><p><strong>段落的换行是使用两个以上空格加上回车</strong></p><h2 id="字体">字体</h2><p><code>*斜体文本*</code> <code>**粗体文本**</code><code>***粗斜体***</code></p><h3 id="字体颜色">字体颜色</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;#FF00BB&quot;</span>&gt;</span></span>使用十六进制颜色值<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="字体高亮">字体高亮</h3><p><code>==高亮文字==</code> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background: #FFFF66&quot;</span>&gt;</span></span>背景色<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br></code></pre></td></tr></table></figure> ### 文字居中<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span></span>要居中的文字<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">center</span>&gt;</span></span><br></code></pre></td></tr></table></figure></p><h2 id="分隔线">分隔线</h2><p><strong>三个以上的星号、减号、底线来建立一个分隔线</strong></p><h2 id="删除线">删除线</h2><p><code>~删除内容~</code></p><h2 id="下划线">下划线</h2><p><code>&lt;u&gt;带下划线文本&lt;/u&gt;</code></p><h2 id="脚注">脚注</h2><p><code>[^要注明的文本]</code></p><h1 id="列表">列表</h1><p>无序列表使用星号<code>*</code>、加号<code>+</code>或是减号<code>-</code>作为列表标记，这些标记后面要添加一个空格，然后再填写内容有序列表使用数字并加上 . 号来表示【注意】使用列表最好<font color="#FF00BB">前边空一格</font>，以约束其作用域</p><h1 id="区块">区块</h1><p>Markdown 区块引用是在段落开头使用 &gt; 符号，然后后面紧跟一个<strong>空格</strong>符号，区块是可以嵌套的，一个 &gt;符号是最外层，两个 &gt; 符号是第一层嵌套 - 区块中使用列表 -列表中使用区块</p><h1 id="代码">代码</h1><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来 `</p><h2 id="代码区块">代码区块</h2><p>代码区块使用 <strong>4 个空格</strong>或者一个<strong>制表符（Tab键）</strong>。</p><p>也可以用 ```包裹一段代码，并指定一种语言（也可以不指定）</p><h1 id="链接">链接</h1><p><code>[链接名称](链接地址)</code> 或者<code>&lt;链接地址&gt;</code></p><h1 id="图片">图片</h1><p><code>![属性文本](图片地址 "可选标题")</code></p><p>指定图片的高度与宽度，使用普通的 <code>&lt;img&gt;</code>标签</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://xxx.logo.png&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;50%&quot;</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h1 id="公式">公式</h1><p><code>$ ... $</code> <code>$$ ... $$</code></p><p><span class="math inline">\(\rightarrow\)</span> ：<code>$\rightarrow$</code></p><h1 id="html元素">HTML元素</h1><p><code>&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt;</code><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>魅族16sPro 解锁&amp;刷机记录</title>
    <link href="/2022/05/05/fc18b2cc7b54.html"/>
    <url>/2022/05/05/fc18b2cc7b54.html</url>
    
    <content type="html"><![CDATA[<h2 id="步骤">步骤</h2><ol type="1"><li>前往<a href="http://www.meizubl.com/">MEIZU玩机论坛</a>购买点数解bl锁</li><li>刷入第三方recovery</li><li>安装面具</li><li>刷入模块 <span id="more"></span></li></ol><h2 id="模块">模块</h2><p>Shamiko</p><p>Zygisk-LSPosed</p><h2 id="reference">Reference</h2><p>https://magiskcn.com/</p><p>https://magisk.suchenqaq.club/</p><p>https://appshare.muge.info/</p><p><a href="https://www.volantgoat.com/archives/220/">MZXPT(Meizu XposedTool)使用说明 - VolantGoat</a></p>]]></content>
    
    
    <categories>
      
      <category>瞎折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BootLoader</tag>
      
      <tag>Magisk</tag>
      
      <tag>LSPosed</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>党岭葫芦海游记</title>
    <link href="/2022/05/03/f01343672401.html"/>
    <url>/2022/05/03/f01343672401.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>五一错过了学校户协木骡子的露营报名，不过最后关头抢到了党岭葫芦海的徒步。算是非常幸运了。对我而言，参加的户外活动实在不算太多，上次户外经历还是去年的冷嘎措，那次的虐团的高反经历犹在眼前。可大自然有着神奇的魔力，她的无限风光总能吸引天南海北络绎不绝的灵魂。<span id="more"></span></p><h2 id="启程">启程</h2><p>4.30早上五点半早早起床，简单洗漱，带上先前准备好的装备以及路餐去校门口集合。三十来号人坐上大巴车，6点三十准时出发，动身前往目的地。一路上没有遇上堵车，心情舒畅～大伙儿在领队的带领下，挨个儿做着自我介绍。算是例行公事了吧，反正我也记不住别人的名字……</p><p>大巴车在高速公路行驶至天全服务区，司机师傅稍作休息，我们也下车解决早饭。上次去川西也来过这儿，318路上最好的服务区，熟悉的感觉又回来了。<img src="https://s2.loli.net/2022/05/13/jhNpsGJEwVD3bZF.jpg" /></p><p>再次启程，我们又出发啦！泸定，川藏第一桥 <imgsrc="https://s2.loli.net/2022/05/13/5iSV7OFdCGg69eM.jpg" /></p><p>接着一路行驶，我们到达丹巴县，昏昏欲睡中，我仍然无法找到合适的坐姿，以适应如此长途的跋涉。<img src="https://s2.loli.net/2022/05/13/iLuA9YvTGCofwV6.jpg" /></p><p>下午一点半，我们在县城下车。各自找了个馆子糊口，随意找了餐馆，没想到味道出乎意料的好。大概是学校食堂拉低了我对食物的期待值吧。</p><p>三点，上车。keep going. 五点半终于到达党岭村预定的客栈。</p><p>此时我已经在心里咒骂了自己一百遍——为啥要找罪受呢，假期呆在床上不舒服吗？近十个小时的车程于我而言真的不太友好。</p><p>分好房间，在客栈吃完晚饭，破冰活动——狼人杀、谁是卧底，已经开始整起来了。不过这些都与我无关，躺在床上开摆～</p><p><img src="https://s2.loli.net/2022/05/13/lGk82bjBHvyeSFp.jpg" /></p><p>行前会，领队表示次日天气不太行，大家一定带好雨衣等必备物品，量力而行。</p><p>会后舍友们在闲扯中入睡。</p><h2 id="葫芦海我来了">葫芦海我来了</h2><p>次日，窗外果然飘起了小雪，远处的山峦像是被盖上一层柳絮，这无疑给这次徒步增加了亿点点难度。不过，对于身为南方娃的我而言，内心的欢喜又多了几分。<img src="https://s2.loli.net/2022/05/13/tRMmSeAXlFs3U5d.jpg" /></p><p>穿上速干的打底衣物，羽绒服，冲锋衣。下楼简单吃过客栈的早餐——白粥，切块的面饼以及人手一个水煮蛋。点名过后，八点左右正式出发！</p><p>起点在海拔3400米的党岭，党岭村至葫芦海总路程约6.7公里，海拔上升800米。沿途高山海子，雪山草甸，原始森林，当地人说这里藏着川西最美的秋天。但往返需8个小时的高原徒步，而且这里的路太泥泞了。好在一路都有简易的标志牌，不至于迷路。在前半段还可以选择骑马，本着勤俭节约的作风，我pass了这种方式。<img src="https://s2.loli.net/2022/05/13/FpbKaHVxqdX1ieL.jpg" /></p><p>我们翻过高山，走过草甸，趟过小溪，穿过原始森林，周围的景色也随着海拔的升高而变化。<img src="https://s2.loli.net/2022/05/13/tR4xK8MSlh9q3ue.jpg" /></p><p>约两小时的跋涉，到达干海子。当然我们的速度快的惊人，一路超了不少稍作停歇的同行人。<img src="https://s2.loli.net/2022/05/13/Um5cuwHb81kCpTY.jpg" /></p><p>从干海子到葫芦海的最后一段路程，有一个小时是这样的乱石滩。 <imgsrc="https://s2.loli.net/2022/05/13/3IfpRSJNZE5zLvr.jpg" /></p><p>11点10分，我们终于到葫芦海啦！！！ <imgsrc="https://s2.loli.net/2022/05/13/cjiAWYPx3VDBF46.jpg" /></p><p>被当地人称作美女神山的夏羌拉雪山就在不远处。找了个聊胜于无的树桩，卸掉登山包，整个人都轻盈了不少，不过鼻息声不曾停下来，高海拔缺氧从不缺席。</p><p>我们拿出自己带的零食和干粮席地而坐，分享路上的所见所闻，等待掉队的队友们。拍照打卡，此刻的快乐溢于言表。</p><p>隔壁家客栈的狗狗，也同我们一齐上来了！超厉害的！ <imgsrc="https://s2.loli.net/2022/05/13/MaGSQBfc1mUAsXi.jpg" /></p><p>下山时，雪已经停了。所见风光与银装素裹迥然不同，别有一番景象。 <imgsrc="https://s2.loli.net/2022/05/13/9eVHyYXOEaNofps.jpg" /></p><p>健步如飞，3点多到达客栈。应该是除了狗狗以外，刷新了今日最快下山记录了。(后面就累的没空记录了。。。也罢，流水账而已)</p><h2 id="归途">归途</h2><p>三日游结束，大巴车上疲态尽显，醉氧酣眠。徒步的过程当中，是自己跟自己对话的一个机会。希望还有机会能有一次说走就走的旅程吧。</p><h2 id="appendix">Appendix</h2><ul><li><ahref="https://mp.weixin.qq.com/s/ek3XXczWTaoHCIbFap6AFA">活动详情</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>徒步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC学习笔记</title>
    <link href="/2022/04/29/54cba0b373d6.html"/>
    <url>/2022/04/29/54cba0b373d6.html</url>
    
    <content type="html"><![CDATA[<h1 id="jdbc-简介">JDBC 简介</h1><p><img src="https://s2.loli.net/2022/04/23/RbtHYa6jGw1zpxn.png" /><span id="more"></span></p><h1 id="jdbc-快速入门">JDBC 快速入门</h1><h2 id="步骤">步骤</h2><p><img src="https://s2.loli.net/2022/04/23/a1W5w2ONiUED4qk.png" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.company.jdbc;  <br>  <br><span class="hljs-keyword">import</span> java.sql.Connection;  <br><span class="hljs-keyword">import</span> java.sql.DriverManager;  <br><span class="hljs-keyword">import</span> java.sql.Statement;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * JDBC步骤  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCDemo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-comment">// 1. 注册驱动  </span><br>        Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);  <br>  <br>        <span class="hljs-comment">// 2.获取连接  </span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/Music&quot;</span>;  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ckwj&quot;</span>;  <br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);  <br>  <br>        <span class="hljs-comment">// 3. 定义SQL语句  </span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update account set money = 3000 where id = 1&quot;</span>;  <br>  <br>        <span class="hljs-comment">// 4. 获取执行sql的对象  </span><br>        <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();  <br>  <br>        <span class="hljs-comment">// 5. 执行SQL  </span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stmt.executeUpdate(sql); <span class="hljs-comment">// 返回值，受影响的行数  </span><br>  <br>        <span class="hljs-comment">// 6. 处理结果  </span><br>        System.out.println(count);  <br>  <br>        <span class="hljs-comment">// 7. 释放资源  </span><br>        stmt.close(); <br>        conn.close();<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure> # JDBC API 详解 ## DriverManager 1. 注册驱动s <imgsrc="https://s2.loli.net/2022/04/23/6Y9cBSOf7Wlp2Ax.png" /></p><ol start="2" type="1"><li>获取数据库连接 <imgsrc="https://s2.loli.net/2022/04/23/53TRZmiasQUgJ2V.png" /></li></ol><h2 id="connection-数据连接对象">Connection (数据连接对象)</h2><ol type="1"><li><p>获取执行SQL的对象 <imgsrc="https://s2.loli.net/2022/04/23/r4WAQz3c2ZbSNge.png" /></p></li><li><p>事务管理 <imgsrc="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/202204232200033.png" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">try</span> &#123;  <br>    <span class="hljs-comment">// 开事务</span><br>    conn.setAutoCommit(<span class="hljs-literal">false</span>);  <br>  <br>    <span class="hljs-comment">// 5. 执行SQL  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count1</span> <span class="hljs-operator">=</span> stmt.executeUpdate(sql1); <span class="hljs-comment">// 返回值，受影响的行数  </span><br>    <span class="hljs-comment">// 6. 处理结果  </span><br>    System.out.println(count1);  <br>  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span> / <span class="hljs-number">0</span>;  <br>  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">count2</span> <span class="hljs-operator">=</span> stmt.executeUpdate(sql2); <br>    System.out.println(count2);  <br>  <br>    <span class="hljs-comment">// 提交  </span><br>    conn.commit();  <br>  <br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>    <span class="hljs-comment">// 回滚  </span><br>    conn.rollback();  <br>    e.printStackTrace();  <br>&#125;<br></code></pre></td></tr></table></figure> ## Statement <imgsrc="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/202204241051030.png" /></p></li></ol><h2 id="resultset">ResultSet</h2><p><imgsrc="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/202204241109997.png" /><imgsrc="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/202204241113416.png" />查询表数据，封装到Java对象中，并且存储到ArrayList集合中 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 创建pojo包 (Plain Ordinary Java Object)，存放实体类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>&#123;&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 1. 定义实体类Account</span><br><span class="hljs-comment">* 2. 查询数据，封装到Account对象中</span><br><span class="hljs-comment">* 3. 将Account对象存入ArrayList集合中</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*/</span><br>List&lt;Account&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>  <br><span class="hljs-comment">// 6. 处理结果  </span><br><span class="hljs-keyword">while</span> (rs.next()) &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-string">&quot;id&quot;</span>);  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-number">2</span>);  <br>    <span class="hljs-type">double</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> rs.getDouble(<span class="hljs-number">3</span>);  <br>    <span class="hljs-type">Account</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>(id, name, money);  <br>    list.add(account);  <br>&#125;  <br>  <br>System.out.println(list);<br><br></code></pre></td></tr></table></figure> ##PreparedStatement - 作用：预编译SQL语句并执行：预防SQL注入问题 -SQL注入：通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行<font style="background: #FFFF70">攻击</font>的方法<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">-</span> 完成用户登录<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;zhangsan&#x27;</span> <span class="hljs-keyword">and</span> password <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;123&#x27;</span>;<br></code></pre></td></tr></table></figure> <imgsrc="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/202204241730436.png" /><code>' or '1' = '1</code>这段字符串里的单引号被转义，不会改变原sql的语义 <imgsrc="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/202204241741166.png" />开启预编译后，日志才有 Prepare(相同一次) 和 Excute (多条多次)， 否则直接Query</p><h1 id="数据库连接池">数据库连接池</h1><h2 id="简介">简介</h2><ul><li>数据库连接池是一个容器，负责分配、管理数据库连接(Connection)</li><li>允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</li><li>释放空闲时间超过最大空闲时间的数据库连接，来避免因为释放数据库连接而引起的数据库连接遗漏</li><li>好处：1. 资源重用；2. 提升系统响应速度；3. 避免数据库连接遗漏 <imgsrc="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/202204291640125.png" />## 实现</li><li>标准接口： DataSource<ul><li>功能：获取连接 <code>Connection getConnection()</code></li></ul></li><li>常用数据库连接池<ul><li>DBCP</li><li>C3P0</li><li>Druid</li></ul></li><li>Druid（德鲁伊）<ul><li>Druid连接池是阿里巴巴开源的数据库连接池项目</li><li>功能强大，性能优秀，是Java语言最好的数据库连接池之一</li></ul></li></ul><h2 id="druid使用步骤">Druid使用步骤</h2><ol type="1"><li>导入jar包 druid-1.2.9.jar <ahref="https://repo1.maven.org/maven2/com/alibaba/druid">官网</a></li><li>定义配置文件 <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">driverClassName</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver  </span><br><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql:///Music?useSSL=false&amp;useServerPrepstmt=true  </span><br><span class="hljs-attr">username</span>=<span class="hljs-string">root  </span><br><span class="hljs-attr">password</span>=<span class="hljs-string">ckwj  </span><br><span class="hljs-comment"># 初始化连接数量  </span><br><span class="hljs-attr">initialSize</span>=<span class="hljs-string">5  </span><br><span class="hljs-comment"># 最大连接数  </span><br><span class="hljs-attr">maxActive</span>=<span class="hljs-string">10  </span><br><span class="hljs-comment"># 最大等待时间  </span><br><span class="hljs-attr">maxWait</span>=<span class="hljs-string">3000</span><br></code></pre></td></tr></table></figure></li><li>加载配置文件</li><li>获取数据库连接池对象</li><li>获取连接 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company.druid_;  <br>  <br><span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;  <br>  <br><span class="hljs-keyword">import</span> javax.sql.DataSource;  <br><span class="hljs-keyword">import</span> java.io.FileInputStream;  <br><span class="hljs-keyword">import</span> java.sql.Connection;  <br><span class="hljs-keyword">import</span> java.util.Properties;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 数据库连接池 Demo  </span><br><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DruidDemo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-comment">// 1. 导入jar包  </span><br>  <br>        <span class="hljs-comment">// 2. 定义配置文件  </span><br>  <br>        <span class="hljs-comment">// 3. 加载配置文件  </span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();  <br><span class="hljs-comment">//        System.out.println(System.getProperty(&quot;user.dir&quot;));  </span><br>        prop.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src/druid.properties&quot;</span>));  <br>  <br>        <span class="hljs-comment">// 4. 获取连接池对象  </span><br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(prop);  <br>  <br>        <span class="hljs-comment">// 5. 获取数据库连接 Connection        </span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();  <br>        System.out.println(connection);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="增删改查练习">增删改查练习</h2><ol type="1"><li>获取Connection</li><li><strong>定义SQL</strong></li><li>获取PrepareStatement对象 4.<strong>设置参数</strong></li><li>执行SQL</li><li><strong>处理数据</strong></li><li>释放资源</li></ol><h3 id="查找">查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company.example;  <br>  <br><span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;  <br><span class="hljs-keyword">import</span> com.company.pojo.Brand;  <br><span class="hljs-keyword">import</span> org.junit.Test;  <br>  <br><span class="hljs-keyword">import</span> javax.sql.DataSource;  <br><span class="hljs-keyword">import</span> java.io.FileInputStream;  <br><span class="hljs-keyword">import</span> java.sql.Connection;  <br><span class="hljs-keyword">import</span> java.sql.PreparedStatement;  <br><span class="hljs-keyword">import</span> java.sql.ResultSet;  <br><span class="hljs-keyword">import</span> java.util.ArrayList;  <br><span class="hljs-keyword">import</span> java.util.List;  <br><span class="hljs-keyword">import</span> java.util.Properties;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 品牌数据的增删改查操作  </span><br><span class="hljs-comment"> */</span>  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BrandTest</span> &#123;  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 查询所有  </span><br><span class="hljs-comment">     * 1. SQL: select * from tb_brand;  </span><br><span class="hljs-comment">     * 2. 参数: 不需要  </span><br><span class="hljs-comment">     * 3. 结果：List&lt;Brand&gt;  </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-meta">@Test</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-comment">// 1. 获取Connection  </span><br>        <span class="hljs-comment">// 1.1 加载配置文件  </span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();  <br>        prop.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src/druid.properties&quot;</span>));  <br>  <br>        <span class="hljs-comment">// 1.2 获取连接池对象  </span><br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(prop);  <br>  <br>        <span class="hljs-comment">// 1.3 获取数据库连接 Connection       </span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> dataSource.getConnection();  <br>  <br>        <span class="hljs-comment">// 2. 定义SQL  </span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from tb_brand&quot;</span>;  <br>  <br>        <span class="hljs-comment">// 3. 获取pstmt对象  </span><br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);  <br>  <br>        <span class="hljs-comment">// 4. 设置参数  </span><br>  <br>        <span class="hljs-comment">// 5. 执行SQL  </span><br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> pstmt.executeQuery();  <br>  <br>        <span class="hljs-comment">// 6. 处理结果  </span><br>        List&lt;Brand&gt; brands = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>        <span class="hljs-type">Brand</span> <span class="hljs-variable">brand</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>        <span class="hljs-keyword">while</span> (rs.next()) &#123;  <br>            <span class="hljs-comment">// 获取数据  </span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-string">&quot;id&quot;</span>);  <br>            <span class="hljs-type">String</span> <span class="hljs-variable">brandName</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-string">&quot;brand_name&quot;</span>);  <br>            <span class="hljs-type">String</span> <span class="hljs-variable">companyName</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-string">&quot;company_name&quot;</span>);  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">ordered</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-string">&quot;ordered&quot;</span>);  <br>            <span class="hljs-type">String</span> <span class="hljs-variable">description</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-string">&quot;description&quot;</span>);  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-string">&quot;status&quot;</span>);  <br>  <br>            <span class="hljs-comment">// 封装Brand对象  </span><br>            brand = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Brand</span>(id, brandName, companyName, ordered, description, status);  <br>  <br>            <span class="hljs-comment">// 装载集合  </span><br>            brands.add(brand);  <br>        &#125;  <br>        System.out.println(brands);  <br>  <br>        <span class="hljs-comment">// 7. 释放资源  </span><br>        rs.close();  <br>        pstmt.close();  <br>        conn.close();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="添加">添加</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 添加  </span><br><span class="hljs-comment"> * 1. SQL: insert into tb_brand(brand_name, company_name, ordered, description, status) values (?, ?, ?, ?);  </span><br><span class="hljs-comment"> * 2. 参数: 需要,除了 id 外的所有信息  </span><br><span class="hljs-comment"> * 3. 结果：Boolean  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAdd</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>    <span class="hljs-comment">// 接收页面提交的参数  </span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">brandName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;魅族&quot;</span>;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">company</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;魅族科技有限公司&quot;</span>;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">ordered</span> <span class="hljs-operator">=</span> <span class="hljs-number">150</span>;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">description</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;温润如玉&quot;</span>;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <br>  <br>    <span class="hljs-comment">// 1. 获取Connection  </span><br>    <span class="hljs-comment">// 1.1 加载配置文件  </span><br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();  <br>    prop.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src/druid.properties&quot;</span>));  <br>  <br>    <span class="hljs-comment">// 1.2 获取连接池对象  </span><br>    <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(prop);  <br>  <br>    <span class="hljs-comment">// 1.3 获取数据库连接 Connection    </span><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> dataSource.getConnection();  <br>  <br>    <span class="hljs-comment">// 2. 定义SQL  </span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into tb_brand(brand_name, company_name, ordered, description, status) values (?, ?, ?, ?, ?)&quot;</span>;  <br>  <br>    <span class="hljs-comment">// 3. 获取pstmt对象  </span><br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);  <br>  <br>    <span class="hljs-comment">// 4. 设置参数  </span><br>    pstmt.setString(<span class="hljs-number">1</span>, brandName);  <br>    pstmt.setString(<span class="hljs-number">2</span>, company);  <br>    pstmt.setInt(<span class="hljs-number">3</span>, ordered);  <br>    pstmt.setString(<span class="hljs-number">4</span>, description);  <br>    pstmt.setInt(<span class="hljs-number">5</span>, status);  <br>  <br>    <span class="hljs-comment">// 5. 执行SQL  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> pstmt.executeUpdate();  <br>  <br>    <span class="hljs-comment">// 6. 处理结果  </span><br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) System.out.println(<span class="hljs-string">&quot;successful&quot;</span>);  <br>    <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;failed&quot;</span>);  <br>  <br>    <span class="hljs-comment">// 7. 释放资源  </span><br>    pstmt.close();  <br>    conn.close();  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修改">修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 修改  </span><br><span class="hljs-comment"> * 1. SQL:  </span><br><span class="hljs-comment"> update tb_brand    set brand_name = ?,    company_name = ?,    ordered = ?,    description = ?,    status = ? where id = ?; * 2. 参数: 需要, Brand对象所有数据  </span><br><span class="hljs-comment"> * 3. 结果：Boolean  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>    <span class="hljs-comment">// 接收页面提交的参数  </span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">brandName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;魅族&quot;</span>;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">company</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;珠海小厂&quot;</span>;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">ordered</span> <span class="hljs-operator">=</span> <span class="hljs-number">1500</span>;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">description</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;青年良品&quot;</span>;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;  <br>  <br>    <span class="hljs-comment">// 1. 获取Connection  </span><br>    <span class="hljs-comment">// 1.1 加载配置文件  </span><br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();  <br>    prop.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src/druid.properties&quot;</span>));  <br>  <br>    <span class="hljs-comment">// 1.2 获取连接池对象  </span><br>    <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(prop);  <br>  <br>    <span class="hljs-comment">// 1.3 获取数据库连接 Connection    </span><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> dataSource.getConnection();  <br>  <br>    <span class="hljs-comment">// 2. 定义SQL  </span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update tb_brand \n&quot;</span> +  <br>            <span class="hljs-string">&quot;        set brand_name = ?,\n&quot;</span> +  <br>            <span class="hljs-string">&quot;        company_name = ?,\n&quot;</span> +  <br>            <span class="hljs-string">&quot;        ordered = ?,\n&quot;</span> +  <br>            <span class="hljs-string">&quot;        description = ?,\n&quot;</span> +  <br>            <span class="hljs-string">&quot;        status = ? \n&quot;</span> +  <br>            <span class="hljs-string">&quot;     where id = ?&quot;</span>;  <br>  <br>    <span class="hljs-comment">// 3. 获取pstmt对象  </span><br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);  <br>  <br>    <span class="hljs-comment">// 4. 设置参数  </span><br>    pstmt.setString(<span class="hljs-number">1</span>, brandName);  <br>    pstmt.setString(<span class="hljs-number">2</span>, company);  <br>    pstmt.setInt(<span class="hljs-number">3</span>, ordered);  <br>    pstmt.setString(<span class="hljs-number">4</span>, description);  <br>    pstmt.setInt(<span class="hljs-number">5</span>, status);  <br>    pstmt.setInt(<span class="hljs-number">6</span>, id);  <br>  <br>    <span class="hljs-comment">// 5. 执行SQL  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> pstmt.executeUpdate();  <br>  <br>    <span class="hljs-comment">// 6. 处理结果  </span><br>    System.out.println(count &gt; <span class="hljs-number">0</span>);  <br>  <br>    <span class="hljs-comment">// 7. 释放资源  </span><br>    pstmt.close();  <br>    conn.close();  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除">删除</h3><ol type="1"><li>编写SQL语句 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> tb_brand <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> ?;<br></code></pre></td></tr></table></figure></li><li>是否需要参数? 需要 id</li><li>返回结果如何封装？ boolean <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDelete</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>    <span class="hljs-comment">// 接收页面提交的参数  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;  <br>  <br>    <span class="hljs-comment">// 1. 获取Connection  </span><br>    <span class="hljs-comment">// 1.1 加载配置文件  </span><br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();  <br>    prop.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src/druid.properties&quot;</span>));  <br>  <br>    <span class="hljs-comment">// 1.2 获取连接池对象  </span><br>    <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(prop);  <br>  <br>    <span class="hljs-comment">// 1.3 获取数据库连接 Connection    </span><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> dataSource.getConnection();  <br>  <br>    <span class="hljs-comment">// 2. 定义SQL  </span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delete from tb_brand where id = ?;&quot;</span>;  <br>  <br>    <span class="hljs-comment">// 3. 获取pstmt对象  </span><br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);  <br>  <br>    <span class="hljs-comment">// 4. 设置参数  </span><br>    pstmt.setInt(<span class="hljs-number">1</span>, id);  <br>  <br>    <span class="hljs-comment">// 5. 执行SQL  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> pstmt.executeUpdate();  <br>  <br>    <span class="hljs-comment">// 6. 处理结果  </span><br>    System.out.println(count &gt; <span class="hljs-number">0</span>);  <br>  <br>    <span class="hljs-comment">// 7. 释放资源  </span><br>    pstmt.close();  <br>    conn.close();  <br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDBC</tag>
      
      <tag>Druid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库笔记</title>
    <link href="/2022/04/29/65dec125cf63.html"/>
    <url>/2022/04/29/65dec125cf63.html</url>
    
    <content type="html"><![CDATA[<h1 id="数据库-database">数据库 (DataBase)</h1><p>存储数据的仓库，数据是有组织的进行存储</p><h2 id="关系型数据库管理系统">关系型数据库管理系统</h2><p>MySQL (Structured Query Language)</p><h2 id="sql-通用语法">SQL 通用语法</h2><ol type="1"><li>SQL 语句可以单行或多行书写，以分号结尾；<span id="more"></span></li><li>MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写；</li><li>注释<ul><li>单行注释： -- 注释内容 或 # 注释内容(MySQL 特有)</li><li>多行注释： /* 注释 */</li></ul></li></ol><h2 id="sql-分类">SQL 分类</h2><p><img src="https://s2.loli.net/2022/04/21/xHneIoAzKThRZwv.png" /> <imgsrc="https://s2.loli.net/2022/04/21/OIKyVU4EN1GfxBF.png" /></p><h3 id="ddl----操作数据库">DDL -- 操作数据库</h3><ol type="1"><li><p>查询 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> DATABASES;<br></code></pre></td></tr></table></figure></p></li><li><p>创建</p></li></ol><ul><li>创建数据库 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE 数据库名称;<br></code></pre></td></tr></table></figure></li><li>创建数据库(判断，如果不存在则创建) <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> 数据库名称;<br></code></pre></td></tr></table></figure></li></ul><ol start="3" type="1"><li>删除</li></ol><ul><li>删除数据库 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE 数据库名称;<br></code></pre></td></tr></table></figure></li><li>删除数据库(判断，如果存在则删除) <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE IF <span class="hljs-keyword">EXISTS</span> 数据库名称;<br></code></pre></td></tr></table></figure></li></ul><ol start="4" type="1"><li>使用数据库</li></ol><ul><li>查看当前使用的数据库 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> DATABASE();<br></code></pre></td></tr></table></figure></li><li>使用数据库 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE 数据库名称;<br></code></pre></td></tr></table></figure></li></ul><h3 id="ddl----操作表">DDL -- 操作表</h3><ol type="1"><li><p>创建(Create) <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名 (<br>字段名<span class="hljs-number">1</span> 数据类型,<br>字段名<span class="hljs-number">2</span> 数据类型,<br>...<br>字段名n 数据类型 <br>);<br></code></pre></td></tr></table></figure><font color = "FF5099">注意：最后一行末尾，不能加逗号</font></p></li><li><p>查询(Retrieve)</p></li></ol><ul><li>查询当前数据库下所有表名称 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> TABLES;<br></code></pre></td></tr></table></figure></li><li>查询表结构 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DESC</span> 表名称;<br></code></pre></td></tr></table></figure></li></ul><ol start="3" type="1"><li>修改(Update)</li></ol><ul><li>修改表名 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 RENAME <span class="hljs-keyword">TO</span> 新表名;<br></code></pre></td></tr></table></figure></li><li>添加一列 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> 列名 数据类型;<br></code></pre></td></tr></table></figure></li><li>修改数据类型 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 MODIFY 列名 新数据类型;<br></code></pre></td></tr></table></figure></li><li>修改列名和数据类型 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 CHANGE 列名 新列名 新数据类型;<br></code></pre></td></tr></table></figure></li><li>删除列 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> 列名;<br></code></pre></td></tr></table></figure></li></ul><ol start="4" type="1"><li>删除(Delete)</li></ol><ul><li>删除表 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> 表名;<br></code></pre></td></tr></table></figure></li><li>删除表时判断表是否存在 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> 表名;<br></code></pre></td></tr></table></figure></li></ul><h4 id="数据类型">数据类型</h4><p>MySQL 支持多种类型，可以分为三类： - 数值 - 日期 - 字符串 <imgsrc="https://s2.loli.net/2022/04/22/eaH23SmNy8l4J5F.png" /></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student (<br><br>id <span class="hljs-type">int</span>,<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),<br>gender <span class="hljs-type">char</span>(<span class="hljs-number">1</span>),<br>birthday <span class="hljs-type">date</span>,<br>score <span class="hljs-keyword">double</span>(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>),<br>email <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>),<br>tel <span class="hljs-type">varchar</span>(<span class="hljs-number">15</span>),<br>status tinyint<br><br>);<br></code></pre></td></tr></table></figure><h3 id="dml----操作数据">DML -- 操作数据</h3><ol type="1"><li>添加(insert)</li></ol><ul><li>给指定列添加数据 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 (列名<span class="hljs-number">1</span>,列名<span class="hljs-number">2</span>,...) <span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,...);<br></code></pre></td></tr></table></figure></li><li>给全部列添加数据 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 <span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,...);<br></code></pre></td></tr></table></figure></li><li>批量添加数据 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 (列名<span class="hljs-number">1</span>,列名<span class="hljs-number">2</span>,...) <span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,...),(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,...),(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,...)...;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 <span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,...),(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,...),(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,...)...;<br></code></pre></td></tr></table></figure></li></ul><ol start="2" type="1"><li>修改(update)</li></ol><ul><li>修改表数据<font color ='008800'>(不加条件，则将所有数据都修改)</font><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> 表名 <span class="hljs-keyword">SET</span> 列名<span class="hljs-number">1</span><span class="hljs-operator">=</span>值<span class="hljs-number">1</span>,列名<span class="hljs-number">2</span><span class="hljs-operator">=</span>值<span class="hljs-number">2</span>,... [<span class="hljs-keyword">WHERE</span> 条件];<br></code></pre></td></tr></table></figure></li></ul><ol start="3" type="1"><li>删除(delete)</li></ol><ul><li>删除数据<font color ='008800'>(不加条件，则将所有数据都删除!)</font><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名 [<span class="hljs-keyword">WHERE</span> 条件];<br></code></pre></td></tr></table></figure></li></ul><h3 id="dql">DQL</h3><p>查询语法 <imgsrc="https://s2.loli.net/2022/04/22/YMfJg4QsALqNvBH.png" /></p><h4 id="基础查询">基础查询</h4><p><img src="https://s2.loli.net/2022/04/22/2dwpi3fgsBOMca8.png" /></p><h4 id="条件查询">条件查询</h4><p><img src="https://s2.loli.net/2022/04/22/gicTN1BSHo3DeCw.png" /></p><h4 id="排序查询">排序查询</h4><p><img src="https://s2.loli.net/2022/04/22/YcHqUSe6dZaTERV.png" /></p><h4 id="分组查询">分组查询</h4><ul><li><p>聚合函数 <imgsrc="https://s2.loli.net/2022/04/22/EK4mvruqcndRNU2.png" /></p></li><li><p>分组查询 <imgsrc="https://s2.loli.net/2022/04/22/Br5TSdXnUzxM96m.png" /></p></li></ul><h4 id="分页查询">分页查询</h4><p><img src="https://s2.loli.net/2022/04/22/FQ3NSct2Jzga4fw.png" /></p><h2 id="约束">约束</h2><h3 id="概念-分类">概念 &amp; 分类</h3><ol type="1"><li>约束的概念</li></ol><ul><li>约束是作用于表中列上的规则，用于限制加入表的数据</li><li>约束的存在保证了数据库中数据的<strong>正确性、有效性和完整性</strong></li></ul><ol start="2" type="1"><li>约束的分类 <imgsrc="https://s2.loli.net/2022/04/22/47cZKfdsNBupIoq.png" />auto_increment 当不指定时自动增长</li></ol><h4 id="添加约束">添加约束</h4><ul><li>创建表时添加约束 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>列名 数据类型 <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>列名 数据类型 <span class="hljs-keyword">DEFAULT</span> 默认值,<br>...<br>[<span class="hljs-keyword">CONSTRAINT</span>] [约束名称] <span class="hljs-keyword">UNIQUE</span>(列名)<br>);<br></code></pre></td></tr></table></figure></li><li>建完表后添加约束 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 MODIFY 字段名 数据类型 <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 MODIFY 字段名 数据类型 <span class="hljs-keyword">UNIQUE</span>;<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ALTER</span> 列名 <span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span> 默认值;<br></code></pre></td></tr></table></figure> #### 删除约束 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 MODIFY 字段名 数据类型;<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> INDEX 字段名;<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ALTER</span> 列名 <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">DEFAULT</span>;<br></code></pre></td></tr></table></figure></li></ul><h4 id="外键">外键</h4><p><img src="https://s2.loli.net/2022/04/23/VfAGi45Q8y3tpax.png" /> <imgsrc="https://s2.loli.net/2022/04/23/YaZruc6QOqSjoAd.png" /></p><h2 id="数据库设计">数据库设计</h2><h3 id="数据库设计简介">数据库设计简介</h3><p><img src="https://s2.loli.net/2022/04/23/aiYNw1vUmc4T2uk.png" /></p><h3 id="表关系">表关系</h3><p><img src="https://s2.loli.net/2022/04/23/UaRFvMbYc15OrWG.png" /> 1.多对一实现方式：在<strong>多</strong>的一方建立<strong>外键</strong>，指向一的一方的主键；2.多对多实现方式：建立第三张<strong>中间表</strong>，中间表至少包含<strong>两个外键</strong>，分别<strong>关联两方主键</strong>；3.一对一实现方式：在任意一方加入外键，关联另一方主键，并且设置外键为<strong>唯一(UNIQUE)</strong>;</p><h2 id="多表查询">多表查询</h2><ul><li>笛卡尔积： 取A, B集合所有组合情况</li><li>多表查询：从多张表查询数据<ul><li>连接查询<ul><li>内连接：相当于查询A和B的交集数据</li><li>外连接：左外连接、右外连接</li></ul></li><li>子查询</li></ul></li></ul><h3 id="内连接">内连接</h3><p><img src="https://s2.loli.net/2022/04/23/7zviVAB5M3CD1JF.png" /> ###外连接 <img src="https://s2.loli.net/2022/04/23/qNAkVByX3o1HdZa.png" />### 子查询 1. 子查询概念：查询中嵌套查询，称嵌套查询为子查询； 2.子查询根据查询结果不同，作用不同 <imgsrc="https://s2.loli.net/2022/04/23/jQFZ9PuWTSmGxL1.png" /></p><h2 id="事务">事务</h2><h3 id="事务简介">事务简介</h3><p><img src="https://s2.loli.net/2022/04/23/jKrxFtkQXpsz7lH.png" /></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> ACCOUNT;<br><br><span class="hljs-comment">-- 创建账户表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> ACCOUNT (<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>NAME <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>),<br>money <span class="hljs-keyword">DOUBLE</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br>);<br><br><span class="hljs-comment">-- 添加数据</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> ACCOUNT(NAME,money) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">1000</span>), (<span class="hljs-string">&#x27;李四&#x27;</span>,<span class="hljs-number">1000</span>);<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> ACCOUNT;<br><br><span class="hljs-comment">-- 转账操作</span><br><span class="hljs-comment">-- # 开启事务</span><br><span class="hljs-keyword">BEGIN</span>;<br><br><span class="hljs-comment">-- 1. 查询李四的余额</span><br><br><span class="hljs-comment">-- 2. 李四金额 -500</span><br><span class="hljs-keyword">UPDATE</span> ACCOUNT <span class="hljs-keyword">SET</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">-</span> <span class="hljs-number">500</span> <span class="hljs-keyword">WHERE</span> NAME <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;李四&#x27;</span>;<br><br># 出异常<br><br><span class="hljs-comment">-- 3. 张三金额 +500</span><br><span class="hljs-keyword">UPDATE</span> ACCOUNT <span class="hljs-keyword">SET</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">+</span> <span class="hljs-number">500</span> <span class="hljs-keyword">WHERE</span> NAME <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>;<br><br><span class="hljs-comment">-- # 回滚事务</span><br><span class="hljs-keyword">ROLLBACK</span>;<br><br><span class="hljs-comment">-- # 提交事务</span><br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><h3 id="事务操作">事务操作</h3><ul><li>开启事务</li><li>回滚事务</li><li>提交事务 ### 事务四大特征</li><li>原子性(<font color='ff0000'>A</font>tomicity)：事务是不可分割的最小操作单位，要么同时成功，要么同时失败</li><li>一致性(<font color='ff0000'>C</font>onsistency)：事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性(<font color='ff0000'>I</font>solation)：多个事务之间，操作的可见性</li><li>持久性(<font color='ff0000'>D</font>urability)：事务一旦提交或会回滚，它对数据库中的数据的改变是永久的<img src="https://s2.loli.net/2022/04/23/SRN2gqpvLjEPlC7.png" /></li></ul><h2 id="案例分析">案例分析</h2><ul><li><p>音乐专辑表名 ： Album | 字段名 | 数据类型 | 说明 | | ------------| ------------- | ------------------------------- | | title |varchar(32) | 专辑名 | | style | varchar(8) |流派(经典、流行、民谣、电子...) | | publish_time | date | 发行时间 | |publisher | varchar(16) | 出版者 | | number | tinyint | 唱片数 | |artist | varchar(16) | 艺术家 | | id | int | 编号(唯一) | | summary |varchar(1024) | 简介 |</p></li><li><p>曲目表名：Song | 字段名 | 数据类型 | 说明 | | ---------- |----------- | ---------- | | name | varchar(32) | 歌曲名 | | serial_num| tinyint | 歌曲序号 | | id | int | 编号(唯一) |</p></li><li><p>评论表名： Review | 字段名 | 数据类型 | 说明 | | ----------- |------------ | --------- | | content | varchar(256) | 评论内容 | |rating | tinyint | 评分(1-5) | | review_time | datetime | 评论时间|</p></li><li><p>用户表名： User | 字段名 | 数据类型 | 说明 | | --------- |----------- | -------------- | | username | varchar(16) | 用户名(唯一) || image | varchar(64) | 用户头像地址 | | signature | varchar(64) |个人签名 | | nickname | varchar(16) | 用户昵称 | | id | int |用户编号(主键) |</p></li></ul><h2 id="表关系-1">表关系</h2><p><img src="https://s2.loli.net/2022/04/23/7EdkcZGVU2DAryl.png" /></p><h2 id="代码">代码</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建数据库</span><br> <span class="hljs-keyword">CREATE</span> DATABASE IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> MUSIC;<br><br><span class="hljs-comment">-- 使用数据库</span><br> USE MUSIC;<br><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> Album; <br><span class="hljs-comment">-- 创建专辑表</span><br> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Album (<br>  titile <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">32</span>),<br>  style <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">8</span>),<br>  publish_time <span class="hljs-type">DATE</span>,<br>  publisher <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">16</span>),<br>  numbers TINYINT,<br>  artist <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">16</span>),<br>  id <span class="hljs-type">INT</span> <span class="hljs-keyword">UNIQUE</span>,<br>  summary <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">1024</span>)<br>);<br><br><span class="hljs-comment">-- 创建歌曲表</span><br> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Song (<br>  NAME <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">32</span>),<br>  serial_num TINYINT,<br>  id <span class="hljs-type">INT</span> <span class="hljs-keyword">UNIQUE</span><br>);<br><br><span class="hljs-comment">-- 创建评论表</span><br> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Review (<br>  content <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">256</span>),<br>  rating TINYINT,<br>  review_time DATETIME<br>);<br><br><span class="hljs-comment">-- 创建用户表</span><br> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">USER</span> (<br>  username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">16</span>),<br>  image <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">64</span>),<br>  signature <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">16</span>),<br>  id <span class="hljs-type">INT</span> <br>);<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">USER</span> MODIFY id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY;<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Album MODIFY id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY;<br><br><span class="hljs-comment">-- 展示所有表</span><br><span class="hljs-keyword">SHOW</span> TABLES;<br><br><span class="hljs-comment">-- 表关系</span><br> <span class="hljs-comment">-- 专辑 - 曲目 (1:n)</span><br> <span class="hljs-comment">-- 先添加一列</span><br> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Song <span class="hljs-keyword">ADD</span> album_id <span class="hljs-type">INT</span>;<br> <span class="hljs-comment">-- 一对多</span><br> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Song<br>  <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> album_id_song <span class="hljs-keyword">FOREIGN</span> KEY (album_id) <span class="hljs-keyword">REFERENCES</span> Album (id);<br>  <br> <span class="hljs-comment">-- 专辑- 短评 (1:n)</span><br> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Review <span class="hljs-keyword">ADD</span> album_id <span class="hljs-type">INT</span>;<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Review<br>  <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> album_id_review <span class="hljs-keyword">FOREIGN</span> KEY (album_id) <span class="hljs-keyword">REFERENCES</span> Album (id);<br>  <br><span class="hljs-comment">-- 用户-短评 (1:n)</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Review <span class="hljs-keyword">ADD</span> user_id <span class="hljs-type">INT</span>;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Review <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> user_id_review <span class="hljs-keyword">FOREIGN</span> KEY (user_id) <span class="hljs-keyword">REFERENCES</span> <span class="hljs-keyword">USER</span> (id);<br><br><span class="hljs-comment">-- 专辑-用户 (m:n)</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> AlbumUser;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> AlbumUser (<br>album_id <span class="hljs-type">INT</span>,<br>user_id <span class="hljs-type">INT</span>,<br><br><span class="hljs-keyword">CONSTRAINT</span> album_id_mid <span class="hljs-keyword">FOREIGN</span> KEY (album_id) <span class="hljs-keyword">REFERENCES</span> Album (id),<br><span class="hljs-keyword">CONSTRAINT</span> user_id_mid <span class="hljs-keyword">FOREIGN</span> KEY (user_id) <span class="hljs-keyword">REFERENCES</span> <span class="hljs-keyword">USER</span> (id)<br>);<br><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br><span class="hljs-keyword">SHOW</span> TABLES;<br><br><span class="hljs-keyword">DESC</span> Album;<br><br><span class="hljs-comment">-- 添加数据</span><br><span class="hljs-comment">-- INSERT INTO 表名 (列名1,列名2,...) VALUES(值1,值2,...),(值1,值2,...),(值1,值2,...)...;</span><br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> Album (<br>  titile,<br>  style,<br>  publish_time,<br>  publisher,<br>  numbers,<br>  artist,<br>  id,<br>  summary<br>)<br><span class="hljs-keyword">VALUES</span> (<br>    <span class="hljs-string">&#x27;范特西&#x27;</span>,<br>    <span class="hljs-string">&#x27;流行&#x27;</span>,<br>    <span class="hljs-string">&#x27;2001-09-14&#x27;</span>,<br>    <span class="hljs-string">&#x27;BMG&#x27;</span>,<br>    <span class="hljs-number">10</span>,<br>    <span class="hljs-string">&#x27;周杰伦&#x27;</span>,<br>    <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&#x27;周杰伦的出现，让人们相信台湾创造本土R&amp;B的可能性；周杰伦的走红，彻底地宣布音乐新声代的来临。作曲、填词、编曲、演唱样样俱精的周杰伦，首张同名专辑《Jay杰伦》推出后，销售势如破竹，不单有“音乐新人王”称号，他自成一格的R&amp;B演绎方法，更被誉为陶吉吉的劲敌。 顶着台湾金曲奖“最佳唱片”、“最佳制作人”的光环，周杰伦的第二张专辑《Fantasy(范特西)》终于在万千歌迷的期待中推出。&#x27;</span><br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> Album <span class="hljs-keyword">VALUES</span> (<br><span class="hljs-string">&#x27;叶惠美&#x27;</span>,<br><span class="hljs-string">&#x27;流行&#x27;</span>,<br><span class="hljs-string">&#x27;2003-07-31&#x27;</span>,<br><span class="hljs-string">&#x27;Sony Music&#x27;</span>,<br><span class="hljs-number">11</span>,<br><span class="hljs-string">&#x27;周杰伦&#x27;</span>,<br><span class="hljs-number">2</span>,<br><span class="hljs-string">&#x27;近日转会加盟新公司的周杰伦，同时推出了其年度国语专辑《叶惠美》，收录11首个人独唱歌曲。虽然新碟的惊喜不大，但仍保持着阿Jay一贯的个人风格(其实这正是乐迷最喜欢的)，而且多首歌曲亦较以往更有深度，故此并不算「原地踏步」。再者，当中某几首歌曲，更是惹人钟爱之作，相信这专辑依然会得到不少乐迷支持。&#x27;</span><br>); <br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Album;<br><br><span class="hljs-keyword">DESC</span> Song;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> Song (NAME, serial_num, id)<br><span class="hljs-keyword">VALUES</span><br>    (<span class="hljs-string">&#x27;爱在西元前&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>    (<span class="hljs-string">&#x27;爸我回来了&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>),<br>    (<span class="hljs-string">&#x27;简单爱&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>),<br>    (<span class="hljs-string">&#x27;忍者&#x27;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>),<br>    (<span class="hljs-string">&#x27;开不了口&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>),<br>    (<span class="hljs-string">&#x27;上海一九四三&#x27;</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>),<br>    (<span class="hljs-string">&#x27;对不起&#x27;</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>),<br>    (<span class="hljs-string">&#x27;威廉古堡&#x27;</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>),<br>    (<span class="hljs-string">&#x27;双截棍&#x27;</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>),<br>    (<span class="hljs-string">&#x27;安静&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>    <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> Song (NAME, serial_num, id)<br><span class="hljs-keyword">VALUES</span><br>    (<span class="hljs-string">&#x27;以父为名&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">11</span>),<br>    (<span class="hljs-string">&#x27;儒夫&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">12</span>),<br>    (<span class="hljs-string">&#x27;晴天&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">13</span>),<br>    (<span class="hljs-string">&#x27;三年二班&#x27;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">14</span>),<br>    (<span class="hljs-string">&#x27;东风破&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">15</span>),<br>    (<span class="hljs-string">&#x27;你听得到&#x27;</span>, <span class="hljs-number">6</span>, <span class="hljs-number">16</span>),<br>    (<span class="hljs-string">&#x27;同一种调调&#x27;</span>, <span class="hljs-number">7</span>, <span class="hljs-number">17</span>),<br>    (<span class="hljs-string">&#x27;她的睫毛&#x27;</span>, <span class="hljs-number">8</span>, <span class="hljs-number">18</span>),<br>    (<span class="hljs-string">&#x27;爱情悬崖&#x27;</span>, <span class="hljs-number">9</span>, <span class="hljs-number">19</span>),<br>    (<span class="hljs-string">&#x27;梯田&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>),<br>    (<span class="hljs-string">&#x27;双刀&#x27;</span>, <span class="hljs-number">11</span>, <span class="hljs-number">21</span>);<br> <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Song;<br><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> TABLES;<br><br><span class="hljs-keyword">DESC</span> <span class="hljs-keyword">USER</span>;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">USER</span> (username, image, signature, id)<br><span class="hljs-keyword">VALUES</span><br>    (<br>        <span class="hljs-string">&#x27;张三&#x27;</span>,<br>        <span class="hljs-string">&#x27;https://demo/zhangsan.png&#x27;</span>,<br>        <span class="hljs-string">&#x27;人生无常，大肠包小肠。&#x27;</span>,<br>        <span class="hljs-string">&#x27;1&#x27;</span><br>    ),<br>    (<br>        <span class="hljs-string">&#x27;李四&#x27;</span>,<br>        <span class="hljs-string">&#x27;https://demo/lisi.png&#x27;</span>,<br>        <span class="hljs-string">&#x27;先打一拳，打的时候再把问题问遍。&#x27;</span>,<br>        <span class="hljs-number">2</span><br>    );<br>    <br><span class="hljs-keyword">DESC</span> review;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> Review (<br>    content,<br>    rating,<br>    review_time,<br>    album_id,<br>    user_id<br>)<br><span class="hljs-keyword">VALUES</span><br>    (<br>        <span class="hljs-string">&#x27;首首经典 难以超越的高度 且不仅仅只对周杰伦而言&#x27;</span>,<br>        <span class="hljs-number">5</span>,<br>        <span class="hljs-string">&#x27;2007-3-11 13:02:23&#x27;</span>,<br>        <span class="hljs-number">1</span>,<br>        <span class="hljs-number">1</span><br>    ),<br>    (<br>        <span class="hljs-string">&#x27;题材，旋律，曲风，制作，歌词，商业度和流行度，全方位炸裂，从头高潮到尾。&#x27;</span>,<br>        <span class="hljs-number">5</span>,<br>        <span class="hljs-string">&#x27;2017-5-17 10:30:15&#x27;</span>,<br>        <span class="hljs-number">1</span>,<br>        <span class="hljs-number">2</span><br>    ),<br>    (<br>        <span class="hljs-string">&#x27;十来岁的记忆全部浓缩在这张专辑里；从它开始学会了怎样欣赏音乐，体验到了陶醉和沉浸的感觉&#x27;</span>,<br>        <span class="hljs-number">4</span>,<br>        <span class="hljs-string">&#x27;2012-7-08 16:15:36&#x27;</span>,<br>        <span class="hljs-number">2</span>,<br>        <span class="hljs-number">1</span><br>    ),<br>    (<br>        <span class="hljs-string">&#x27;周董最好的一张专辑，晴天听一百遍也不会腻，都是青春的回忆。&#x27;</span>,<br>        <span class="hljs-number">5</span>,<br>        <span class="hljs-string">&#x27;2015-11-13 08:49:30&#x27;</span>,<br>        <span class="hljs-number">2</span>,<br>        <span class="hljs-number">2</span><br>    );<br>    <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Review;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">USER</span>;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Album;<br><br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> Album <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多系统启动U盘解决方案</title>
    <link href="/2022/04/27/5613b7c49ab5.html"/>
    <url>/2022/04/27/5613b7c49ab5.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>自接触电脑以来，一直被自己的强迫症打败。重装系统的次数不下于三四十余次，原因要么是安装软件环境变量没配好，误删系统关键文件，导致某些操作频繁报错，要么是爱折腾双系统、多系统以及黑苹果导致。对于六字真言『重启重装 重买』，以我目前的经济水平，只能践行前四字。 <span id="more"></span>重装系统与我而言，乃是家常便饭。从组装自己的第一台主机那时的激动喜悦，到现在的麻木装机。碰到最多的问题，每次都是下载当前最新的系统镜像，重新格式化制作启动盘。当然这一切得益于我的强迫症，好多次冒出以下想法：如果给我一台新电脑，我一定在旧电脑上折腾明白，然后小心翼翼把新电脑按需配置得明明白白，就像先打草稿再誊写一样。</p><p>此前装Windows系统可以用一个U盘，制作一个PE就能一劳永逸，最多替换一下ISO镜像文件。后来有了装Ubuntu和MacOS的需求，一个U盘就不能满足我了。直到了解到Ventoy，它的出现解决了我装机最大的痛点。</p><h2 id="使用">使用</h2><p>Ventoy可以理解为在之前我们熟知的PE引导外边，又套了一层引导，并且这层引导可以识别各种EFI和Grub以及ISO等，做到轻松在多系统之间切换，有了它，从根本上解决了反复格式化U盘的问题。它甚至可以引导 win to go 以及 ubuntu to go，这一点给我带来了很大的惊喜。此外，它也有丰富的插件以拓展其功能，以后用到再补充吧。</p><p>那么话不多说， Let's start!</p><h3 id="准备">准备</h3><ol type="1"><li>一个U盘 （我的是128G的SSD优盘，因为打算装一个WTG）</li><li>系统镜像 <a href="https://next.itellyou.cn/Original/">MSDN</a></li><li>Ventoy <ahref="https://www.ventoy.net/cn/index.html">Ventoy官网</a></li><li>WePE <ahref="https://www.wepe.com.cn/download.html">WePE官网</a></li><li>WTG辅助工具 <ahref="https://bbs.luobotou.org/forum-88-1.html">萝卜头论坛</a></li></ol><h3 id="制作步骤">制作步骤</h3><ol type="1"><li>用WTG辅助工具制作虚拟磁盘</li><li>制作Ventoy启动盘</li><li>将WePE, 镜像 以及 虚拟磁盘复制到 U盘</li><li>打上引导的插件</li></ol>]]></content>
    
    
    <categories>
      
      <category>瞎折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ventoy</tag>
      
      <tag>WinPE</tag>
      
      <tag>win to go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——枚举注解异常</title>
    <link href="/2022/04/25/9198f0f5f6dc.html"/>
    <url>/2022/04/25/9198f0f5f6dc.html</url>
    
    <content type="html"><![CDATA[<h1 id="枚举">枚举</h1><p>创建Season对象有如下特点： 1. 季节的值是有限的几个值(spring, summer,autumn, winter)</p><ol start="2" type="1"><li>只读，不需要修改</li></ol><p>解决方案： 1. 枚举对应英文(enumeration，简写enum)</p><ol start="2" type="1"><li><p>枚举是一组常量的集合</p></li><li><p>可以理解为：枚举属于一种特殊的类，里面只包含一组有限的特定对象<span id="more"></span></p></li></ol><h2 id="枚举的两种实现方式">枚举的两种实现方式</h2><h3 id="自定义类实现枚举">自定义类实现枚举</h3><ul><li>不需要提供 <code>setXxx</code> 方法，因为枚举对象通常为只读</li><li>对枚举对象/属性使用 <code>final</code> + <code>static</code>共同修饰，实现底层优化</li><li>枚举对象通常使用全部大写，常量的命名规范</li><li>枚举对象根据需要，可以有多个属性<br /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company.enum_;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Enumeration</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        System.out.println(Season.SPRING);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Season</span> &#123;  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> String desc;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Season</span> <span class="hljs-variable">SPRING</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>(<span class="hljs-string">&quot;春天&quot;</span>, <span class="hljs-string">&quot;温暖&quot;</span>);  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Season</span> <span class="hljs-variable">SUMMER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>(<span class="hljs-string">&quot;夏天&quot;</span>, <span class="hljs-string">&quot;炎热&quot;</span>);  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Season</span> <span class="hljs-variable">AUTUMN</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>(<span class="hljs-string">&quot;秋天&quot;</span>, <span class="hljs-string">&quot;凉爽&quot;</span>);  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Season</span> <span class="hljs-variable">WINTER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>(<span class="hljs-string">&quot;冬天&quot;</span>, <span class="hljs-string">&quot;寒冷&quot;</span>);  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Season</span><span class="hljs-params">(String name, String desc)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>        <span class="hljs-built_in">this</span>.desc = desc;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> name;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDesc</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> desc;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Season&#123;&quot;</span> +  <br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +  <br>                <span class="hljs-string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +  <br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure> 小结：进行自定义类实现枚举，有如下特点：</li><li>构造器私有</li><li>本类内部创建一组对象</li><li>对外暴露对象(通过为对象添加 <code>public final static</code>修饰符)</li><li>可以提供 <code>get</code> 方法，但是不要提供 <code>set</code>方法</li></ul><h3 id="使用-enum-关键字实现枚举">使用 enum 关键字实现枚举</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Season</span> &#123;  <br>    SPRING(<span class="hljs-string">&quot;春天&quot;</span>, <span class="hljs-string">&quot;温暖&quot;</span>), SUMMER(<span class="hljs-string">&quot;夏天&quot;</span>, <span class="hljs-string">&quot;炎热&quot;</span>), <br>    AUTUMN(<span class="hljs-string">&quot;秋天&quot;</span>, <span class="hljs-string">&quot;凉爽&quot;</span>), WINTER(<span class="hljs-string">&quot;冬天&quot;</span>, <span class="hljs-string">&quot;寒冷&quot;</span>);  <br>  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> String desc;  <br>  <br>    Season(String name, String desc) &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>        <span class="hljs-built_in">this</span>.desc = desc;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> name;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDesc</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> desc;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Season&#123;&quot;</span> +  <br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +  <br>                <span class="hljs-string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +  <br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注意事项">注意事项</h4><ol type="1"><li>当使用 <code>enum</code> 关键字开发一个枚举类时，默认会继承<code>Enum</code> 类 (javap反编译) <imgsrc="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/202205091853320.png" /></li><li>传统的<code>public static final Season SPRING = new Season("春天", "温暖");</code>简化成 <code>SPRING("春天", "温暖")</code> ，这里需清楚它调用的是哪个构造器</li><li>如果无参构造器 创建 枚举对象，则实参列表和小括号都可以省略</li><li>当有多个枚举对象时，使用 <code>,</code>间隔，最后有一个分号结尾</li><li>枚举对象必须放在枚举类的行首</li></ol><h4 id="enum常用方法">enum常用方法</h4><p>使用关键字 <code>enum</code> 时，会隐式继承 Enum 类，因此可以使用Enum 类相关方法 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Enum</span>&lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Enum</span>&lt;E&gt;&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;, Serialization &#123;<br>&#125;<br></code></pre></td></tr></table></figure></p><table><thead><tr class="header"><th style="text-align: center;">方法名</th><th>详细描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">valueOf</td><td>传递枚举类型的Class对象和枚举常量名称给静态方法valueOf，会得到与参数匹配的枚举常量。</td></tr><tr class="even"><td style="text-align: center;">toString</td><td>得到当前枚举常f的名称。你可以通过重写这个方法来使得到的结果更易读。</td></tr><tr class="odd"><td style="text-align: center;">equals</td><td>在枚举类型中可以直接使用 "=="来比较两个枚举常量是否相等。Enum提供的这个equals()方法，也是直接使用"=="实现的。它的存在是为了在Set、List和Map中使用。注意，equals()是不可变的。</td></tr><tr class="even"><td style="text-align: center;">hashCode</td><td>Enum 实现了hashCode()来和equals()保持一致。它也是不可变的。</td></tr><tr class="odd"><td style="text-align: center;">getDeclaringClass</td><td>得到枚举常量所属枚举类型的Class对象。可以用它来判断两个枚举常量是否属于同一个枚举类型。</td></tr><tr class="even"><td style="text-align: center;">name</td><td>得到当前枚举常量的名称。建议优先使用toString()。</td></tr><tr class="odd"><td style="text-align: center;">ordinal</td><td>得到当前枚举常量的次序。(从0开始编号)</td></tr><tr class="even"><td style="text-align: center;">compareTo</td><td>枚举类型实现了Comparable接口,这样可以比较两个枚举常量的大小（按照声明的顺序排列)</td></tr><tr class="odd"><td style="text-align: center;">clone</td><td>枚举类型不能被Clone。为了防止子类实现克隆方法,Enum实现了一个仅抛出CloneNotSupportedException异常的不变Clone()。</td></tr><tr class="even"><td style="text-align: center;">values</td><td>返回当前枚举类中所有的常量, 用对象数组接收</td></tr></tbody></table><h4 id="enum-实现接口">enum 实现接口</h4><ol type="1"><li>使用enum关键字后，就不能继承其它类了，因为enum会隐式继承Enum，而Java时单继承机制。</li><li>枚举类和普通类一样，可以实现接口 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> 类名 implements 接口<span class="hljs-number">1</span>, 接口<span class="hljs-number">2</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="注解">注解</h1><h2 id="注解的理解">注解的理解</h2><ol type="1"><li>注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息。</li><li>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。</li><li>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和xml配置等。</li></ol><h2 id="基本的-annotation-介绍">基本的 Annotation 介绍</h2><p>使用Annotation时要在其前面增加<code>@</code>符号，并把该Annotation当成一个修饰符使用。用于修饰它支持的程序元素</p><p>三个基本的Annotation:</p><ol type="1"><li><code>@Override</code>:限定某个方法，是重写父类方法，该注解只能用于方法</li><li><code>@Deprecated</code>:用于表示某个程序元素(类，方法等)已过时</li><li><code>@SuppressWarnings</code>: 抑制编译器警告 ({"all"})</li></ol><blockquote><p>补充说明：<code>@interface</code>不是interface，是注解类，是jdk5.0之后加入的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span>  <span class="hljs-comment">// 修饰注解的注解</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override &#123;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="四种元注解">四种元注解</h2><ol type="1"><li><code>Retention</code>//指定注解的作用范围，三种SOURCE,CLASS,RUNTIME</li><li><code>Target</code> //指定注解可以在哪些地方使用</li><li><code>Documented</code> //指定该注解是否会在javadoc体现</li><li><code>Inherited</code> //子类会继承父类注解</li></ol><h1 id="异常">异常</h1><h2 id="异常基本介绍">异常基本介绍</h2><ul><li><p>基本概念Java语言中，将程序执行中发生的不正常情况称为“异常”。(开发过程中的语法错误和逻辑错误不是异常)</p></li><li><p>执行过程中所发生的异常事件可分为两类</p></li></ul><ol type="1"><li>Error(错误)：Java虚拟机无法解决的严重问题。如:JVM系统内部错误、资源耗尽等严重情况。比如:StackOverflowError[栈溢出]和OOM(out of memory)，Error是严重错误,程序会崩溃。</li><li>Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等，Exception分为两大类：<strong>运行时异常</strong>和<strong>编译时异常</strong>。</li></ol><h2 id="异常体系图">异常体系图</h2><ul><li>体现了继承和实现关系 <imgsrc="https://cdn.jsdelivr.net/gh/nessaj7/ImageHost/img/202206131515452.png" /></li></ul><p>编译异常： Java源程序 -&gt; 字节码文件 运行异常： 字节码文件 -&gt;在内存种加载、运行类</p><h3 id="异常体系图的小结">异常体系图的小结</h3><ol type="1"><li>异常分为两大类,运行时异常和编译时异常；</li><li>运行时异常，编译器检测不出。一般是指编程时的逻辑错误，是程序员应该避免其出现的异常。<code>java.lang.RuntimeException</code>类及它的子类都是运行时异常；</li><li>对于运行时异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响；</li><li>编译时异常，是编译器要求必须处置的异常。</li></ol><h2 id="常见的运行时异常">常见的运行时异常</h2><ul><li><code>NullPointerException</code> 空指针异常</li><li><code>ArithmeticException</code> 数据运算异常</li><li><code>ArrayIndexOutOfBoundsException</code> 数组下标越界异常</li><li><code>ClassCastException</code> 类型转换异常当试图将对象强制转换为不是实例的子类时，抛出该异常</li><li><code>NumberFormatException</code> 数据格式不正确异常</li></ul><h2 id="常见的编译时异常">常见的编译时异常</h2><ul><li><code>SQLException</code> 操作数据库时，查询表可能发生的异常</li><li><code>IOException</code> 操作文件时，发生的异常</li><li><code>FileNotFoundException</code>当操作一个不存在的文件时，发生异常</li><li><code>ClassNotFoundException</code>加载一个不存在的类时，发生的异常</li><li><code>EOFException</code> 操作文件，到文件末尾，发生异常</li><li><code>IllegalArguementException</code> 参数异常</li></ul><h2 id="异常处理">异常处理</h2><h3 id="基本介绍">基本介绍</h3><p>异常处理就是当异常发生时，对异常处理的方式。 ### 异常处理的方式1）<code>try-catch-finally</code> 程序员在代码种捕获发生的异常，自行处理<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 可能有有异常的代码</span><br>&#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br><span class="hljs-comment">// 捕获到异常</span><br><span class="hljs-comment">// 当异常发生时，系统将异常封装成Exception对象e，传递给catch</span><br><span class="hljs-comment">// 得到异常后，程序员自己处理</span><br><span class="hljs-comment">// 若没有发生异常则catch代码块不执行</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">// 1. 不管try代码块是否有异常发生，始终要执行finally</span><br><span class="hljs-comment">// 2. 通常将释放资源的代码放在这里</span><br>&#125;<br></code></pre></td></tr></table></figure> 2）<code>throws</code>将发生的异常抛出，交给调用者(方法)来处理，最顶级的处理者就是JVM，输出异常信息，退出程序<imgsrc="https://cdn.jsdelivr.net/gh/nessaj7/ImageHost/img/202206131600789.png" /></p><h3 id="try---catch-注意事项">try - catch 注意事项</h3><p>快捷键：<code>ctrl + alt + t</code> 1.如果异常发生，则异常发生后面的代码不会执行，直接进入到catch块 2.如果异常没有发生，则顺序执行try的代码块，不会进入到catch 3.如果希望不管是否发生异常，都执行某段代码(比如关闭连接，释放资源等)则使用finally4.可以有多个catch语句，捕获不同的异常(进行不同的业务处理)，要求<strong>父类异常在后，子类异常在前</strong>，比如(Exception在后，NullPointerException在前)，如果发生异常，只会匹配一个catch5. 可以进行 try - finally配合使用，这种用法相当于没有捕获异常，因此程序会直接崩掉/退出。应用场景，就是执行一段代码，不管是否发生异常，都必须执行某个业务逻辑。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(str);<br>System.out.println(<span class="hljs-string">&quot;数字：&quot;</span> + a);<br>&#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;<br>System.out.println(<span class="hljs-string">&quot;异常信息 = &quot;</span> + e.getMessage());<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;程序继续执行...&quot;</span>);<br><br></code></pre></td></tr></table></figure></p><h4 id="练习1">练习1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Exception01</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            i++;  <br>            String[] names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">3</span>];  <br>            <span class="hljs-keyword">if</span> (names[<span class="hljs-number">1</span>].equals(<span class="hljs-string">&quot;tom&quot;</span>)) &#123;  <br>                System.out.println(names[<span class="hljs-number">1</span>]);  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                names[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;kuhn&quot;</span>;  <br>            &#125;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>        &#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;  <br>        &#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;  <br>            <span class="hljs-keyword">return</span> i++; <span class="hljs-comment">// i = 2 =&gt; 保存临时变量 tmp = 2, i = 3        &#125; finally &#123;  </span><br>            ++i; <span class="hljs-comment">// i = 4  </span><br>            System.out.println(<span class="hljs-string">&quot;i = &quot;</span> + i); <span class="hljs-comment">// i = 4  </span><br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        System.out.println(method()); <span class="hljs-comment">// 2  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="练习2">练习2</h4><p>循环输入，直到是整数为止 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Exception01</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;请输入一个整数：&quot;</span>);  <br>  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                num = Integer.parseInt(scanner.next());  <br>                <span class="hljs-keyword">break</span>;            &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;  <br>                System.out.println(<span class="hljs-string">&quot;非法输入，请重试！&quot;</span>);  <br>            &#125;  <br>        &#125;  <br>        System.out.println(<span class="hljs-string">&quot;输入的值为：&quot;</span> + num);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        method();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="throws-异常处理">throws 异常处理</h3><p>1）如果一个方法（中的语句执行时）可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法地调用者负责处理；2）在方法声明中用throws语句可以声明抛出异常地列表，throws后面地异常类型可以是方法中产生地异常类型，也可以是该异常的父类；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">(String file)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 读取文件的操作可能产生FileNotFoundException类型的异常</span><br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;./tmp.txt&quot;</span>);<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure> - 注意事项和使用细节 1）对于编译异常，程序中必须处理，比如<code>try-catch</code> 或者 <code>throws</code>2）对于<em>运行时</em>异常，程序中如果没有处理，默认就是<code>throws</code>的方式处理3）子类<strong>重写</strong>父类的方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类型4）在<code>throws</code> 过程中，如果有方法 <code>try - catch</code>，就相当于处理异常，此时就不必 <code>throws</code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span> &#123;<br>f2();  <span class="hljs-comment">// 报错</span><br><span class="hljs-comment">// f2()抛出编译异常，f1()调用就要处理它的异常</span><br><span class="hljs-comment">// 要么 throws 抛出， 要么 try-catch</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;./tmp.txt&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure> ##自定义异常 ### 自定义异常的步骤 1.定义类：自定义异常类名继承<code>Exception</code>或者<code>RuntimeException</code>2. 如果继承<code>Exception</code>，属于编译异常 3.如果继承<code>RuntimeException</code>，属于运行异常（最常见）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomException</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">180</span>;<br><span class="hljs-keyword">if</span> (!(age &gt;= <span class="hljs-number">18</span> &amp;&amp; age &lt;= <span class="hljs-number">120</span>)) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AgeException</span>(<span class="hljs-string">&quot;年龄需要在18 ~ 120之间&quot;</span>);<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;输入正确&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">AgeException</span><span class="hljs-params">(String message)</span> &#123; <span class="hljs-comment">// 构造器</span><br><span class="hljs-built_in">super</span>(message);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure> ## throw 和 throws的对比 | | 意义 | 位置 | 后面跟的东西 || ------ | ------------------------ | ---------- | ------------ | |throws | 异常处理的一种方式 | 方法声明处 | 异常类型 | | throw |手动生成异常对象的关键字 | 方法体中 | 异常对象 | <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReturnExceptionDemo</span> &#123;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;1. 进入方法A&quot;</span>);  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;3. 制造异常&quot;</span>);  <br>        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;2. 用A方法的finally&quot;</span>);  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;4. 进入方法B&quot;</span>);  <br>            <span class="hljs-keyword">return</span>;        &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;5. 调用B方法的finally&quot;</span>);  <br>        &#125;  <br>    &#125;  <br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        ReturnExceptionDemo.methodA();  <br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>        System.out.println(e.getMessage());  <br>    &#125;  <br>    ReturnExceptionDemo.methodB();  <br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——面向对象编程(高级)</title>
    <link href="/2022/04/21/fe17ffcb6203.html"/>
    <url>/2022/04/21/fe17ffcb6203.html</url>
    
    <content type="html"><![CDATA[<h1 id="类变量和类方法">类变量和类方法</h1><h2 id="类变量">类变量</h2><p>static变量 被类的所有对象实例共享jdk8以后，静态变量在内存的<strong>堆</strong>中 class实例的尾部共识：<span id="more"></span></p><ol type="1"><li>static变量是同一个类所有对象共享</li><li>static类变量，在<strong>类加载</strong>的时候就生成了，<font color="#558088">没创建实例也能访问</font></li></ol><p>定义：<code>访问修饰符 static 数据类型 变量名</code>访问：<code>类名.类变量名</code></p><h3 id="使用细节">使用细节</h3><ol type="1"><li>什么时候需要用类变量当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量(静态变量)：例如：定义学生类，统计所有学生共交了多少钱。<code>Student(name, static fee)</code></li><li>类变量与实例变量(普通变量)区别类变量是该类的所有对象共享的，而实例变量是每个对象独享的。</li><li>实例变量不能通过<code>类名.类变量名</code>方式访问</li><li>类变量是在类加载时就初始化了，即使没创建对象，只要类加载了，就可以使用类变量</li><li>类变量的生命周期时随类的加载开始，随类的消亡而销毁</li></ol><h2 id="类方法">类方法</h2><p>定义：<code>访问修饰符 static 数据返回类型 方法名()&#123; &#125;</code>访问：<code>类名.类方法名</code><u>前提满足访问修饰符的访问权限和范围</u>使用场景：当方法不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，不需要创建对象就可以使用，提高开发效率。比如：工具类中的方法utils,Math类，Arrays类，Collections集合类</p><h3 id="使用细节-1">使用细节</h3><ol type="1"><li>类方法和普通方法都是随类的加载而加载，将结构信息存储在方法区：类方法中无<code>this</code>的参数，普通方法中隐含<code>this</code>的参数</li><li>类方法可以通过类名调用，也可以通过对象名调用</li><li>类方法中不允许使用和对象有关的关键字，比如<code>this</code>和<code>super</code>，普通方法(成员方法)可以。</li><li>类方法中只能访问静态变量或静态方法，普通成员方法还能访问普通变量和方法</li></ol><h1 id="理解main方法语法">理解main方法语法</h1><p><code>public static void main(String[] args)</code> 1.Java虚拟机需要调用类的main()方法，所以该方法的访问权限必须时public 2.Java虚拟机在执行main()方法时不必创建对象，所以该方法必须时static 3.该方法在接收String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数4. java 执行的程序 参数1 参数2 参数3 ...</p><h2 id="特别提示">特别提示：</h2><ol type="1"><li>在main()方法中，我们可以直接调用main方法所在类的静态方法或静态属性</li><li>不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员。</li></ol><h1 id="代码块">代码块</h1><p>代码块又称<u>初始化块</u>，属于类中的成员，即类的一部分，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来。但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。基本语法 <code>[static] &#123; 代码 &#125;</code></p><h2 id="代码块的好处">代码块的好处</h2><ol type="1"><li>相当于另一种形式的构造器（对构造器的补充机制），可以做初始化操作</li><li>场景：如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性</li></ol><h2 id="代码块使用注意事项和细节">代码块使用注意事项和细节</h2><ol type="1"><li>static代码块也叫静态代码块，作用是对类进行初始化，而且它随着<font color=#008000>类的加载</font>而执行，并且<font color=#008000>只会执行一次</font>。如果是普通代码块，每<strong>创建一个对象</strong>，就执行一次。</li><li>类被加载的三种情况(<font color=#008000>重要</font>)<ol type="1"><li>创建对象实例时(new)</li><li>创建子类对象实例，父类也会被加载</li><li>使用类的静态成员时(静态属性，静态方法)</li></ol></li><li>普通代码块，在创建对象实例时，会被隐式的调用。如果只是使用类的静态成员，普通代码块不会被执行。</li><li>创建一个对象时，在<font color=#008000>一个类</font>中调用顺序：(<font color=#008000>重要</font>)<ol type="1"><li>调用静态代码块和静态属性<strong>初始化</strong>（优先级一样，顺序调用）</li><li>调用普通代码块和普通属性的<strong>初始化</strong>（优先级一样）</li><li>调用构造方法</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.company.codeblock_;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeBlockExercise02</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sample</span> &#123;  <br>    Sample (String s) &#123;  <br>        System.out.println(s);  <br>    &#125;  <br>  <br>    Sample () &#123;  <br>        System.out.println(<span class="hljs-string">&quot;调用 Sample 默认无参构造器&quot;</span>);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>    <span class="hljs-type">Sample</span> <span class="hljs-variable">sam1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sample</span>(<span class="hljs-string">&quot;sam1 成员初始化&quot;</span>); <span class="hljs-comment">// 3  </span><br>  <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Sample</span> <span class="hljs-variable">sam</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sample</span>(<span class="hljs-string">&quot;静态成员sam初始化&quot;</span>); <span class="hljs-comment">// 1  </span><br>  <br>    <span class="hljs-keyword">static</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;static块执行&quot;</span>); <span class="hljs-comment">// 2  </span><br>        <span class="hljs-keyword">if</span> (sam ** <span class="hljs-literal">null</span>) System.out.println(<span class="hljs-string">&quot;sam is null&quot;</span>);  <br>    &#125;  <br>  <br>    Test () &#123;  <br>        System.out.println(<span class="hljs-string">&quot;Test默认构造器被调用&quot;</span>); <span class="hljs-comment">// 4  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>构造器（构造方法）的最前面其实<strong>隐含了super()和调用普通代码块</strong>；静态相关的代码块、属性初始化，在类加载时就执行完毕。因此是优先于构造器和普通代码块执行的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// super();</span><br><span class="hljs-comment">// 调用普通代码块</span><br>System.out.println(<span class="hljs-string">&quot;ok&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>创建一个子类时，调用顺序： 父静 -&gt; 子静 -&gt; 父普 -&gt; 父构-&gt; 子普 -&gt; 子构 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> (<span class="hljs-number">1</span>) 进行类的加载<br><span class="hljs-regexp">//</span> <span class="hljs-number">1.1</span> 先加载父类  <span class="hljs-number">1.2</span> 再加载子类<br><span class="hljs-regexp">//</span> (<span class="hljs-number">2</span>) 创建对象<br><span class="hljs-regexp">//</span> <span class="hljs-number">2.1</span> 从子类构造器开始<br></code></pre></td></tr></table></figure></li><li>静态代码块只能直接调用静态成员，普通代码块可以调用任意成员</li></ol><h1 id="单例设计模式">单例设计模式</h1><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法步骤： 1. 构造器私有化 (防止直接new) 2. 类的内部创建对象 3.向外暴露一个静态的公共方法(getInstance)</p><h2 id="饿汉式">饿汉式</h2><p><strong>没调用也会创建对象</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.company.single_;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleInstance01</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">GirlFriend</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> GirlFriend.getInstance();  <br>        System.out.println(instance);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GirlFriend</span> &#123;  <br>    <span class="hljs-keyword">private</span> String name;  <br>  <br>    <span class="hljs-comment">// 1. 将构造器私有化  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">GirlFriend</span><span class="hljs-params">(String name)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 2. 类内创建静态对象  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">GirlFriend</span> <span class="hljs-variable">joe</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GirlFriend</span>(<span class="hljs-string">&quot;Jocelyn&quot;</span>);  <br>  <br>    <span class="hljs-comment">// 3. 静态方法返回对象引用  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GirlFriend <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> joe;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;GirlFriend&#123;&quot;</span> +  <br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +  <br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="懒汉式">懒汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.company.single_;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleTon</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        System.out.println(Cat.n1);  <br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">ins</span> <span class="hljs-operator">=</span> Cat.getInstance();  <br>        System.out.println(ins);  <br>  <br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">ins2</span> <span class="hljs-operator">=</span> Cat.getInstance();  <br>        System.out.println(ins2);  <br>  <br>        System.out.println(ins == ins2);  <span class="hljs-comment">// true</span><br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Cat cat;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(String name)</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;创建Cat对象...&quot;</span>);  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Cat <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (cat == <span class="hljs-literal">null</span>) &#123;  <br>            cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;mimi&quot;</span>);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> cat;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Cat&#123;&quot;</span> +  <br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +  <br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="饿汉式vs懒汉式">饿汉式VS懒汉式</h2><ol type="1"><li>两种主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建；</li><li>饿汉式不存在线程安全问题，懒汉式存在线程安全问题；</li><li>饿汉式存在资源浪费的可能；（没有使用对象实例）</li><li>在JavaSE标准类中，<code>java.lang.Runtime</code>是经典的单例模式；</li></ol><h1 id="final关键字">final关键字</h1><h2 id="基本介绍">基本介绍</h2><p><code>final</code>可以修饰类、属性、方法和局部变量 1.当不希望类被继承时，可以用final修饰； 2.当不希望父类的某个方法被子类覆盖/重写(override)时，可以用final关键字修饰；3. 当不希望类的某个属性的值被修改，可以用final修饰； 4.当不希望某个局部变量被修改，可以使用final修饰；</p><h2 id="注意事项">注意事项</h2><ol type="1"><li>final修饰的属性又叫常量，一般用XX_XX来命名；</li><li>final修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值方式：<ul><li>定义时；</li><li>在构造器中；</li><li>在代码块中；</li></ul></li><li>如果final修饰的属性是静态的，则初始化的不能在构造器中赋值；</li><li>final类不能继承，但是可以实例化；</li><li>如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承；</li><li>一般来说，如果一个类已经是final类了，就没必要再将方法修饰成final方法；</li><li><strong>final不能修饰构造器</strong></li><li>final 和 static往往搭配使用，效率更高，底层编译器做了优化处理；<br /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;   <br>    <span class="hljs-comment">// 有final 静态代码块不会被提前加载</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;  <br>  <br>    <span class="hljs-keyword">static</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;类A被加载...&quot;</span>);  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>包装类(Integer, Double, Float,Boolean等都是final)，String也是final类；</li></ol><h1 id="抽象类">抽象类</h1><ul><li>父类方法的不确定性当父类的某些方法，需要声明，但是又不确定如何实现时，可以将其声明为抽象方法，那么这个类就是抽象类，用abstract修饰；抽象类会被继承，由其子类实现具体方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">访问修饰符 <span class="hljs-keyword">abstract</span> 返回类型 方法名(参数列表); <span class="hljs-comment">// 没有方法体</span><br></code></pre></td></tr></table></figure></li><li>抽象类的价值更多作用在于设计，是设计者设计好后，让子类继承并实现抽象类，在框架和设计模式使用较多## 使用细节和注意事项</li></ul><ol type="1"><li><strong>抽象类不能被实例化</strong></li><li>抽象类不一定要包含abstract方法</li><li>一旦类包含了abstract方法，则这个类必须声明为abstract</li><li>abstract 只能修饰类和方法，不能修饰属性和其它的</li><li>抽象类可以有任意成员【抽象类本质还是类】</li><li>抽象方法不能有主体，即不能实现</li><li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也申明为abstract<strong>类</strong></li><li>抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的</li></ol><h2 id="模板设计模式">模板设计模式</h2><p>设计一个抽象类(Template)，能完成如下功能： 1.编写一个方法calculateTime()，可以计算某段代码的耗时时间 2.编写抽象方法job() 3. 编写一个子类Sub，继承抽象类Template，并实现job方法4. 编写一个测试类TestTemplate<br /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company.abstract_;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestTemplate</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Sub</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>();  <br>        sub.calculateTime();  <span class="hljs-comment">// 多态的动态绑定机制</span><br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Template</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 抽象方法  </span><br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">calculateTime</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();  <br>        job(); <span class="hljs-comment">// 调用  动态绑定机制</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();  <br>        System.out.println(<span class="hljs-string">&quot;耗时：&quot;</span> + (end - start));  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Template</span> &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-comment">// 具体的工作  </span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">800000</span>; i++) &#123;  <br>            num += i;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure> # 接口 ## 基本介绍接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">interface 接口名 &#123;<br><span class="hljs-comment">// 属性</span><br><span class="hljs-comment">// 方法</span><br>&#125;<br><br>class 类名 implements 接口 &#123;<br>自己属性;<br>自己方法;<br>必须实现的接口的抽象方法;<br>&#125;<br></code></pre></td></tr></table></figure> -在jdk8.0后接口类可以有static<em>静态方法</em>，default<em>默认方法</em>，也就是说接口中可以有方法的具体实现;- 在接口中，抽象方法可以省略abstract关键字 ## 使用细节 1.接口不能被实例化； 2.接口中所有的方法是<strong>public</strong>方法，接口中抽象方法，可以不用abstract修饰；3. 一个普通类实现接口，就必须将该接口的所有方法都实现； 4.抽象类实现接口，可以不用实现接口的方法； 5. 一个类同时可以实现多个接口；6. <u>接口中的属性，只能是final的，而且是public static final修饰符。</u>比如：<code>int a = 1;</code>实际上是<code>public static final int a = 1;</code>（必须初始化）7. 接口中属性的访问形式：<code>接口名.属性名</code> 8.一个接口不能<strong>继承</strong>其他类，但可以继承多个别的接口；<code>interface A extends B, C &#123;&#125;</code>9. 接口的修饰符只能是public和默认，这点和类的修饰符是一样的； ##实现接口 VS 继承类 1. 接口和继承解决的问题不同 -继承的价值主要在于：解决代码的复用性和可维护性 -接口的价值主要在于：设计，设计好各种规范(方法)，让其它类去实现这些方法2. 接口比继承更加灵活继承是满足<code>is-a</code>的关系，而接口只需满足<code>like-a</code>的关系3. 接口在一定程度上实现代码解耦 【接口规范性+动态绑定】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company.interface_;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExtendsVsInterface</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">LittleMonkey</span> <span class="hljs-variable">wuKong</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LittleMonkey</span>(<span class="hljs-string">&quot;wuKong&quot;</span>);  <br>        wuKong.climbing();  <br>        wuKong.swimming();  <br>        wuKong.flying();  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Monkey</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Monkey</span><span class="hljs-params">(String name)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">climbing</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(name + <span class="hljs-string">&quot;生来会爬树...&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> name;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-comment">// 实现接口可以理解为对 java 单继承机制的一种补充  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LittleMonkey</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Monkey</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fishable</span>, Birdable &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LittleMonkey</span><span class="hljs-params">(String name)</span> &#123;  <br>        <span class="hljs-built_in">super</span>(name);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(getName() + <span class="hljs-string">&quot;通过学习，会游泳了...&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flying</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(getName() + <span class="hljs-string">&quot;通过学习，会飞翔了...&quot;</span>);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fishable</span> &#123;  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span>;  <br>&#125;  <br>  <br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Birdable</span> &#123;  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">flying</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口多态特性">接口多态特性</h2><ol type="1"><li>多态参数<br />接口引用可以指向实现了接口的类的对象 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> &#123;  <br>    <span class="hljs-comment">// 传入接口  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">(UsbInterface usbInterface)</span> &#123;  <br>        <span class="hljs-comment">// 通过接口调用方法  </span><br>        usbInterface.start();  <br>        usbInterface.stop();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li>多态数组 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company.interface_;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfacePolyArr</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        Usb[] usbs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Usb</span>[<span class="hljs-number">2</span>];  <br>        usbs[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone_</span>();  <br>        usbs[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Camara_</span>();  <br>  <br>        <span class="hljs-keyword">for</span> (Usb usb : usbs) &#123;  <br>            <span class="hljs-keyword">if</span> (usb <span class="hljs-keyword">instanceof</span> Phone_) ((Phone_) usb).call(); <span class="hljs-comment">// 向下转型  </span><br>            usb.work(); <span class="hljs-comment">// 动态绑定  </span><br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Usb</span> &#123;  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone_</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Usb</span> &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;手机工作中...&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;---手机可以打电话---&quot;</span>);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Camara_</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Usb</span> &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;相机工作中...&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li>接口存在多态传递现象 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-comment">//xxx</span><br>&#125;<br><br><span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">C</span>(); <span class="hljs-comment">// 接口类型的变量指向实现该接口的类的对象实例</span><br><span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">C</span>(); <span class="hljs-comment">// B 继承了 A, C相当于也实现了接口A</span><br></code></pre></td></tr></table></figure> # 内部类 ## 基本介绍一个类的内部又完整的嵌套了另一个类结构，被嵌套的类称为内部类(innerclass)，嵌套其他类的类称为外部类(outerclass)。内部类最大特点就是可以直接访问<strong>私有属性</strong>，并且可以体现类与类之间的包含关系。类的五大成员：<strong>属性，方法，构造器，代码块，内部类</strong> ##基本语法 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123; <span class="hljs-comment">// 外部类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123; <span class="hljs-comment">// 内部类</span><br><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Other</span> &#123; <span class="hljs-comment">// 外部其他类</span><br><br>&#125;<br></code></pre></td></tr></table></figure> ## 内部类的分类</li></ol><ul><li>定义在外部类局部位置上(比如方法内, 代码块内)：<ul><li>局部内部类（有类名）</li><li><strong>匿名内部类</strong>（没有类名，<font color='ff0000'>重点！！！</font>）</li></ul></li><li>定义在外部类的成员位置上：<ul><li>成员内部类（没用static修饰）</li><li>静态内部类（使用static修饰）</li></ul></li></ul><h3 id="局部内部类">局部内部类</h3><ol type="1"><li>可以直接访问外部类的所有成员，包括私有的</li><li>不能添加访问修饰符，因为它的地位就是一个<strong>局部变量</strong>。局部变量是不能使用修饰符的。但是可以使用final修饰</li><li>作用域：仅仅在定义它的方法或代码块中</li><li>局部内部类 - 访问 - 外部类的成员 【访问方式：直接访问】</li><li>外部类 - 访问 - 局部内部类的成员 【访问方式：创建对象再访问】</li><li>外部其他类 - 不能访问 - 局部内部类</li><li>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可使用<code>外部类名.this.成员</code>去访问【<code>外部类名.this</code>本质是外部类的对象，谁调用就指谁】 ###匿名内部类 本质是类，内部类，该类没有名字，同时还是一个对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类或接口(参数列表) &#123;<br>类体<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><ul><li>匿名内部类的使用匿名内部类的语法比较奇特，因为匿名内部类既是一个类的定义，同时它本身也是一个对象，既有定义类的特征，也有创建对象的特征，因此可以调用匿名内部类方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company.innerclass_;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Outer</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();  <br>        outer.f1();  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// class 匿名内部类 extends Preson &#123;&#125;</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>() &#123; <span class="hljs-comment">// 创建一个基于类的匿名内部类  </span><br>            <span class="hljs-meta">@Override</span>  <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;  <br>                System.out.println(<span class="hljs-string">&quot;匿名内部类重写了hi()方法&quot;</span>);  <br>            &#125;  <br>        &#125;;  <br>        System.out.println(p.getClass());  <br>        p.hi(); <span class="hljs-comment">// 动态绑定，运行类型是 Outer$1</span><br>        <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>() &#123; <span class="hljs-comment">// 直接调用</span><br>            <span class="hljs-meta">@Override</span>  <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;  <br>                System.out.println(<span class="hljs-string">&quot;匿名内部类重写了hi()方法&quot;</span>);  <br>            &#125;  <br>        &#125;.hi();<br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;person.hi()&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company.innerclass_;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exercise</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-comment">// 匿名内部类  </span><br>        f1(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AA</span>() &#123;  <br>            <span class="hljs-meta">@Override</span>  <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;  <br>                System.out.println(<span class="hljs-string">&quot;**=当作实参直接传递**=&quot;</span>);  <br>            &#125;  <br>        &#125;);  <br>  <br>        <span class="hljs-comment">// 传统做法  </span><br>        f1(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Picture</span>());  <br>    &#125;  <br>    <span class="hljs-comment">// 静态方法，形参是接口类型  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">(AA a)</span> &#123;  <br>        a.show();  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">AA</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Picture</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AA</span> &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;**=硬编码**=&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company.innerclass_;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exercise02</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Cellphone</span> <span class="hljs-variable">cellphone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cellphone</span>();  <br>        <span class="hljs-comment">// 编译类型 ~ 运行类型  </span><br>        cellphone.alarmClock(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bell</span>() &#123;  <br>            <span class="hljs-meta">@Override</span>  <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ring</span><span class="hljs-params">()</span> &#123;  <br>                System.out.println(<span class="hljs-string">&quot;懒猪起床啦&quot;</span>);  <br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;  <br>                    x += i;  <br>                &#125;  <br>                System.out.println(<span class="hljs-string">&quot;x: &quot;</span> + x);  <br>            &#125;  <br>        &#125;);  <br><span class="hljs-comment">//lambda</span><br>        cellphone.alarmClock(() -&gt; System.out.println(<span class="hljs-string">&quot;小伙伴上课啦&quot;</span>));  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Bell</span> &#123;  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">ring</span><span class="hljs-params">()</span>;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cellphone</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alarmClock</span><span class="hljs-params">(Bell bell)</span> &#123;  <br>        System.out.println(bell.getClass());  <br>        bell.ring(); <span class="hljs-comment">// 动态绑定  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="成员内部类">成员内部类</h3><p>成员内部类是定义在外部类的成员位置，并且没有static修饰。 1.可以直接访问外部类的所有成员，包括私有的 2.可以添加任意访问修饰符，因为它的地位就是一个<strong>成员</strong> 3.作用域和外部类的其他成员一样，为整个类体。 4. 成员内部类 - 访问 - 外部类【访问方式：直接访问】 5. 外部类 - 访问 - 成员内部类【访问方式：创建对象，再访问】 6. 外部其他类 - 访问 - 成员内部类 <imgsrc="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/202204282107504.png" /></p><h3 id="静态内部类">静态内部类</h3><p>静态内部类是定义在外部类的成员位置，并且<strong>有</strong>static修饰。1.可以直接访问外部类的所有静态成员，包含私有的，但是不能直接访问非静态成员2. 可以添加任意访问修饰符(public, protected, default, private) 3.作用域：同其他成员，为整个类体 4. 静态内部类 - 访问 - 外部类【访问方式：直接访问所有静态成员】 5. 外部类 - 访问 - 静态内部类【访问方式：创建对象，再访问】 6. 外部其他类 - 访问 - 成员内部类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company.innerclass_;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticInnerClass</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer_</span>().m1();  <br>  <br>        <span class="hljs-comment">// 其他外部类使用静态内部类  </span><br>        <span class="hljs-comment">// 方式1 【直接类名访问】  </span><br>        Outer_.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer_</span>.Inner();  <br>        inner.say();  <br>  <br>        <span class="hljs-comment">// 方式2 【编写一个方法，返回静态内部类的对象实例】  </span><br>        <span class="hljs-type">Outer_</span> <span class="hljs-variable">outer_</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer_</span>();  <br>        Outer_.<span class="hljs-type">Inner</span> <span class="hljs-variable">inn</span> <span class="hljs-operator">=</span> outer_.getInner();  <br>        inn.say();  <br>  <br>        <span class="hljs-comment">// 方式3 【编写一个静态方法，返回静态内部类的对象实例】  </span><br>        Outer_.<span class="hljs-type">Inner</span> <span class="hljs-variable">innerInstance</span> <span class="hljs-operator">=</span> Outer_.getInnerInstance();  <br>        innerInstance.say();  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer_</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;张三&quot;</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;cry()...&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span> &#123;  <br>            System.out.println(name);  <br>            cry();  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();  <br>        inner.say();  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Inner <span class="hljs-title function_">getInnerInstance</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> Inner <span class="hljs-title function_">getInner</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure> 7.如果外部类和静态内部类的成员重名时，静态内部类访问的时候，遵循就近原则，如果想要访问外部类的成员，可以使用<code>外部类名.成员</code>去访问【注意没有this】</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电视盒子就该这样玩</title>
    <link href="/2022/02/13/20f92009ddc1.html"/>
    <url>/2022/02/13/20f92009ddc1.html</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面">写在前面</h2><p>假期在家闲来无事，折腾起了电视盒子。换不起电视机，还换不起电视盒子吗？受够电视龟速开机，直接恢复出厂设置，不再连接网络，仅仅充当盒子的输出显示，连开机广告也没了。不过那个安卓4.4.4的盒子实在是不能担当重任，也该让它退休了。</p><p>寻寻觅觅，发现国内各大厂商的电视盒子，也就当贝盒子良心点，可性价比确实不行。于是我的目光瞄向了外贸盒子，然后一发不可收。外贸盒子除了做工不咋样，对比前者简直就是性价比天花板，感情国人都是冤大头。除此之外，外贸盒子的可玩性自然不必多说。</p><p>说干就干，某鱼入手了HK1 box，到手刷机，体验纵享丝滑，直接退烧。</p><span id="more"></span><h2 id="外贸盒子">外贸盒子</h2><h3 id="hk1-box">HK1 box</h3><p>配置：芯片S905X3+4GB运行内存+32G机身存储+千兆网+双频wifi+光纤音频+USB3.0刷入ATV</p><p>【线刷】 工具： USB公对公线一条，牙签一根，电脑一台（烧录工具）</p><p>其他玩法：CoreELEC、Openwrt和emuELEC有时间再折腾吧。。</p><h2 id="移动魔百盒">移动魔百盒</h2><h3 id="创维-e900v22c">创维 E900V22C</h3><p>配置：2G + 8G、百兆网口、双频Wi-Fi、蓝牙5.0、USB2.0</p><p>【办宽带白送，还要啥自行车】破解后，刷入当贝桌面或乐家桌面，敏感肌也能用~~</p><h2 id="资源">资源</h2><ol type="1"><li><p>电视软件 <ahref="http://a1111.ysepan.com/">ysepan.com</a></p></li><li><p>刷机固件 https://slimboxtv.ru/hk1-box/</p></li><li><p><a href="https://www.bilibili.com/read/cv9065539">折腾记篇一：X96 Max+ 卡刷 SlimBOX，使用原生的ATV</a></p></li><li><p><ahref="https://www.bilibili.com/video/BV1uX4y1G7rP?spm_id_from=333.337.search-card.all.click">HK1Box刷机系列 第三方固件slimbox刷机教程及功能展示</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>瞎折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电视盒子</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法模板Part Three - 搜索与图论</title>
    <link href="/2021/11/19/c0087d7049a8.html"/>
    <url>/2021/11/19/c0087d7049a8.html</url>
    
    <content type="html"><![CDATA[<h2 id="树与图的存储">树与图的存储</h2><p>树是一种特殊的图，与图的存储方式相同。对于无向图中的边ab，存储两条有向边a<spanclass="math inline">\(\rightarrow\)</span>b, b<spanclass="math inline">\(\rightarrow\)</span>a。因此我们可以只考虑有向图的存储。</p><ol type="1"><li>邻接矩阵：g[a] [b] 存储边a<spanclass="math inline">\(\rightarrow\)</span>b</li><li>邻接表：<span id="more"></span></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span><br><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><br><span class="hljs-comment">// 添加一条边a-&gt;b</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 初始化</span><br>idx = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br></code></pre></td></tr></table></figure><h2 id="树与图的遍历">树与图的遍历</h2><p>时间复杂度 <span class="math inline">\(O(n+m)\)</span>, <spanclass="math inline">\(n\)</span>表示点数，<spanclass="math inline">\(m\)</span>表示边数 ### 深度优先遍历 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// st[u] 表示点u已经被遍历过</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j]) <span class="hljs-built_in">dfs</span>(j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>### 广度优先遍历 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++">queue&lt;<span class="hljs-type">int</span>&gt; q;<br>st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示1号点已经被遍历过</span><br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>&#123;<br>    <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j])<br>        &#123;<br>            st[j] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示点j已经被遍历过</span><br>            q.<span class="hljs-built_in">push</span>(j);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> ## 拓扑排序 时间复杂度 <spanclass="math inline">\(O(n+m)\)</span>, <spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-comment">// d[i] 存储点i的入度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">if</span> (!d[i])<br>            q[ ++ tt] = i;<br><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt)<br>    &#123;<br>        <span class="hljs-type">int</span> t = q[hh ++ ];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (-- d[j] == <span class="hljs-number">0</span>)<br>                q[ ++ tt] = j;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span><br>    <span class="hljs-keyword">return</span> tt == n - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="dijkstra">Dijkstra</h2><h3 id="朴素dijkstra">朴素dijkstra</h3><p>时间复杂是 <span class="math inline">\(O(n^2+m)\)</span>, <spanclass="math inline">\(n\)</span>表示点数，<spanclass="math inline">\(m\)</span> 表示边数 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> g[N][N];  <span class="hljs-comment">// 存储每条边</span><br><span class="hljs-type">int</span> dist[N];  <span class="hljs-comment">// 存储1号点到每个点的最短距离</span><br><span class="hljs-type">bool</span> st[N];   <span class="hljs-comment">// 存储每个点的最短路是否已经确定</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;     <span class="hljs-comment">// 在还未确定最短路的点中，寻找距离最小的点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br><br>        <span class="hljs-comment">// 用t更新其他点的距离</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br><br>        st[t] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure> ###堆优化版dijkstra 时间复杂度 <spanclass="math inline">\(O(m\log{n})\)</span>, <spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 点的数量</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// 存储所有点到1号点的距离</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点的最短距离是否已确定</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);      <span class="hljs-comment">// first存储距离，second存储节点编号</span><br><br>    <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-type">int</span> ver = t.second, distance = t.first;<br><br>        <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>;<br>        st[ver] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; distance + w[i])<br>            &#123;<br>                dist[j] = distance + w[i];<br>                heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure> ##Bellman-Ford算法 时间复杂度 <span class="math inline">\(O(nm)\)</span>,<span class="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;       <span class="hljs-comment">// n表示点数，m表示边数</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// dist[x]存储1到x的最短路距离</span><br><span class="hljs-comment">// 备份数组</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>     <span class="hljs-comment">// 边，a表示出点，b表示入点，w表示边的权重</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br>&#125;edges[M];<br><br><span class="hljs-comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;<br>            <span class="hljs-keyword">if</span> (dist[b] &gt; dist[a] + w)<br>                dist[b] = dist[a] + w;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="spfa-算法队列优化的bellman-ford算法">spfa算法（队列优化的Bellman-Ford算法）</h2><p>时间复杂度 平均情况下 <spanclass="math inline">\(O(m)\)</span>，最坏情况下 <spanclass="math inline">\(O(nm)\)</span>, <spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// 存储每个点到1号点的最短距离</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                <span class="hljs-keyword">if</span> (!st[j])     <span class="hljs-comment">// 如果队列中已存在j，则不需要将j重复插入</span><br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure> ##spfa判断图中是否存在负环 时间复杂度是 <spanclass="math inline">\(O(nm)\)</span>,<spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N], cnt[N];        <span class="hljs-comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 如果存在负环，则返回true，否则返回false。</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 不需要初始化dist数组</span><br>    <span class="hljs-comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span><br><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>        st[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;       <span class="hljs-comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span><br>                <span class="hljs-keyword">if</span> (!st[j])<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure> ## Floyd算法时间复杂度是 <span class="math inline">\(O(n^3)\)</span>, <spanclass="math inline">\(n\)</span> 表示点数 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++">初始化：<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (i == j) d[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> d[i][j] = INF;<br><br><span class="hljs-comment">// 算法结束后，d[a][b]表示a到b的最短距离</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<br>&#125;<br></code></pre></td></tr></table></figure> ##朴素版prim算法 时间复杂度是 <spanclass="math inline">\(O(n^2+m)\)</span>, <spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// n表示点数</span><br><span class="hljs-type">int</span> g[N][N];        <span class="hljs-comment">// 邻接矩阵，存储所有边</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// 存储其他点到当前最小生成树的距离</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否已经在生成树中</span><br><br><br><span class="hljs-comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br><br>        <span class="hljs-keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="hljs-keyword">return</span> INF;<br><br>        <span class="hljs-keyword">if</span> (i) res += dist[t];<br>        st[t] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="hljs-built_in">min</span>(dist[j], g[t][j]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure> ## Kruskal算法时间复杂度是 <span class="math inline">\(O(m\log {m})\)</span>, <spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, m;       <span class="hljs-comment">// n是点数，m是边数</span><br><span class="hljs-type">int</span> p[N];       <span class="hljs-comment">// 并查集的父节点数组</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>     <span class="hljs-comment">// 存储边</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> Edge &amp;W)<span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> w &lt; W.w;<br>    &#125;<br>&#125;edges[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>     <span class="hljs-comment">// 并查集核心操作</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sort</span>(edges, edges + m);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="hljs-comment">// 初始化并查集</span><br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;<br><br>        a = <span class="hljs-built_in">find</span>(a), b = <span class="hljs-built_in">find</span>(b);<br>        <span class="hljs-keyword">if</span> (a != b)     <span class="hljs-comment">// 如果两个连通块不连通，则将这两个连通块合并</span><br>        &#123;<br>            p[a] = b;<br>            res += w;<br>            cnt ++ ;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (cnt &lt; n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure> ##染色法判别二分图 时间复杂度是 <spanclass="math inline">\(O(n+m)\)</span>, <spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// n表示点数</span><br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;     <span class="hljs-comment">// 邻接表存储图</span><br><span class="hljs-type">int</span> color[N];       <span class="hljs-comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span><br><br><span class="hljs-comment">// 参数：u表示当前节点，c表示当前点的颜色</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    color[u] = c;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (color[j] == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(j, !c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (color[j] == c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(color, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> color);<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">if</span> (color[i] == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">0</span>))<br>            &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br></code></pre></td></tr></table></figure> ## 匈牙利算法时间复杂度是 <span class="math inline">\(O(nm)\)</span>, <spanclass="math inline">\(n\)</span> 表示点数，<spanclass="math inline">\(m\)</span> 表示边数 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> n1, n2;     <span class="hljs-comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span><br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;     <span class="hljs-comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span><br><span class="hljs-type">int</span> match[N];       <span class="hljs-comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 表示第二个集合中的每个点是否已经被遍历过</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[x]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j])<br>        &#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (match[j] == <span class="hljs-number">0</span> || <span class="hljs-built_in">find</span>(match[j]))<br>            &#123;<br>                match[j] = x;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span><br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i ++ )<br>&#123;<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(i)) res ++ ;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基本语法</title>
    <link href="/2021/11/16/7bf8ece318c3.html"/>
    <url>/2021/11/16/7bf8ece318c3.html</url>
    
    <content type="html"><![CDATA[<h2 id="基础类型">基础类型</h2><p>python中的主要基本数据类型是数字（<strong>整数</strong>和<strong>浮点数</strong>），<strong>布尔值</strong>和<strong>字符串</strong></p><h3 id="字符串操作">字符串操作</h3><ul><li>字符串可以被<code>'</code>, <code>"</code>,<code>'''</code>包裹</li><li>字符串是python的特殊类型。作为对象，在类中，可以使用<code>.methodName()</code>表示法调用字符串对象上的方法。字符串类在python中默认可用，因此不需要import语句即可将对象接口用于字符串。<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">firstVariable = <span class="hljs-string">&#x27;Hello World&#x27;</span><br>a = firstVariable.split(<span class="hljs-string">&#x27; &#x27;</span>)   <span class="hljs-comment"># [&#x27;Hello&#x27;, &#x27;World&#x27;]</span><br><span class="hljs-string">&#x27; &#x27;</span>.join(a) <span class="hljs-comment"># &#x27;Hello World&#x27;</span><br></code></pre></td></tr></table></figure></li><li>拼接字符串<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;0&quot;</span> * <span class="hljs-number">3</span>  <span class="hljs-comment"># &#x27;000&#x27;</span><br><span class="hljs-string">&quot;Fizz&quot;</span> + <span class="hljs-string">&quot;Buzz&quot;</span> <span class="hljs-comment"># &#x27;FizzBuzz&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="基础数学">基础数学</h3><ul><li>有四种不同的数字类型：普通整数，长整数，浮点数和复数。另外，布尔值是普通整数的子类型。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># integer division</span><br><span class="hljs-number">130</span>/<span class="hljs-number">2</span>  <span class="hljs-comment"># 65.0</span><br><br><span class="hljs-comment"># Exponentiation</span><br><span class="hljs-number">2</span> ** <span class="hljs-number">3</span> <span class="hljs-comment"># 8</span><br><br><span class="hljs-comment"># Modulo</span><br><span class="hljs-number">9</span> % <span class="hljs-number">3</span> <span class="hljs-comment"># 0</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="操作符">操作符</h3><table><thead><tr class="header"><th>比较操作符</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>&lt;</td><td>小于</td></tr><tr class="even"><td>&lt;=</td><td>小于或等于</td></tr><tr class="odd"><td>&gt;</td><td>大于</td></tr><tr class="even"><td>&gt;=</td><td>大于或等于</td></tr><tr class="odd"><td>==</td><td>等于</td></tr><tr class="even"><td>!=</td><td>不等于</td></tr></tbody></table><table><thead><tr class="header"><th>逻辑操作符</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>and</td><td>如果两个操作数均为True，则condition变为True.</td></tr><tr class="even"><td>or</td><td>如果两个操作数中的任何一个为True，则condition变为True.</td></tr><tr class="odd"><td>not</td><td>用于反转逻辑（不是False变为True，而不是True变为False</td></tr></tbody></table><h2 id="列表">列表</h2><p>列表后面要加上方括号 [ ] - 切片<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">z = [<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>]<br>z[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>] <span class="hljs-comment">#[3, 7]</span><br>z[:<span class="hljs-number">3</span>] <span class="hljs-comment"># [3, 7, 4]</span><br></code></pre></td></tr></table></figure> - 取列表的最大值, 最小值, 长度, 以及总和<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">min</span>(z), <span class="hljs-built_in">max</span>(z), <span class="hljs-built_in">len</span>(z), <span class="hljs-built_in">sum</span>(z)) <span class="hljs-comment"># 2 7 4 16</span><br></code></pre></td></tr></table></figure> - 对列表中对象出现次数进行统计 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">random_list = [<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>]<br>random_list.count(<span class="hljs-number">4</span>) <span class="hljs-comment"># 3</span><br></code></pre></td></tr></table></figure> -返回列表第一个指针 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">random_list.index(<span class="hljs-number">4</span>) <span class="hljs-comment"># 0</span><br>random_list.index(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>) <span class="hljs-comment"># 从索引3开始搜索第一个4的位置</span><br>random_list.index(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>) <span class="hljs-comment"># random_list.index(value, [start, stop])</span><br></code></pre></td></tr></table></figure> - 对列表进行排序 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">x = [<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">11</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>]<br>y = [<span class="hljs-string">&#x27;Steve&#x27;</span>, <span class="hljs-string">&#x27;Rachel&#x27;</span>, <span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-string">&#x27;Adam&#x27;</span>, <span class="hljs-string">&#x27;Monica&#x27;</span>, <span class="hljs-string">&#x27;Jessica&#x27;</span>, <span class="hljs-string">&#x27;Lester&#x27;</span>]<br><br><br>x.sort() <span class="hljs-comment"># low to high</span><br>x.sort(reverse = <span class="hljs-literal">True</span>) <span class="hljs-comment"># high to low</span><br><br>y.sort() <span class="hljs-comment"># 按字典序排序</span><br>new_list = sort(y) <span class="hljs-comment"># 不改变原列表</span><br></code></pre></td></tr></table></figure> -在列表结尾添加一个对象 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">x.append(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure> - 删除列表中一个对象 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">x.remove(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure>- 删除列表中指定位置的对象 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Remove item at the index</span><br><span class="hljs-comment"># this function will also return the item you removed from the list</span><br><span class="hljs-comment"># Default is the last index</span><br>x.pop(<span class="hljs-number">3</span>) <br></code></pre></td></tr></table></figure> - 合并列表通过在末尾续加的方式来延长列表 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x.extend([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br>x + y <span class="hljs-comment"># 列表里元素类型可以不同</span><br></code></pre></td></tr></table></figure> - 在列表指定位置前插入对象<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">x.insert(<span class="hljs-number">4</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]) <span class="hljs-comment"># [11, 10, 8, 4, [4, 5], 3, 2, 4, 5]</span><br></code></pre></td></tr></table></figure></p><h2 id="字典">字典</h2><p>字典是将键(key)映射到值(value)的无序数据结构。值可以是任何值（列表，函数，字符串，任何东西）。键(key)必须是不可变的，例如，数字，字符串或元组。<code>dict = &#123;'key1': 'value1', 'key2': 'value2'&#125;</code> -访问字典中的值 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">webstersDict =&#123;<span class="hljs-string">&#x27;person&#x27;</span>: <span class="hljs-string">&#x27;a human being, whether an adult or child&#x27;</span>,<br> <span class="hljs-string">&#x27;marathon&#x27;</span>: <span class="hljs-string">&#x27;a running race that is about 26 miles&#x27;</span>,<br> <span class="hljs-string">&#x27;resist&#x27;</span>: <span class="hljs-string">&#x27; to remain strong against the force or effect of (something)&#x27;</span>,<br> <span class="hljs-string">&#x27;run&#x27;</span>: <span class="hljs-string">&#x27;to move with haste; act quickly&#x27;</span>&#125;<br>webstersDict[<span class="hljs-string">&#x27;marathon&#x27;</span>]<br></code></pre></td></tr></table></figure> - 更新字典 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># add one new key value pair to dictionary</span><br>webstersDict[<span class="hljs-string">&#x27;shoe&#x27;</span>] = <span class="hljs-string">&#x27;an external covering for the human foot&#x27;</span><br><br><span class="hljs-comment"># update method, update or add more than key value pair at a time</span><br>webstersDict.update(&#123;<span class="hljs-string">&#x27;shirt&#x27;</span>: <span class="hljs-string">&#x27;a long- or short-sleeved garment for the upper part of the body&#x27;</span>, <span class="hljs-string">&#x27;shoe&#x27;</span>: <span class="hljs-string">&#x27;an external covering for the human foot, usually of leather and consisting of a more or less stiff or heavy sole and a lighter upper part ending a short distance above, at, or below the ankle.&#x27;</span>&#125;)<br><br><span class="hljs-comment"># Removing key from dictionary</span><br><span class="hljs-keyword">del</span> webstersDict[<span class="hljs-string">&#x27;resist&#x27;</span>]<br>webstersDict<br></code></pre></td></tr></table></figure> -不是所有东西都可以当作Key - 使用 <code>get()</code> 方法返回给定键的值<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">storyCount = &#123;<span class="hljs-string">&#x27;is&#x27;</span>: <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;the&#x27;</span>: <span class="hljs-number">90</span>, <span class="hljs-string">&#x27;Michael&#x27;</span>: <span class="hljs-number">12</span>, <span class="hljs-string">&#x27;runs&#x27;</span>: <span class="hljs-number">5</span>&#125;<br>storyCout[<span class="hljs-string">&#x27;run&#x27;</span>] <span class="hljs-comment"># 报错</span><br>storyCout.get(<span class="hljs-string">&#x27;run&#x27;</span>) <span class="hljs-comment"># None</span><br>storyCout.get(<span class="hljs-string">&#x27;run&#x27;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment"># 若不存在，则返回默认值0</span><br></code></pre></td></tr></table></figure> - 删除键，但同时可以返回值 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">count = storyCount.pop(<span class="hljs-string">&#x27;the&#x27;</span>)<br></code></pre></td></tr></table></figure> - 遍历字典<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># return keys in dictionary</span><br><span class="hljs-built_in">print</span>(storyCount.keys())<br><br><span class="hljs-comment"># return values in dictionary</span><br><span class="hljs-built_in">print</span>(storyCount.values())<br></code></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># iterate through keys</span><br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> storyCount: <br>    <span class="hljs-built_in">print</span>(key)<br><br><span class="hljs-comment"># iterate through keys and values</span><br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> webstersDict.items():<br>    <span class="hljs-built_in">print</span>(key, value)<br></code></pre></td></tr></table></figure><h2 id="元组">元组</h2><p>元组是一种序列，就像列表一样。元组和列表之间的区别在于，与列表（可变）不同，元组不能更改（不可变）。元组使用括号，而列表使用方括号。 - 初始化一个元组 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">emptyTuple = ()<br>emptyTuple = <span class="hljs-built_in">tuple</span>()<br><br><span class="hljs-comment"># 可以通过用逗号分隔值的序列来初始化具有值的元组。</span><br>z = (<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>)<br>z = <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>  <span class="hljs-comment"># 也可以不要括号</span><br><br><span class="hljs-comment"># 要创建仅包含一个值的元组，则需要在项目后面添加一个逗号！</span><br>tup1 = (<span class="hljs-string">&#x27;Michael&#x27;</span>,)<br>tup2 = <span class="hljs-string">&#x27;Michael&#x27;</span>,<br>notTuple = (<span class="hljs-string">&#x27;Michael&#x27;</span>)  <span class="hljs-comment"># This is a string, NOT a tuple.</span><br></code></pre></td></tr></table></figure> -访问元组内的值 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">z[<span class="hljs-number">0</span>]<br>z[-<span class="hljs-number">1</span>] <span class="hljs-comment"># 负索引</span><br></code></pre></td></tr></table></figure> - 切分元组 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Initialize a tuple</span><br>z = (<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># first index is inclusive (before the :) and last (after the :) is not.</span><br><span class="hljs-built_in">print</span>(z[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>])<br><span class="hljs-built_in">print</span>(z[:<span class="hljs-number">3</span>])<br><span class="hljs-built_in">print</span>(z[-<span class="hljs-number">4</span>:-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure> -元组是不可改变的，不过可以采用现有元组的一部分来创建新的元组<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Initialize tuple</span><br>tup1 = (<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;SQL&#x27;</span>)<br><br><span class="hljs-comment"># Initialize another Tuple</span><br>tup2 = (<span class="hljs-string">&#x27;R&#x27;</span>,)<br><br><span class="hljs-comment"># Create new tuple based on existing tuples</span><br>new_tuple = tup1 + tup2;<br><span class="hljs-built_in">print</span>(new_tuple)<br></code></pre></td></tr></table></figure></p><h3 id="tuple-方法">Tuple 方法</h3><ul><li>index 方法(索引) <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Initialize a tuple</span><br>animals = (<span class="hljs-string">&#x27;lama&#x27;</span>, <span class="hljs-string">&#x27;sheep&#x27;</span>, <span class="hljs-string">&#x27;lama&#x27;</span>, <span class="hljs-number">48</span>)<br><br><span class="hljs-built_in">print</span>(animals.index(<span class="hljs-string">&#x27;lama&#x27;</span>))<br></code></pre></td></tr></table></figure></li><li>count 方法(计数) <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(animals.count(<span class="hljs-string">&#x27;lama&#x27;</span>))<br></code></pre></td></tr></table></figure></li><li>遍历元组 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;lama&#x27;</span>, <span class="hljs-string">&#x27;sheep&#x27;</span>, <span class="hljs-string">&#x27;lama&#x27;</span>, <span class="hljs-number">48</span>):<br>    <span class="hljs-built_in">print</span>(item)<br></code></pre></td></tr></table></figure></li><li>元组拆包 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 元组对序列解包非常有用</span><br>x, y = (<span class="hljs-number">7</span>, <span class="hljs-number">10</span>);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Value of x is &#123;&#125;, the value of y is &#123;&#125;.&quot;</span>.<span class="hljs-built_in">format</span>(x, y))<br><span class="hljs-comment"># Value of x is 7, the value of y is 10.</span><br></code></pre></td></tr></table></figure></li><li>枚举 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 枚举函数返回一个元组，其中包含每次迭代的计数（从默认为0的开始）和迭代序列获得的值</span><br>friends = (<span class="hljs-string">&#x27;Steve&#x27;</span>, <span class="hljs-string">&#x27;Rachel&#x27;</span>, <span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-string">&#x27;Monica&#x27;</span>)<br><span class="hljs-keyword">for</span> index, friend <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(friends):<br><br>    <span class="hljs-built_in">print</span>(index,friend)<br></code></pre></td></tr></table></figure></li></ul><h3 id="元组相对列表的优势">元组相对列表的优势</h3><ul><li>元组比列表更快。如果要定义一组常量值，迭代它，使用元组而不是列表。</li><li>元组可以作为字典键，列表不可以用作字典键 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">bigramsTupleDict = &#123;(<span class="hljs-string">&#x27;this&#x27;</span>, <span class="hljs-string">&#x27;is&#x27;</span>): <span class="hljs-number">23</span>,<br>                    (<span class="hljs-string">&#x27;is&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>): <span class="hljs-number">12</span>,<br>                    (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;sentence&#x27;</span>): <span class="hljs-number">2</span>&#125;<br>  <br><span class="hljs-built_in">print</span>(bigramsTupleDict)<br></code></pre></td></tr></table></figure></li><li>元组可以是集合中的值，列表不可以是集合中的值 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">graphicDesigner = &#123;(<span class="hljs-string">&#x27;this&#x27;</span>, <span class="hljs-string">&#x27;is&#x27;</span>),<br>                   (<span class="hljs-string">&#x27;is&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>),<br>                   (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;sentence&#x27;</span>)&#125;<br><br><span class="hljs-built_in">print</span>(graphicDesigner)<br></code></pre></td></tr></table></figure> ###生成斐波那契序列 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打印出前10个Fibonacci数</span><br>a,b = <span class="hljs-number">1</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Fib(a): &quot;</span>, a, <span class="hljs-string">&quot;b is: &quot;</span>, b)<br>    a,b = b,a+b<br></code></pre></td></tr></table></figure></li></ul><h2 id="for-循环">for 循环</h2><p>Task: <strong>从文本中删除标点符号并将最终产品转换为列表:</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">text = <span class="hljs-string">&#x27;&#x27;&#x27;On a dark desert highway, cool wind in my hair Warm smell of colitas, rising up through the air Up ahead in the distance, I saw a shimmering light My head grew heavy and my sight grew dim I had to stop for the night There she stood in the doorway; I heard the mission bell And I was thinking to myself, &quot;This could be Heaven or this could be Hell&quot; Then she lit up a candle and she showed me the way&#x27;&#x27;&#x27;</span><br><br><span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;-.,;\n&quot;\&#x27;&#x27;</span>:<br>text = text.replance(char, <span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-comment"># Split converts string to list.</span><br>text.split(<span class="hljs-string">&#x27; &#x27;</span>)[<span class="hljs-number">0</span>:<span class="hljs-number">20</span>]  <span class="hljs-comment"># 取前20个</span><br><br>cleaned_list = []<br><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> text.split(<span class="hljs-string">&#x27; &#x27;</span>): <br>    word_length = <span class="hljs-built_in">len</span>(word)<br>    <span class="hljs-keyword">if</span> word_length &gt; <span class="hljs-number">0</span>:<br>        cleaned_list.append(word)<br></code></pre></td></tr></table></figure> ### range 函数 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Making empty lists to append even and odd numbers to. </span><br>even_numbers = []<br>odd_numbers = []<br><br><span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">51</span>):<br>    <span class="hljs-keyword">if</span> number % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        even_numbers.append(number)<br>    <span class="hljs-keyword">else</span>: <br>        odd_numbers.append(number)<br></code></pre></td></tr></table></figure> ## 函数 ### 创建函数的语法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">function_name</span>(<span class="hljs-params">parameters</span>): <br>    <span class="hljs-string">&quot;&quot;&quot;docstring&quot;&quot;&quot;</span><br>    statement(s)<br></code></pre></td></tr></table></figure> 上面显示的是一个函数定义，它由以下组件组成。 1.关键字def标记函数头的开始。 2.用于唯一标识它的函数名称。函数命名遵循在Python中编写标识符的相同规则。3. 参数（参数），我们通过它将值传递给函数。它们是可选的。 4.冒号（:)标记函数头的结尾。 5.用于描述函数功能的可选文档字符串（docstring）。 6.构成函数体的一个或多个有效的python语句。语句必须具有相同的缩进级别（通常为4个空格）。7. 用于从函数返回值的可选return语句。</p><h3 id="返回语句">返回语句</h3><p>return语句用于退出函数并返回到调用函数的位置。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">return</span> [expression_list]<br></code></pre></td></tr></table></figure>此语句可以包含要求求值的表达式，并返回值。如果语句中没有表达式，或者函数内部不存在return语句本身，则该函数将返回None对象。### 变量函数参数 - 默认参数但是一旦我们有一个默认参数，它右边的所有参数也必须有默认值。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name, msg = <span class="hljs-string">&quot;Good morning!&quot;</span></span>):<br>   <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">   This function greets to</span><br><span class="hljs-string">   the person with the</span><br><span class="hljs-string">   provided message.</span><br><span class="hljs-string">  </span><br><span class="hljs-string">   If message is not provided,</span><br><span class="hljs-string">   it defaults to &quot;Good</span><br><span class="hljs-string">   morning!&quot;</span><br><span class="hljs-string">   &quot;&quot;&quot;</span><br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello&quot;</span>,name + <span class="hljs-string">&#x27;, &#x27;</span> + msg)<br><br>greet(<span class="hljs-string">&quot;Kate&quot;</span>)<br>greet(<span class="hljs-string">&quot;Bruce&quot;</span>,<span class="hljs-string">&quot;How do you do?&quot;</span>)<br></code></pre></td></tr></table></figure> - 关键字参数在函数调用期间将位置参数与关键字参数混合使用。但必须记住，关键字参数必须遵循位置参数。在关键字参数之后使用位置参数将导致错误。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># greet(msg = &quot;How do you do?&quot;, &quot;Bruce&quot;)</span><br>greet(<span class="hljs-string">&quot;Bruce&quot;</span>,msg = <span class="hljs-string">&quot;How do you do?&quot;</span>)<br></code></pre></td></tr></table></figure> - 任意参数事先并不知道将传递给函数的参数数量。Python允许我们通过具有任意数量参数的函数调用来处理这种情况。这些参数在传递给函数之前被包装到<strong>元组</strong>中。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">*names</span>):<br>   <span class="hljs-string">&quot;&quot;&quot;This function greets all</span><br><span class="hljs-string">   the person in the names tuple.&quot;&quot;&quot;</span><br><br>   <span class="hljs-comment"># names is a tuple with arguments</span><br>   <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names:<br>       <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello&quot;</span>,name)<br><br>greet(<span class="hljs-string">&quot;Monica&quot;</span>,<span class="hljs-string">&quot;Luke&quot;</span>,<span class="hljs-string">&quot;Steve&quot;</span>,<span class="hljs-string">&quot;John&quot;</span>)<br></code></pre></td></tr></table></figure> ### 在列表中移除重复元素 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">remove_duplicates</span>(<span class="hljs-params">duplicate</span>): <br>    uniques = [] <br>    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> duplicate: <br>        <span class="hljs-keyword">if</span> num <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> uniques: <br>            uniques.append(num) <br>    <span class="hljs-keyword">return</span>(uniques)<br><br>duplicate = [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">20</span>, <span class="hljs-number">4</span>] <br><span class="hljs-built_in">print</span>(remove_duplicates(duplicate))<br></code></pre></td></tr></table></figure></p><h2 id="python面向对象编程">Python面向对象编程</h2><p>面向对象编程（Object-orientedProgramming，简称OOP）是一种编程范例，它提供了一种结构化程序的方法，以便将属性和行为捆绑到单个对象中。### Python中的类 一个类只提供结构 -它是应该如何定义某个东西的蓝图，但它实际上并不提供任何真实的内容。可以将"类"视为"某事物的定义"，每个事物或对象都是某个类的实例。### Python对象（实例）在创建对象的单个实例之前，我们必须首先通过定义类来指定所需的内容。 ###定义和使用方法 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>: <br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>使用class关键字指示正在创建一个类，然后添加该类的名称（使用骆驼命名法，以大写字母开头。）</p><h4 id="实例属性">实例属性</h4><p>所有类都需要创建对象，所有对象都包含称为属性的特征。使用<code>__init __</code>方法通过为对象的初始属性提供其默认值（或状态）来初始化（例如，指定）对象的初始属性。此方法必须至少有一个参数以及自变量，它引用对象本身（例如，Dog）。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>: <br>    <span class="hljs-comment"># Initializer / Instance Attributes </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>): <br>        self.name = name <br>        self.age = age<br></code></pre></td></tr></table></figure></p><blockquote><p>创建一个新的实例时<code>__init__</code>会被自动调用。</p></blockquote><h4 id="类属性">类属性</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>: <br><span class="hljs-comment"># Class Attribute</span><br>species = <span class="hljs-string">&#x27;mammal&#x27;</span><br><br><span class="hljs-comment"># Initializer / Instance Attributes </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>): <br>self.name = name <br>self.age = age<br></code></pre></td></tr></table></figure><h4 id="实例化对象">实例化对象</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>Dog() <br><span class="hljs-meta">&gt;&gt;&gt; </span>&lt;__main__.Dog <span class="hljs-built_in">object</span> at <span class="hljs-number">0x1004ccc50</span>&gt; <br><span class="hljs-meta">&gt;&gt;&gt; </span>Dog() <br><span class="hljs-meta">&gt;&gt;&gt; </span>&lt;__main__.Dog <span class="hljs-built_in">object</span> at <span class="hljs-number">0x1004ccc90</span>&gt; <br><br><span class="hljs-meta">&gt;&gt;&gt; </span>a = Dog() <br><span class="hljs-meta">&gt;&gt;&gt; </span>b = Dog()<br><span class="hljs-meta">&gt;&gt;&gt; </span>a == b <br><span class="hljs-literal">False</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(a)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Dog&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>:<br>    <span class="hljs-comment"># Class Attribute</span><br>    species = <span class="hljs-string">&#x27;mammal&#x27;</span><br>    <span class="hljs-comment"># Initializer / Instance Attributes</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br><br><span class="hljs-comment"># Instantiate the Dog object</span><br>philo = Dog(<span class="hljs-string">&quot;Philo&quot;</span>, <span class="hljs-number">5</span>)<br>mikey = Dog(<span class="hljs-string">&quot;Mikey&quot;</span>, <span class="hljs-number">6</span>)<br>  <br><span class="hljs-comment"># Access the instance attributes</span><br><span class="hljs-comment"># 使用点表示法来访问每个对象的属性</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125; is &#123;&#125; and &#123;&#125; is &#123;&#125;.&quot;</span>.<span class="hljs-built_in">format</span>( <br>             philo.name, philo.age, mikey.name, mikey.age))<br><br><span class="hljs-comment"># Is Philo a mammal?</span><br><span class="hljs-keyword">if</span> philo.species == <span class="hljs-string">&quot;mammal&quot;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;0&#125; is a &#123;1&#125;!&quot;</span>.<span class="hljs-built_in">format</span>(philo.name, philo.species))<br></code></pre></td></tr></table></figure><h4 id="实例方法">实例方法</h4><p>实例方法在类中定义，用于获取实例的内容。它们还可用于使用对象的属性执行操作。与<code>__init__</code>方法一样，第一个参数始终是<code>self</code>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>:<br>    <span class="hljs-comment"># Class Attribute</span><br>    species = <span class="hljs-string">&#x27;mammal&#x27;</span><br><br>    <span class="hljs-comment"># Initializer / Instance Attributes</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br>    <br>    <span class="hljs-comment"># instance method</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">description</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#125; is &#123;&#125; years old&quot;</span>.<span class="hljs-built_in">format</span>(self.name, self.age)<br><br>    <span class="hljs-comment"># instance method</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self, sound</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#125; says &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(self.name, sound)<br><br><span class="hljs-comment"># Instantiate the Dog object</span><br>mikey = Dog(<span class="hljs-string">&quot;Mikey&quot;</span>, <span class="hljs-number">6</span>)<br><br><span class="hljs-comment"># call our instance methods</span><br><span class="hljs-built_in">print</span>(mikey.description())<br><span class="hljs-built_in">print</span>(mikey.speak(<span class="hljs-string">&quot;Gruff Gruff&quot;</span>))<br></code></pre></td></tr></table></figure> - 修改属性 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Email</span>: <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>): <br>self.is_sent = <span class="hljs-literal">False</span> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_email</span>(<span class="hljs-params">self</span>): <br>self.is_sent = <span class="hljs-literal">True</span> <br><br>my_email = Email() <br><span class="hljs-built_in">print</span>(my_email.is_sent) <br><br>my_email.send_email() <br><span class="hljs-built_in">print</span>(my_email.is_sent)<br></code></pre></td></tr></table></figure></p><h3 id="python对象继承">Python对象继承</h3><p>继承是一个类采用另一个类的属性和方法的过程。新形成的类称为子类，子类派生的类称为父类。重要的是要注意子类<strong>覆盖</strong>或<strong>扩展</strong>父类的功能（例如，属性和行为）。换句话说，子类继承了父项的所有属性和行为，但也可以添加不同行为。最基本的类是一个对象，通常所有其他类都继承为它们的父对象。定义新类时，Python 3隐式使用object作为父类。所以以下两个定义是等价的：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">object</span>): <br><span class="hljs-keyword">pass</span> <br><br><span class="hljs-comment"># In Python 3, this is the same as: </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>: <br><span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure></p><ul><li><p>扩展父类功能 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Child class (inherits from Dog class)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RussellTerrier</span>(<span class="hljs-title class_ inherited__">Dog</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, speed</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#125; runs &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(self.name, speed) <br><br><span class="hljs-comment"># Child class (inherits from Dog class)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bulldog</span>(<span class="hljs-title class_ inherited__">Dog</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, speed</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#125; runs &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(self.name, speed)<br><br><span class="hljs-comment"># Child classes inherit attributes and</span><br><span class="hljs-comment"># behaviors from the parent class</span><br>jim = Bulldog(<span class="hljs-string">&quot;Jim&quot;</span>, <span class="hljs-number">12</span>)<br><span class="hljs-built_in">print</span>(jim.description())   <span class="hljs-comment"># Jim is 12 years old</span><br><br><span class="hljs-comment"># Child classes have specific attributes</span><br><span class="hljs-comment"># and behaviors as well</span><br><span class="hljs-built_in">print</span>(jim.run(<span class="hljs-string">&quot;slowly&quot;</span>))  <span class="hljs-comment"># Jim runs slowly</span><br></code></pre></td></tr></table></figure></p></li><li><p>覆盖父类功能<code>isinstance()</code>函数用于确定实例是否也是某个父类的实例。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>: <br>species = <span class="hljs-string">&#x27;mammal&#x27;</span> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeBreed</span>(<span class="hljs-title class_ inherited__">Dog</span>): <br><span class="hljs-keyword">pass</span> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeOtherBreed</span>(<span class="hljs-title class_ inherited__">Dog</span>): <br>species = <span class="hljs-string">&#x27;reptile&#x27;</span> <br><br>frank = SomeBreed() <br><span class="hljs-built_in">print</span>(frank.species) <span class="hljs-comment"># mammal</span><br><br>beans = SomeOtherBreed() <br><span class="hljs-built_in">print</span>(beans.species) <span class="hljs-comment"># reptile</span><br></code></pre></td></tr></table></figure></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习笔记</title>
    <link href="/2021/11/14/076c0a205bdd.html"/>
    <url>/2021/11/14/076c0a205bdd.html</url>
    
    <content type="html"><![CDATA[<h1 id="主要命令">主要命令</h1><ol type="1"><li><p>提交 <code>git commit</code></p></li><li><p>创建新分支 <code>git branch xx</code><code>git checkout xx</code> <code>git checkout -b xx</code></p></li><li><p>合并分支 <code>git merge xx</code></p></li><li><p>线性合并分支 <code>git rebase xx</code></p></li></ol><h1 id="相对引用">相对引用</h1><ol type="1"><li><p>分离Head <code>git checkout C4</code></p></li><li><p>相对引用 <code>git checkout main^</code><code>main~&lt;num&gt;</code></p></li><li><p>强制修改分支位置 <code>git branch -f main HEAD~3</code> 将 main分支强制指向 HEAD 的第 3 级父提交</p></li><li><p>撤销变更 <code>git reset xx</code><code>git revert xx</code></p></li></ol><h1 id="移动提交记录">移动提交记录</h1><ol type="1"><li><p>将一些提交（除HEAD上游）)复制到当前所在的位置（HEAD）下面的话<code>git cherry-pick &lt;提交号&gt; ...</code></p></li><li><p>交互式的rebase，将提交重新排序以及删除<code>git rebase -i HEAD~4</code></p></li></ol><h1 id="杂项">杂项</h1><ol type="1"><li><p>本地栈式提交 <code>git rebase -i</code><code>git cherry-pick C3 C4 C2 ...</code></p></li><li><p>对提交做一些小修改 <code>git commit --amend</code></p></li><li><p>永远指向某个提交记录的标签（锚点）<code>git tag v1 &lt;哈希值&gt;</code>省略则指向<code>HEAD</code>所指向的位置</p></li><li><p>描述离当前位置最近的锚点<code>git describe &lt;ref&gt;</code></p></li><li><p>查找产生Bug的提交记录的指令 <code>git bisect</code></p></li></ol><h1 id="高级话题">高级话题</h1><ol type="1"><li><p>多分支 rebase <code>git rebase xx yy</code></p></li><li><p>选择父提交记录 <code>git check HEAD^&lt;num&gt;</code>支持链式操作 <code>git branch bugWork HEAD~^2~2</code></p></li></ol><h1 id="git-远程仓库">Git 远程仓库</h1><ol type="1"><li><p>在本地克隆远程仓库 <code>git clone</code></p></li><li><p>远程分支 origin/main特性自动进入分离HEAD状态<code>git checkout o/main</code></p></li><li><p>从远程仓库获取数据，将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态，但不会更新main分支<code>git fetch</code> <code>http://</code> <code>git://</code></p></li><li><p>将变化更新到本地的工作中（先抓取更新再合并到本地分支）<code>git pull</code> 或者<code>git fetch; git merge o/main</code></p></li><li><p>将本地变更上传到指定的远程仓库，并在远程仓库上合并新提交记录<code>git push</code></p></li><li><p>在远程仓库变更了以后更新我们的工作<code>git fetch; git rebase o/main; git push</code> 或者<code>git fetch; git merge o/main; git push</code> 或者<code>git pull --rebase; git push</code></p></li><li><p>远程服务器拒绝，策略配置要求 pull requests来提交更新，需要新建一个分支, 推送(push)这个分支并申请pullrequest，推送到远程服务器.然后reset你的main分支和远程服务器保持一致，否则下次你pull并且他人的提交和你冲突的时候就会有问题。</p></li></ol><h1 id="git-远程仓库高级操作">Git 远程仓库高级操作</h1><ol type="1"><li>合并特性分支</li></ol><p>TBC...</p><h1 id="参考">参考</h1><ul><li>https://learngitbranching.js.org/</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法模板Part Two - 数据结构</title>
    <link href="/2021/11/12/40cf75a726af.html"/>
    <url>/2021/11/12/40cf75a726af.html</url>
    
    <content type="html"><![CDATA[<h2 id="单链表">单链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span><br><span class="hljs-type">int</span> head, e[N], ne[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = <span class="hljs-number">-1</span>;<br>    idx = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 在链表头插入一个数a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = a, ne[idx] = head, head = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 将头结点删除，需要保证头结点存在</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = ne[head];<br>&#125;<br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="双链表">双链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span><br><span class="hljs-type">int</span> e[N], l[N], r[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//0是左端点，1是右端点</span><br>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    idx = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// 在节点a的右边插入一个数x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br>    l[idx] = a, r[idx] = r[a];<br>    l[r[a]] = idx, r[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 删除节点a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    l[r[a]] = l[a];<br>    r[l[a]] = r[a];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="栈">栈</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// tt表示栈顶</span><br><span class="hljs-type">int</span> stk[N], tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 向栈顶插入一个数</span><br>stk[ ++ tt] = x;<br><br><span class="hljs-comment">// 从栈顶弹出一个数</span><br>tt -- ;<br><br><span class="hljs-comment">// 栈顶的值</span><br>stk[tt];<br><br><span class="hljs-comment">// 判断栈是否为空</span><br><span class="hljs-keyword">if</span> (tt &gt; <span class="hljs-number">0</span>)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="队列">队列</h2><h3 id="普通队列">普通队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// hh 表示队头，tt表示队尾</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[ ++ tt] = x;<br><br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh ++ ;<br><br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><br><span class="hljs-comment">// 判断队列是否为空</span><br><span class="hljs-keyword">if</span> (hh &lt;= tt)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环队列">循环队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// hh 表示队头，tt表示队尾的后一个位置</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[tt ++ ] = x;<br><span class="hljs-keyword">if</span> (tt == N) tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh ++ ;<br><span class="hljs-keyword">if</span> (hh == N) hh = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><br><span class="hljs-comment">// 判断队列是否为空</span><br><span class="hljs-keyword">if</span> (hh != tt)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调栈">单调栈</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">常见模型：找出每个数左边离它最近的比它大/小的数<br><span class="hljs-type">int</span> tt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (tt &amp;&amp; <span class="hljs-built_in">check</span>(stk[tt], i)) tt -- ;<br>    stk[ ++ tt] = i;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列">单调队列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">常见模型：找出滑动窗口中的最大值/最小值<br><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="hljs-built_in">check_out</span>(q[hh])) hh ++ ;  <span class="hljs-comment">// 判断队头是否滑出窗口</span><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="hljs-built_in">check</span>(q[tt], i)) tt -- ;<br>    q[ ++ tt] = i;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="kmp">KMP</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span><br>求模式串的Next数组：<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>    ne[i] = j;<br>&#125;<br><br><span class="hljs-comment">// 匹配</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>    <span class="hljs-keyword">if</span> (j == m)<br>    &#123;<br>        j = ne[j];<br>        <span class="hljs-comment">// 匹配成功后的逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="trie树">Trie树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> son[N][<span class="hljs-number">26</span>], cnt[N], idx;<br><span class="hljs-comment">// 0号点既是根节点，又是空节点</span><br><span class="hljs-comment">// son[][]存储树中每个节点的子节点</span><br><span class="hljs-comment">// cnt[]存储以每个节点结尾的单词数量</span><br><br><span class="hljs-comment">// 插入一个字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;<br>        p = son[p][u];<br>    &#125;<br>    cnt[p] ++ ;<br>&#125;<br><br><span class="hljs-comment">// 查询字符串出现的次数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = son[p][u];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="并查集">并查集</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C++">(<span class="hljs-number">1</span>)朴素并查集：<br><br>    <span class="hljs-type">int</span> p[N]; <span class="hljs-comment">//存储每个点的祖宗节点</span><br><br>    <span class="hljs-comment">// 返回x的祖宗节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;<br><br>    <span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>    p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br><br><br>(<span class="hljs-number">2</span>)维护size的并查集：<br><br>    <span class="hljs-type">int</span> p[N], size[N];<br>    <span class="hljs-comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span><br><br>    <span class="hljs-comment">// 返回x的祖宗节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        p[i] = i;<br>        size[i] = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>    size[<span class="hljs-built_in">find</span>(b)] += size[<span class="hljs-built_in">find</span>(a)];<br>    p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br><br><br>(<span class="hljs-number">3</span>)维护到祖宗节点距离的并查集：<br><br>    <span class="hljs-type">int</span> p[N], d[N];<br>    <span class="hljs-comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span><br><br>    <span class="hljs-comment">// 返回x的祖宗节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (p[x] != x)<br>        &#123;<br>            <span class="hljs-type">int</span> u = <span class="hljs-built_in">find</span>(p[x]);<br>            d[x] += d[p[x]];<br>            p[x] = u;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        p[i] = i;<br>        d[i] = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>    p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br>    d[<span class="hljs-built_in">find</span>(a)] = distance; <span class="hljs-comment">// 根据具体问题，初始化find(a)的偏移量</span><br></code></pre></td></tr></table></figure><h2 id="堆">堆</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span><br><span class="hljs-comment">// ph[k]存储第k个插入的点在堆中的位置</span><br><span class="hljs-comment">// hp[k]存储堆中下标是k的点是第几个插入的</span><br><span class="hljs-type">int</span> h[N], ph[N], hp[N], size;<br><br><span class="hljs-comment">// 交换两个点，及其映射关系</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">swap</span>(ph[hp[a]],ph[hp[b]]);<br>    <span class="hljs-built_in">swap</span>(hp[a], hp[b]);<br>    <span class="hljs-built_in">swap</span>(h[a], h[b]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = u;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (u != t)<br>    &#123;<br>        <span class="hljs-built_in">heap_swap</span>(u, t);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="hljs-number">2</span>])<br>    &#123;<br>        <span class="hljs-built_in">heap_swap</span>(u, u / <span class="hljs-number">2</span>);<br>        u &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// O(n)建堆</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i; i -- ) <span class="hljs-built_in">down</span>(i);<br></code></pre></td></tr></table></figure><h2 id="一般哈希">一般哈希</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++">(<span class="hljs-number">1</span>) 拉链法<br>    <span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><br>    <span class="hljs-comment">// 向哈希表中插入一个数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> k = (x % N + N) % N;<br>        e[idx] = x;<br>        ne[idx] = h[k];<br>        h[k] = idx ++ ;<br>    &#125;<br><br>    <span class="hljs-comment">// 在哈希表中查询某个数是否存在</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> k = (x % N + N) % N;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[k]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>            <span class="hljs-keyword">if</span> (e[i] == x)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>(<span class="hljs-number">2</span>) 开放寻址法<br>    <span class="hljs-type">int</span> h[N];<br><br>    <span class="hljs-comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> t = (x % N + N) % N;<br>        <span class="hljs-keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)<br>        &#123;<br>            t ++ ;<br>            <span class="hljs-keyword">if</span> (t == N) t = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="字符串哈希">字符串哈希</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++">核心思想：将字符串看成P进制数，P的经验值是<span class="hljs-number">131</span>或<span class="hljs-number">13331</span>，取这两个值的冲突概率低<br>小技巧：取模的数用<span class="hljs-number">2</span>^<span class="hljs-number">64</span>，这样直接用<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>存储，溢出的结果就是取模的结果<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br>ULL h[N], p[N]; <span class="hljs-comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span><br><br><span class="hljs-comment">// 初始化</span><br>p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i];<br>    p[i] = p[i - <span class="hljs-number">1</span>] * P;<br>&#125;<br><br><span class="hljs-comment">// 计算子串 str[l ~ r] 的哈希值</span><br><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="c-stl简介">C++ STL简介</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector, 变长数组，倍增的思想<br>    <span class="hljs-built_in">size</span>()  返回元素个数<br>    <span class="hljs-built_in">empty</span>()  返回是否为空<br>    <span class="hljs-built_in">clear</span>()  清空<br>    <span class="hljs-built_in">front</span>()/<span class="hljs-built_in">back</span>()<br>    <span class="hljs-built_in">push_back</span>()/<span class="hljs-built_in">pop_back</span>()<br>    <span class="hljs-built_in">begin</span>()/<span class="hljs-built_in">end</span>()<br>    []<br>    支持比较运算，按字典序<br><br>pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;<br>    first, 第一个元素<br>    second, 第二个元素<br>    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）<br><br>string，字符串<br>    <span class="hljs-built_in">size</span>()/<span class="hljs-built_in">length</span>()  返回字符串长度<br>    <span class="hljs-built_in">empty</span>()<br>    <span class="hljs-built_in">clear</span>()<br>    <span class="hljs-built_in">substr</span>(起始下标，(子串长度))  返回子串<br>    <span class="hljs-built_in">c_str</span>()  返回字符串所在字符数组的起始地址<br><br>queue, 队列<br>    <span class="hljs-built_in">size</span>()<br>    <span class="hljs-built_in">empty</span>()<br>    <span class="hljs-built_in">push</span>()  向队尾插入一个元素<br>    <span class="hljs-built_in">front</span>()  返回队头元素<br>    <span class="hljs-built_in">back</span>()  返回队尾元素<br>    <span class="hljs-built_in">pop</span>()  弹出队头元素<br><br>priority_queue, 优先队列，默认是大根堆<br>    <span class="hljs-built_in">size</span>()<br>    <span class="hljs-built_in">empty</span>()<br>    <span class="hljs-built_in">push</span>()  插入一个元素<br>    <span class="hljs-built_in">top</span>()  返回堆顶元素<br>    <span class="hljs-built_in">pop</span>()  弹出堆顶元素<br>    定义成小根堆的方式：priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; q;<br><br>stack, 栈<br>    <span class="hljs-built_in">size</span>()<br>    <span class="hljs-built_in">empty</span>()<br>    <span class="hljs-built_in">push</span>()  向栈顶插入一个元素<br>    <span class="hljs-built_in">top</span>()  返回栈顶元素<br>    <span class="hljs-built_in">pop</span>()  弹出栈顶元素<br><br>deque, 双端队列<br>    <span class="hljs-built_in">size</span>()<br>    <span class="hljs-built_in">empty</span>()<br>    <span class="hljs-built_in">clear</span>()<br>    <span class="hljs-built_in">front</span>()/<span class="hljs-built_in">back</span>()<br>    <span class="hljs-built_in">push_back</span>()/<span class="hljs-built_in">pop_back</span>()<br>    <span class="hljs-built_in">push_front</span>()/<span class="hljs-built_in">pop_front</span>()<br>    <span class="hljs-built_in">begin</span>()/<span class="hljs-built_in">end</span>()<br>    []<br><br>set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列<br>    <span class="hljs-built_in">size</span>()<br>    <span class="hljs-built_in">empty</span>()<br>    <span class="hljs-built_in">clear</span>()<br>    <span class="hljs-built_in">begin</span>()/<span class="hljs-built_in">end</span>()<br>    ++, -- 返回前驱和后继，时间复杂度 <span class="hljs-built_in">O</span>(logn)<br><br>    set/<span class="hljs-function">multiset</span><br><span class="hljs-function">        <span class="hljs-title">insert</span><span class="hljs-params">()</span>  插入一个数</span><br><span class="hljs-function">        <span class="hljs-title">find</span><span class="hljs-params">()</span>  查找一个数</span><br><span class="hljs-function">        <span class="hljs-title">count</span><span class="hljs-params">()</span>  返回某一个数的个数</span><br><span class="hljs-function">        <span class="hljs-title">erase</span><span class="hljs-params">()</span></span><br><span class="hljs-function">            <span class="hljs-params">(<span class="hljs-number">1</span>)</span> 输入是一个数x，删除所有x   <span class="hljs-title">O</span><span class="hljs-params">(k + logn)</span></span><br><span class="hljs-function">            <span class="hljs-params">(<span class="hljs-number">2</span>)</span> 输入一个迭代器，删除这个迭代器</span><br><span class="hljs-function">        <span class="hljs-title">lower_bound</span><span class="hljs-params">()</span>/<span class="hljs-title">upper_bound</span><span class="hljs-params">()</span></span><br><span class="hljs-function">            <span class="hljs-title">lower_bound</span><span class="hljs-params">(x)</span>  返回大于等于x的最小的数的迭代器</span><br><span class="hljs-function">            <span class="hljs-title">upper_bound</span><span class="hljs-params">(x)</span>  返回大于x的最小的数的迭代器</span><br><span class="hljs-function">    map/multimap</span><br><span class="hljs-function">        <span class="hljs-title">insert</span><span class="hljs-params">()</span>  插入的数是一个pair</span><br><span class="hljs-function">        <span class="hljs-title">erase</span><span class="hljs-params">()</span>  输入的参数是pair或者迭代器</span><br><span class="hljs-function">        <span class="hljs-title">find</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        []  注意multimap不支持此操作。 时间复杂度是 <span class="hljs-title">O</span><span class="hljs-params">(logn)</span></span><br><span class="hljs-function">        <span class="hljs-title">lower_bound</span><span class="hljs-params">()</span>/<span class="hljs-title">upper_bound</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</span><br><span class="hljs-function">    和上面类似，增删改查的时间复杂度是 <span class="hljs-title">O</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function">    不支持 <span class="hljs-title">lower_bound</span><span class="hljs-params">()</span>/<span class="hljs-title">upper_bound</span><span class="hljs-params">()</span>， 迭代器的++，--</span><br><span class="hljs-function"></span><br><span class="hljs-function">bitset, 圧位</span><br><span class="hljs-function">    bitset&lt;10000&gt; s</span>;<br>    ~, &amp;, |, ^<br>    &gt;&gt;, &lt;&lt;<br>    ==, !=<br>    []<br><br>    <span class="hljs-built_in">count</span>()  返回有多少个<span class="hljs-number">1</span><br><br>    <span class="hljs-built_in">any</span>()  判断是否至少有一个<span class="hljs-number">1</span><br>    <span class="hljs-built_in">none</span>()  判断是否全为<span class="hljs-number">0</span><br><br>    <span class="hljs-built_in">set</span>()  把所有位置成<span class="hljs-number">1</span><br>    <span class="hljs-built_in">set</span>(k, v)  将第k位变成v<br>    <span class="hljs-built_in">reset</span>()  把所有位变成<span class="hljs-number">0</span><br>    <span class="hljs-built_in">flip</span>()  等价于~<br>    <span class="hljs-built_in">flip</span>(k) 把第k位取反<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——面向对象编程(中级)</title>
    <link href="/2021/11/07/3ac8577c686b.html"/>
    <url>/2021/11/07/3ac8577c686b.html</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程中级">面向对象编程(中级)</h1><h2 id="intellij-idea">IntelliJ IDEA</h2><h3 id="快捷键mac版">快捷键（Mac版）</h3><ol type="1"><li>删除当前行 <code>command</code> + <code>backspace</code></li><li>复制当前行 <code>command</code> + <code>D</code> <span id="more"></span></li><li>补全代码 <code>option</code> + <code>/</code></li><li>添加注释和取消注释 <code>command</code> + <code>space</code> +<code>/</code></li><li>导入该行需要的类 <code>option</code> + <code>enter</code></li><li>快速格式化代码 <code>option</code> + <code>command</code> +<code>L</code></li><li>快速运行程序 <code>control</code> + <code>shift</code> +<code>R</code></li><li>生成构造器等 <code>command</code> + <code>N</code></li><li>查看一个类的层级关系 <code>control</code> + <code>H</code></li><li>自动的分配变量名 <code>.var</code></li><li>定位方法的类 将光标放在方法上 <code>command</code> +<code>click</code></li><li>模板/自定义模板 Live Templates <code>psvm</code><code>sout</code></li></ol><h3 id="快捷键win版">快捷键(Win版)</h3><p>File -&gt; Setting -&gt; Keymap</p><ol start="0" type="1"><li>显示所有快捷键 <code>ctrl + J</code></li><li>删除当前行 <code>Ctrl + Y</code></li><li>复制当前行 <code>Ctrl + D</code></li><li>补全代码 <code>Alt + /</code></li><li>添加、取消注释 <code>Ctrl + /</code></li><li>导入该行需要的类 先配置autoimport，然后使用<code>Alt + Enter</code></li><li>快速格式化代码 <code>Ctrl + Alt + L</code></li><li>快速运行程序 <code>Shift + F10</code></li><li>生成构造器等 <code>Alt + Insert</code></li><li>查看一个类的层级(继承)关系 <code>Ctrl + H</code></li><li>自动的分配变量名 <code>.var</code><kbd>Alt</kbd>+<kbd>Enter</kbd></li><li>定位方法的类 将光标放在方法上 <code>Ctrl + 鼠标左键</code></li><li>模板/自定义模板 LiveTemplates <code>psvm</code> <code>sout</code></li><li>移动当前行 <kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd>↓</kbd></li><li>多行编辑 <kbd>Alt</kbd>+ <kbd>鼠标拖动</kbd></li><li>向后删除 <kbd>Del</kbd></li></ol><h2 id="包">包</h2><h3 id="包的三大作用">包的三大作用</h3><ol type="1"><li>区分相同名字的类</li><li>当类很多时，可以很好的管理类</li><li>控制访问范围</li></ol><h3 id="包的基本语法">包的基本语法</h3><p><code>package 包名;</code> 包的本质实际上就是创建不同的文件夹/目录来保存类文件</p><p><imgsrc="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/image-20211107214820966.png"alt="image-20211107214820966" /> ### 常用的包 * <code>java.lang.*</code>// lang包是基本包，默认引入，不需要再引入 * <code>java.util.*</code> //util包，系统提供的工具包，工具类，例如使用Scanner时需引入 *<code>java.net.*</code> // 网络包，网络开发 * <code>java.awt.*</code> //是做java的界面开发，GUI</p><h2 id="访问修饰符">访问修饰符</h2><table><thead><tr class="header"><th>访问级别</th><th>访问控制修饰符</th><th>同一类</th><th>同一包</th><th style="text-align: left;">子类</th><th style="text-align: left;">不同包</th></tr></thead><tbody><tr class="odd"><td>公开</td><td>public</td><td>√</td><td>√</td><td style="text-align: left;">√</td><td style="text-align: left;">√</td></tr><tr class="even"><td>受保护</td><td>protected</td><td>√</td><td>√</td><td style="text-align: left;">√</td><td style="text-align: left;">×</td></tr><tr class="odd"><td>默认</td><td></td><td>√</td><td>√</td><td style="text-align: left;">×</td><td style="text-align: left;">×</td></tr><tr class="even"><td>私有</td><td>private</td><td>√</td><td>×</td><td style="text-align: left;">×</td><td style="text-align: left;">×</td></tr></tbody></table><h3 id="注意事项">注意事项</h3><ol type="1"><li>修饰符可以用来修饰类中的属性，成员方法以及类</li><li>只有默认的和public才能修饰类！并遵循上述访问权限的特点</li><li>成员方法的访问规则和属性完全一致</li></ol><h2 id="封装">封装</h2><h3 id="封装介绍">封装介绍</h3><p>封装(encapsulation)就是把抽象出的数据【属性】和对数据的操作【方法】封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作【方法】，才能对数据进行操作。</p><h3 id="封装的理解和好处">封装的理解和好处</h3><ol type="1"><li>隐藏实现细节：方法（连接数据库） &lt;--- 调用（传入参数）</li><li>可以对数据进行验证，保证安全合理</li></ol><h3 id="封装的实现步骤三步">封装的实现步骤（三步）</h3><ol type="1"><li>将属性进行私有化private 【不能直接修改属性】</li><li>提供一个公共的set方法，用于对属性判断并赋值 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setXxx</span><span class="hljs-params">(类型 参数名)</span> &#123; <span class="hljs-comment">// Xxx表示某个属性</span><br><span class="hljs-comment">//加入数据验证的业务逻辑</span><br>属性 = 参数名;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>提供一个公共的get方法，用于获取属性的值 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> 数据类型 getXxx() &#123; <span class="hljs-comment">// 权限判断，Xxx的某个属性</span><br>    <span class="hljs-keyword">return</span> xx;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="封装与构造器">封装与构造器</h3><p>构造器中调用set方法，实现数据验证逻辑</p><h2 id="继承">继承</h2><p>当多个类存在相同的属性（变量）和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有子类不需要重新定义这些属性和方法，只需要通过<code>extends</code>来声明继承父类即可。### 继承的基本语法 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">class 子类 extends 父类 &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure> 1. 子类自动拥有父类定义的属性和方法 2.父类又叫超类、基类 3. 子类又叫派生类</p><h3 id="继承的使用细节">继承的使用细节</h3><ol type="1"><li>子类继承了所有的属性和方法，但是私有属性不能在子类直接访问，要通过公共的方法去访问</li><li>子类必须调用父类的构造器，完成父类初始化</li><li>当创建子类对象时，不管使用子类的哪个构造器，<spanstyle="color: rgb(255, 0, 255);">默认情况下总会去调用父类的无参构造器</span>，如果父类没有提供无参构造器，则必须在子类的构造器中用<code>super</code>去指定使用父类的哪个构造器完成对父类的初始化工作，否则编译不会通过。</li><li>如果希望指定去调用父类的某个构造器，则显式的调用一下：<code>super(参数列表);</code></li><li><code>super</code>在使用时，必须放在构造器第一行</li><li><code>super()</code>和this<spanstyle="color: rgb(255, 0, 255);">()</span>都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器中</li><li>Java所有类都是Object类的子类</li><li>父类构造器的调用不限于直接父类！将一直往上追溯直到Object类</li><li>子类最多只能继承一个父类（指直接继承），Java中是单继承机制</li><li>不能滥用继承，子类和父类之间必须满足<code>is-a</code>的逻辑关系</li></ol><h3 id="继承的内存布局">继承的内存布局</h3><p><img src="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/image-20211109202905373.png" alt="image-20211109202905373" style="zoom:50%;" /></p><h2 id="多态-polymorphic">多态 Polymorphic</h2><h3 id="多态基本介绍">多态基本介绍</h3><p>方法或者对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承的基础之上的。</p><h3 id="多态的具体体现">多态的具体体现</h3><ol type="1"><li>方法的多态： 重写和重载体现多态</li><li>对象的多态：<ul><li>一个对象的编译类型和运行类型可以不一致</li><li>编译类型在定义对象时就确定了，不能改变</li><li>运行类型时可以变化的</li><li>编译类型看定义时<code>=</code>的左边，运行类型看<code>=</code>的右边<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(); <span class="hljs-comment">// animal编译类型是Animal，运行类型是Dog</span><br>animal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(); <span class="hljs-comment">// animal的运行类型变成了Cat，编译类型仍然是Animal</span><br></code></pre></td></tr></table></figure></li></ul></li><li>使用多态机制，统一管理主人喂食问题 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">feed</span><span class="hljs-params">(Animal animal, Food food)</span> &#123;<br>System.out.println(animal.getName() + <span class="hljs-string">&quot; &quot;</span> + food.getName());<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="注意细节">注意细节</h3><ol type="1"><li>多态的前提是：两个对象（类）存在继承关系</li><li>多态的向上转型<ul><li>本质：父类引用指向子类对象 <code>Object obj = new Cat();</code></li><li>特点：可以调用父类中的所有成员（需遵守访问权限），不能调用子类的特有成员，最终运行效果看子类的具体实现。</li></ul></li><li>多态的向下转型<ul><li>语法：<code>子类类型 引用名 = (子类类型) 父类引用;</code><code>Cat cat = (Cat) animal;</code></li><li>特点：只能强转父类的引用，不能强转父类的对象；要求父类的引用必须指向的是当前目标类型；可以调用子类类型中的所有成员</li></ul></li><li>属性/成员变量没有重写之说！<spanstyle="color: rgb(255, 0, 255);">属性的值看编译类型</span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Base</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>();<br>System.out.println(base.count); <span class="hljs-comment">// 10</span><br><span class="hljs-type">Sub</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>();<br>System.out.println(sub.count); <span class="hljs-comment">// 20</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><code>instanceOf</code>比较操作符，用于判断对象的<spanstyle="color: rgb(255, 0, 255);">运行类型</span>是否为xx类型或xx类型的子类型</li><li>Java的动态绑定机制(重要)<ul><li>当调用对象方法的时候，<spanstyle="color: rgb(255, 0, 255);">该方法会和该对象的内存地址/运行类型</span>绑定</li><li>当调用对象属性时，没有动态绑定机制，哪里声明，那里使用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getI() + <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getI</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br>   <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>    <span class="hljs-comment">// public int sum() &#123;</span><br>    <span class="hljs-comment">//  return i + 20;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getI</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-comment">// public int sum1() &#123;</span><br>    <span class="hljs-comment">// return i + 10;</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;<br>   <br><span class="hljs-comment">// main方法中</span><br><span class="hljs-comment">// A是a的编译类型，B是a的运行类型</span><br><span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>(); <span class="hljs-comment">// 向上转型</span><br>System.out.println(a.sum()); <span class="hljs-comment">// 40 注释掉B的sum方法后---&gt;  30</span><br>Systtem.out.println(a.sum1()); <span class="hljs-comment">// 30  ---&gt;  20</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="多态的应用">多态的应用</h3><ol type="1"><li>多态数组 数组的定义类型为父类类型，里面保存的实际元素类型为子类类型<code>Person[] persons = new Person[5];</code><code>persons[0] = new Student("jack", 18, 100);</code><code>if(person[i] instanceOf Student) ((Student) person[i]).study();</code></li><li>多态参数 方法定义的形参类型为父类类型，实参类型允许为子类类型</li></ol><h2 id="super">Super</h2><p>super代表父类的引用，用于访问父类的属性、方法、构造器 ### 基本语法 1.访问父类的属性，但不能访问父类的private属性 <code>super.属性名;</code>2. 访问父类的方法，不能访问父类的private方法<code>super.方法名(参数列表);</code> 3.访问父类的构造器，只能用在构造器的第一句，只能出现一句!<code>super(参数列表);</code></p><h3 id="使用细节">使用细节</h3><ol type="1"><li>调用父类的构造器的好处（分工明确，父类属性由父类初始化，子类属性由子类初始化）</li><li>当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果！</li><li>如果多个基类（上级类）中都用同名的成员，使用super访问遵循就近原则。</li></ol><h3 id="super和this的比较">super和this的比较</h3><figure><imgsrc="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/image-20211109215804994.png"alt="image-20211109215804994" /><figcaption aria-hidden="true">image-20211109215804994</figcaption></figure><h2 id="方法重写覆盖-override">方法重写/覆盖 Override</h2><p>方法重写就是子类有一个方法，和父类的某个方法的名字、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的方法### 使用细节 1.子类的方法的形参列表，方法名，要和父类方法的形参列表，方法名完全一致。2. 子类方法的返回类型和父类方法的返回类型一样，或者是父类<spanstyle="color: rgb(255, 0, 255);">返回类型的子类</span>；比如父类返回类型是Object，子类方法返回类型是String。 3.子类方法不能缩小父类方法的访问权限。 <code>void A() &#123;&#125;</code><code>public void A() &#123;&#125;</code></p><h3 id="方法重写和重载的比较">方法重写和重载的比较</h3><p><img src="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/image-20211109222337091.png" alt="image-20211109222337091" style="zoom:50%;" /></p><h2 id="object类详解">Object类详解</h2><h3 id="equals">equals()</h3><ol type="1"><li><code>==</code>和<code>equals</code>的对比</li></ol><ul><li><code>==</code>是一个比较运算符，既可以判断基本类型(值)，又可以判断引用类型(地址)</li><li><code>equals</code>只能判断引用类型，默认判断的是地址是否相等，子类往往重写该方法，用于判断内容是否相等。</li></ul><h3 id="hashcode">hashCode()</h3><ol type="1"><li>提高具有哈希结构的容器的效率！</li><li>两个引用，如果指向的是同一对象，则哈希值肯定一样</li><li>两个引用，如果指向的是不同的对象，则哈希值是不一样的</li><li>哈希值主要是根据地址号来的，不能完全将哈希值等价于地址</li></ol><h3 id="tostring">toString()</h3><ol type="1"><li>基本介绍 默认返回：全类名 + @ +哈希值的十六进制，子类往往重写toString方法，用于返回对象的属性信息。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>&#125;<br></code></pre></td></tr></table></figure></li><li>重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式。</li><li>当直接输出一个对象时，toString方法会被默认的调用。</li></ol><h3 id="finalize">finalize()</h3><ol type="1"><li>当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些<code>释放资源</code>的操作；</li><li>当某个对象没有任何引用时，则JVM就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象之前，会先调用finalize方法；</li><li>垃圾回收机制的调用，是由系统来决定的，也可以通过<code>System.gc()</code>主动触发垃圾回收机制；</li></ol><h2 id="断点调试">断点调试</h2><ol type="1"><li><code>Step over</code> 逐行运行</li><li><code>Step into</code> 进入方法 <code>Step out</code>运行完当前方法</li><li><code>Resume</code> 运行到下一个断点</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——面向对象编程(基础部分)</title>
    <link href="/2021/11/06/547b5e049711.html"/>
    <url>/2021/11/06/547b5e049711.html</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程基础">面向对象编程(基础)</h1><h2 id="类和对象">类和对象</h2><p>单独变量来解决，不利于数据的管理；数组，数据类型体现不出，不能体现行为；类 (<spanstyle="color: rgb(255, 0, 255);">自定义数据类型</span>)--------&gt;对象【属性， 行为】(具体的实例)类是抽象的；对象是具体的；类是对象的模板<span id="more"></span></p><h3 id="对象内存布局">对象内存布局</h3><p><imgsrc="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/image-20211104172142987.png"alt="image-20211104172142987" /> 字符串常量是索引</p><ul><li><p><spanstyle="color: rgb(255, 0, 255);">类和对象的内存分配机制</span></p><p><code>栈</code>：一般存放基本数据类型（局部变量）；<code>堆</code>：存放对象（Catcat，数组等）；<code>方法区</code>：常量池（常量，比如字符串），类加载信息</p></li></ul><h3 id="对象创建过程">对象创建过程</h3><ol type="1"><li><p>先加载Person类信息（属性和方法信息，只会加载一次）</p></li><li><p>在堆中分配空间，进行默认初始化（看规则）</p></li><li><p>把地址赋给p，p就指向对象</p></li><li><p>进行指定初始化，比如<code>p.name = "jack";</code><code>p.age = 10;</code></p><figure><imgsrc="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/image-20211104214002977.png"alt="image-20211104214002977" /><figcaption aria-hidden="true">image-20211104214002977</figcaption></figure></li></ol><h3 id="属性成员变量">属性/成员变量</h3><ol type="1"><li>属性的定义语法同变量，实例：访问修饰符 属性类型 属性名；</li><li>属性的定义类型可以为任意类型，包含基本数据类型和引用类型；</li><li>属性若不赋值，有默认值，规则和数组一致； 访问属性 ：<code>对象名.属性名</code></li></ol><h2 id="成员方法">成员方法</h2><h3 id="方法调用机制">方法调用机制</h3><figure><imgsrc="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/image-20211105153704015.png"alt="image-20211105153704015" /><figcaption aria-hidden="true">image-20211105153704015</figcaption></figure><h3 id="成员方法的好处">成员方法的好处</h3><ol type="1"><li>提高代码的复用性</li><li>将实现细节封装起来，供其他用户调用</li></ol><h3 id="方法使用细节">方法使用细节</h3><ol type="1"><li>访问修饰符（作用是控制 方法使用的范围） 如果不写，则默认访问，【有四种：public, protected, default, private】</li><li>返回数据类型<ul><li>一个方法最多有一个返回值【通过数组返回多个结果】</li><li>返回类型可以任意类型，包含基本类型和 <spanstyle="color: rgb(255, 0, 255);">引用类型（数组、对象）</span></li><li>返回值类型必须和return的值类型一致或者<code>兼容</code>（自动类型转换）</li><li>驼峰命名法</li></ul></li><li>方法体<ul><li>方法不能嵌套定义</li></ul></li><li>方法调用<ul><li>同一个类中的方法调用：直接调用即可</li><li>跨类中的方法A类调用B类方法：需要通过对象名调用。先创建对象，再调用</li><li>跨类的方法调用和方法的访问修饰符相关</li></ul></li></ol><h3 id="编写方法的思路">编写方法的思路</h3><ol type="1"><li>方法的返回类型</li><li>方法的名字</li><li>方法的形参</li><li>方法体</li></ol><h2 id="成员方法传参机制">成员方法传参机制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 实参和形参，位于不同栈中</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">method</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;  <br>        <span class="hljs-type">AA</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AA</span>(); <br>        s.swap(a, b); <span class="hljs-comment">// 调用方法，会创建新栈</span><br>        System.out.println(<span class="hljs-string">&quot;\nmain中a = &quot;</span> + a + <span class="hljs-string">&quot;, b = &quot;</span> + b); <br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> a;<br>        System.out.println(<span class="hljs-string">&quot;\n交换前a = &quot;</span> + a + <span class="hljs-string">&quot;, b = &quot;</span> + b);<br>        a = b;<br>        b = tmp;<br>        System.out.println(<span class="hljs-string">&quot;\n交换后a = &quot;</span> + a + <span class="hljs-string">&quot;, b = &quot;</span> + b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>int[] arr = &#123;1, 2, 3&#125;;</code>引用类型传递的是<code>地址</code>（传递也是值，但值是地址），指向<code>堆</code>的相应位置，可以通过形参影响实参！</p><h2 id="方法重载overload">方法重载OverLoad</h2><p>Java中允许同一个类中，多个同名方法的存在，但要求形参列表不一致!比如：<code>System.out.println();</code> 中out是PrintStream类型</p><ol type="1"><li>方法名：必须相同</li><li>形参列表：必须不同（形参类型或个数或顺序，至少有一个不同）</li><li>返回类型：无要求</li></ol><h2 id="可变参数">可变参数</h2><p>Java允许将同一个类中<code>多个同名同功能</code>但<code>参数个数不同</code>的方法，封装成一个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">访问修饰符 返回类型 方法名(数据类型... 形参名) &#123;<br>    <span class="hljs-comment">// 使用可变参数时，可以当作数组来使用</span><br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>可变参数的实参可以为0个或者任意多个；</li><li>可变参数的实参可以是数组；</li><li>可变参数的本质是数组；</li><li>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后；</li><li>一个形参列表中只能出现一个可变参数；</li></ol><h2 id="作用域">作用域</h2><ul><li>全局变量：属性（成员变量），作用域是整个类体；</li><li>局部变量：除了属性之外的其他变量，作用域是定义它的代码块；</li><li>全局变量可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值；</li><li>属性的生命周期比较长，伴随着对象的创建而创建，伴随着对象的死亡而死亡。局部变量，生命周期比较短，在一次方法调用过程中。</li></ul><h3 id="注意事项">注意事项</h3><ol type="1"><li>全局变量/属性：可以被本类使用，或者其它类使用（通过对象调用）</li><li>局部变量：只能在本类中对应的方法使用</li><li>全局变量可以加修饰符，局部变量不可以加修饰符</li></ol><h2 id="构造器-constructor">构造器 Constructor</h2><p>构造器又叫构造方法，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。特点如下：1）方法名和类名相同 2）<spanstyle="color: rgb(255, 0, 255);">没有返回值</span>3）在创建对象时，<code>系统</code>会自动的调用该类的构造器完成对<code>对象</code>的<code>初始化</code></p><h3 id="注意事项-1">注意事项</h3><ol type="1"><li>一个类可以定义多个不同的构造器</li><li>构造器名和类名要相同</li><li>构造器是完成对象的初始化，并不是创建对象</li><li>若开发者没有定义构造器，系统会自动给类生成一个默认无参构造器，<code>javap</code>反编译</li><li>一旦自定义了构造器，默认构造器就被覆盖</li></ol><h3 id="对象创建流程">对象创建流程</h3><ol type="1"><li>加载Person类信息（Person.class），只会加载一次</li><li>在堆中分配空间（地址）</li><li>完成对象初始化 3.1 默认初始化 age = 0, name = null 3.2 显示初始化age = 90, name = null 3.3 构造器初始化 age = 10, name = “小倩”</li><li>把对象在堆中的地址，返回给p（p是对象名，也可以理解成对象的引用）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">90</span>;<br>String name;<br>Person(String n, <span class="hljs-type">int</span> a) &#123;<br>name = n;<br>age = a;<br>&#125;<br>&#125;<br><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;小倩&quot;</span>, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure> ## thisJava虚拟机会给每个对象分配<code>this</code>，代表当前对象。使用<code>this</code>解决变量命名问题</li></ol><figure><imgsrc="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/image-20211106165450967.png"alt="image-20211106165450967" /><figcaption aria-hidden="true">image-20211106165450967</figcaption></figure><p><code>dog1.age</code> 等同于<code>this.age</code>，可以用hashCode验证</p><h3 id="this的使用细节">this的使用细节</h3><ol type="1"><li>this关键字可以用来访问本类的属性、方法、构造器</li><li>this用于区分当前类的属性和局部变量</li><li>访问成员方法的语法：<code>this.方法名(参数列表);</code></li><li>访问构造器语法：<code>this(参数列表);</code>注意只能在构造器中的第一个语句使用（即只能在构造器中访问另一个构造器）</li><li>this不能在类定义的外部使用</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法模板Part One - 基础算法</title>
    <link href="/2021/11/05/ccc1686ecce6.html"/>
    <url>/2021/11/05/ccc1686ecce6.html</url>
    
    <content type="html"><![CDATA[<h2 id="快速排序">快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j), <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="归并排序">归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(q, l, mid);<br>    <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span> tmp[k ++ ] = q[j ++ ];<br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];<br><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="整数二分">整数二分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="浮点数二分">浮点数二分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; eps)<br>    &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度加法">高精度加法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C = A + B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() &lt; B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(B, A);<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t) C.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度减法">高精度减法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度乘低精度">高精度乘低精度</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C = A * b, A &gt;= 0, b &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || t; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i] * b;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度除以低精度">高精度除以低精度</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;r)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一维前缀和">一维前缀和</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">S[i] = a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] + ... a[i]<br>a[l] + ... + a[r] = S[r] - S[l - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="二维前缀和">二维前缀和</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">S[i, j] = 第i行j列格子左上部分所有元素的和<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - <span class="hljs-number">1</span>, y2] - S[x2, y1 - <span class="hljs-number">1</span>] + S[x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="一维差分">一维差分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">给区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="hljs-number">1</span>] -= c<br></code></pre></td></tr></table></figure><h2 id="二维差分">二维差分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] += c, S[x2 + <span class="hljs-number">1</span>, y1] -= c, S[x1, y2 + <span class="hljs-number">1</span>] -= c, S[x2 + <span class="hljs-number">1</span>, y2 + <span class="hljs-number">1</span>] += c<br></code></pre></td></tr></table></figure><h2 id="位运算">位运算</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">求n的第k位数字: n &gt;&gt; k &amp; <span class="hljs-number">1</span><br>返回n的最后一位<span class="hljs-number">1</span>：<span class="hljs-built_in">lowbit</span>(n) = n &amp; -n<br></code></pre></td></tr></table></figure><h2 id="双指针算法">双指针算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j ++ ;<br><br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br>常见问题分类：<br>  (<span class="hljs-number">1</span>) 对于一个序列，用两个指针维护一段区间<br>  (<span class="hljs-number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作<br></code></pre></td></tr></table></figure><h2 id="离散化">离散化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt; alls; <span class="hljs-comment">// 存储所有待离散化的值</span><br><span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将所有值排序</span><br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">// 去掉重复元素</span><br><br><span class="hljs-comment">// 二分求出x对应的离散化的值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 找到第一个大于等于x的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 映射到1, 2, ...n</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="区间合并">区间合并</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 将所有存在交集的区间合并</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;PII&gt; &amp;segs)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;PII&gt; res;<br><br>    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(), segs.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-type">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs)<br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>            st = seg.first, ed = seg.second;<br>        &#125;<br>        <span class="hljs-keyword">else</span> ed = <span class="hljs-built_in">max</span>(ed, seg.second);<br><br>    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br><br>    segs = res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记——前置知识</title>
    <link href="/2021/11/01/4d89359e5d87.html"/>
    <url>/2021/11/01/4d89359e5d87.html</url>
    
    <content type="html"><![CDATA[<p>javac 将java文件<code>编译</code>成class文件 Java8、Java11 （LTS)</p><h2 id="java特点">Java特点</h2><ol type="1"><li>面向对象的OOP</li><li>健壮的：强类型机制、异常处理、垃圾自动回收</li><li>跨平台(JVM)</li><li>解释型（编译后还需要<code>解释器</code>来执行）<span id="more"></span></li></ol><h2 id="jdk">JDK</h2><p>Java Development Kit，JDK = JRE + Java的开发工具。JRE（Java RuntimeEnvironment）中包含JVM和Java的核心类库。</p><h2 id="java快速入门">Java快速入门</h2><ol type="1"><li>需求说明</li><li>开发步骤</li><li>运行原理</li><li>细节和注意事项</li></ol><h3 id="控制台编码格式gbk">控制台编码格式GBK</h3><p>运行<code>java hello</code> 而非 <code>java hello.class</code></p><h3 id="注意事项">注意事项</h3><ol type="1"><li><font color='x00aaff'>一个源文件中最多只能有一个public类</font>，其他类的个数不限。编译后每个类都生成一个<code>.class</code>文件；</li><li>如果源文件包含一个public类，则文件名必须按该类名命名！</li><li>可以将main方法写在非public类中，然后指定运行非public类；</li></ol><h2 id="java学习方法">Java学习方法</h2><ol type="1"><li>先看需求</li><li>看是否能用传统技术解决</li><li>引入新技术和知识点</li><li>学习新技术或者知识点的基本原理和语法（不要考虑细节）</li><li>快速入门（基本程序，CRUD）</li><li>开始研究技术的注意事项，细节，规范，以及如何优化</li></ol><h2 id="基础语法">基础语法</h2><h3 id="java转义字符">Java转义字符</h3><p><code>\t</code>：制表符， <code>\n</code>：换行符，<code>\r</code>：回车(光标回到行首)</p><h3 id="注释comment">注释（comment）</h3><p>单行注释<code>//</code>、多行注释<code>/* ...  */</code>（不要嵌套）、文档注释<code>javadoc标签</code><code>/** ... */</code></p><h3 id="java代码规范">Java代码规范</h3><ol type="1"><li>类、方法的注释，以javadoc的方式来写；</li><li>源文件使用utf-8编码</li><li>行宽不要超过80字符</li><li>运算符两边习惯性加空格</li><li>代码编写<code>次行风格</code>和<code>行尾风格</code></li></ol><h3 id="快捷键">快捷键</h3><ol type="1"><li><code>CTRL</code> + <code>[</code> 或<code>]</code>整行左右移动</li></ol><h3 id="dos命令">DOS命令</h3><p>Disk Operating System 磁盘操作系统 常见的dos命令：</p><ol type="1"><li>查看当前目录有哪些文件 <code>dir</code></li><li>切换到其他目录 <code>cd</code></li><li>创建目录 <code>md</code></li><li>删除目录 <code>rd</code></li><li>相对路径&amp;绝对路径 <code>..</code> <code>\</code></li><li>查看指定目录下所有子目录 <code>tree</code></li><li>清屏clean screen <code>cls</code></li><li>退出DOS <code>exit</code></li><li>* 其他 <code>echo</code> <code>copy</code> <code>move</code><code>del</code> <code>type</code></li></ol><h2 id="java数据类型">Java数据类型</h2><ol type="1"><li><p>基本数据类型 数值型<code>byte[1], short[2], int[4], long[8], float[4], double[8]</code>、字符型 <code>char[2]</code> 、布尔型 <code>boolean[1]</code></p></li><li><p>引用数据类型 类 <code>class</code> 、接口 <code>interface</code>、数组 <code>[]</code> <!--more--></p><p>【String是类，属于引用数据类型】</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 基本数据类型 -&gt; 字符串</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> n1 + <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> b1 + <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-comment">// 字符串 -&gt; 基本数据类型 【包装类的parseXxx()方法解析】</span><br>Integer.parseInt(<span class="hljs-string">&quot;123&quot;</span>);<br>Boolean.parseBoolean(<span class="hljs-string">&quot;true&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="java-api-文档">Java API 文档</h2><p>Application Programming Interface，Java提供大量的基础类。Java类的组织形式 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">JDK -&gt; 包 -&gt; 类、接口、异常 -&gt; 字段、构造器、成员方法<br></code></pre></td></tr></table></figure></p><h2 id="运算符优先级">运算符优先级</h2><ol type="1"><li>只有单目运算符、赋值运算符是从右向左运算的。</li><li><ol type="a"><li><code>()</code> <code>.</code> <code>&#123;&#125;</code> <code>,</code></li><li>单目运算符<code>--</code> <code>++</code></li><li>算术运算符</li><li>位移运算符</li><li>比较运算符</li><li>逻辑运算符</li><li>三元运算符</li><li>赋值运算符</li></ol></li></ol><h2 id="键盘输入语句">键盘输入语句</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-comment">// 创建Scanner类对象</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-comment">// 调用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> input.next(); <span class="hljs-comment">// 输入一个字符串</span><br><span class="hljs-type">char</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> input.next().charAt(<span class="hljs-number">0</span>); <span class="hljs-comment">// 输入一个字符</span><br><span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> input.nextInt();<br><span class="hljs-type">double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> input.nextDouble();<br></code></pre></td></tr></table></figure><h2 id="原码反码补码">原码、反码、补码</h2><ol type="1"><li>二进制的最高位是符号位：0表示正数，1表示负数</li><li>正数三码合一</li><li>负数的反码 = 它的原码符号位不变，其他位取反</li><li>负数的补码 = 它的反码 + 1， 负数的反码 = 它的补码 - 1</li><li>0的反码、补码都是0</li><li>Java没有无符号数</li><li>计算机以<code>补码</code>方式运算</li><li>运算结果要看原码</li></ol><h2 id="数组赋值机制">数组赋值机制</h2><p>数组在默认情况下是<code>引用</code>传递，赋的值是<code>地址</code>。而基本数据类型赋值方式为<code>拷贝</code>。</p><h3 id="值传递和引用传递的区别">值传递和引用传递的区别</h3><p>栈、堆、方法区</p><figure><imgsrc="https://raw.githubusercontent.com/nessaj7/ImageHost/main/img/image-20211104155422426.png"alt="image-20211104155422426" /><figcaption aria-hidden="true">image-20211104155422426</figcaption></figure><h2 id="数组拷贝">数组拷贝</h2><ol type="1"><li>创建一个新数组，开辟新的数据空间</li><li>遍历arr1， 把每个元素拷贝到arr2对应元素位置 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span>[] arr1 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br><span class="hljs-type">int</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr1.length];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr1.length; i ++ ) &#123;<br>    arr2[i] = arr1[i];<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Quantumult X: 我最爱的IOS神器</title>
    <link href="/2021/10/09/62a04f5b8b05.html"/>
    <url>/2021/10/09/62a04f5b8b05.html</url>
    
    <content type="html"><![CDATA[<center>“Quantumult X is a powerful network tool on iOS”</center><p>圈X作为一款代理软件，科学上网是它最不值得一提的功能。通过配置『分流』『重写』『MitM』等规则，它能实现包括去广告，自动化签到，薅羊毛，以及破解软件VIP权限等骚操作。折腾了一段时间，算是回归平淡。</p><p>每次来来回回找一些配置文件耗费不少时间，很多大佬的仓库也确实有很多不错的脚本，可大部分都是我用不到的，过分臃肿。所以在此整理一下自己用到的配置，避免之后重写捣鼓无意义的时间开销。</p><span id="more"></span><h2 id="general">[general]</h2><p>模块内为一些通用的设置参数项 Quantumult X 会对<code>server_check_url</code>指定的网址进行相应测试，以确认节点的可用性；同样可以在server_local/remote中，为节点、订阅单独指定<code>server_check_url</code>参数</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server_check_url</span>=<span class="hljs-string">http://www.qualcomm.cn/generate_204</span><br></code></pre></td></tr></table></figure><p>节点延迟测试超时参数，需小于 5000 毫秒才生效 <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server_check_timeout</span>=<span class="hljs-string">2000</span><br></code></pre></td></tr></table></figure></p><p>资源解析器，可用于自定义各类远程资源的转换，如节点，规则 filter，复写rewrite 等 <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">resource_parser_url</span>=<span class="hljs-string">https://cdn.jsdelivr.net/gh/KOP-XIAO/QuantumultX@master/Scripts/resource-parser.js</span><br></code></pre></td></tr></table></figure></p><p><code>geo_location_checker</code>用于节点页面的节点信息展示</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">geo_location_checker</span>=<span class="hljs-string">http://ip-api.com/json/?lang=zh-CN, https://raw.githubusercontent.com/KOP-XIAO/QuantumultX/master/Scripts/IP_API.js</span><br></code></pre></td></tr></table></figure><p>运行模式模块，<code>running_mode_trigger</code>设置，即根据网络自动切换 分流/直连/全局代理 等模式。</p><p><code>running-mode-trigger</code> 模式下，跟手动切换直连/全局代理等效，rewrite/task 模块始终会生效</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 前两个 filter 先后表示 在 [数据蜂窝网络] 跟 [一般 Wi-Fi] 下，走 filter(分流)模式</span><br><span class="hljs-comment"># 后面表示在 asus-5g 下切换为全局直连[all_direct]，asus 切换为全局代理[all_proxy]</span><br><span class="hljs-comment"># 如需使用，相应 SSID 换成自己 Wi-Fi 名即可</span><br><span class="hljs-attr">running_mode_trigger</span>=<span class="hljs-string">filter, filter, asus-5g:all_direct, asus:all_proxy</span><br></code></pre></td></tr></table></figure><p>UDP白名单，留空则默认所有为端口。不在udp白名单列表中的端口，将被丢弃处理（返回ICMP “端口不可达” 信息）。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">udp_whitelist</span>=<span class="hljs-string">53, 80-427, 444-65535</span><br></code></pre></td></tr></table></figure><p>参数 fallback_udp_policy的值仅支持末端策略（末端策略为经由规则模块和策略模块后所命中的策略，例如：direct、reject以及节点；不支持内置策略 proxy 以及其它自定义策略）。 <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">fallback_udp_policy</span>=<span class="hljs-string">direct</span><br></code></pre></td></tr></table></figure>下列表中的内容将不经过 QuantumultX的处理，设置后建议重启设备<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">excluded_routes</span>=<span class="hljs-string">192.168.0.0/16, 172.16.0.0/12, 100.64.0.0/10, 10.0.0.0/8</span><br><span class="hljs-attr">icmp_auto_reply</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure></p><h2 id="dns">[dns]</h2><p>指定 dns 服务器，并发响应选取最优结果 <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server</span>=<span class="hljs-string">114.114.114.114</span><br><span class="hljs-attr">server</span>=<span class="hljs-string">202.141.176.93 </span><br><span class="hljs-attr">server</span>=<span class="hljs-string">202.141.178.13</span><br><span class="hljs-attr">server</span>=<span class="hljs-string">117.50.10.10</span><br><span class="hljs-attr">server</span>=<span class="hljs-string">223.5.5.5</span><br><span class="hljs-attr">server</span>=<span class="hljs-string">119.29.29.29:53</span><br><span class="hljs-attr">server</span>=<span class="hljs-string">119.28.28.28</span><br></code></pre></td></tr></table></figure></p><p>指定域名解析dns, 下面为示范，按需启用 <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server</span>=<span class="hljs-string">/*.taobao.com/223.5.5.5</span><br><span class="hljs-attr">server</span>=<span class="hljs-string">/*.tmall.com/223.5.5.5</span><br><span class="hljs-attr">server</span>=<span class="hljs-string">/*.qq.com/119.28.28.28</span><br><span class="hljs-attr">server</span>=<span class="hljs-string">/*.163.com/119.29.29.29</span><br><span class="hljs-attr">server</span>=<span class="hljs-string">/*.netease.com/119.29.29.29</span><br><span class="hljs-attr">;server</span>=<span class="hljs-string">/*.mi.com/119.29.29.29</span><br><span class="hljs-attr">;server</span>=<span class="hljs-string">/*testflight.apple.com/23.76.66.98</span><br><span class="hljs-attr">;server</span>=<span class="hljs-string">8.8.8.8</span><br></code></pre></td></tr></table></figure></p><h2 id="policy">[policy]</h2><p>static 策略组中，你需要手动选择想要的节点/策略组。url-latency-benchmark 延迟策略组，选取延迟最优节点。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># img-url 参数用于指定策略组图标</span><br><span class="hljs-comment"># server-tag-regex 以及 resource-tag-regex 参数用于正则筛选来建立策略组</span><br><span class="hljs-attr">static</span>=<span class="hljs-string">国内, direct, proxy, img-url=https://raw.githubusercontent.com/Koolson/Qure/master/IconSet/DomesticMedia.png</span><br><span class="hljs-attr">static</span>=<span class="hljs-string">全球加速, 香港, 台湾, 日本, 新加坡, 美国, proxy, img-url=https://raw.githubusercontent.com/Orz-3/mini/master/Color/Global.png</span><br><br><span class="hljs-attr">url-latency-benchmark</span>=<span class="hljs-string">香港, server-tag-regex=(?=.*(港|HK|(?i)Hong))^((?!(台|日|韩|新|美)).)*$, check-interval=86400, tolerance=0, img-url=https://raw.githubusercontent.com/Orz-3/mini/master/Color/HK.png</span><br><span class="hljs-attr">url-latency-benchmark</span>=<span class="hljs-string">台湾, server-tag-regex=(?=.*(台|TW|(?i)Taiwan))^((?!(港|日|韩|新|美)).)*$, check-interval=86400, tolerance=0, img-url=https://raw.githubusercontent.com/Orz-3/mini/master/Color/TW.png</span><br><span class="hljs-attr">url-latency-benchmark</span>=<span class="hljs-string">日本, server-tag-regex=(?=.*(日|JP|(?i)Japan))^((?!(港|台|韩|新|美)).)*$, check-interval=86400, tolerance=0, img-url=https://raw.githubusercontent.com/Orz-3/mini/master/Color/JP.png</span><br><span class="hljs-attr">url-latency-benchmark</span>=<span class="hljs-string">新加坡, server-tag-regex=(?=.*(新|SG|(?i)Singapore))^((?!(港|台|日|韩|美)).)*$, check-interval=86400, tolerance=0, img-url=https://raw.githubusercontent.com/Orz-3/mini/master/Color/SG.png</span><br><span class="hljs-attr">url-latency-benchmark</span>=<span class="hljs-string">美国, server-tag-regex=(?=.*(美|US|(?i)States|American))^((?!(港|台|日|韩|新)).)*$, check-interval=86400, tolerance=0, img-url=https://raw.githubusercontent.com/Orz-3/mini/master/Color/US.png</span><br></code></pre></td></tr></table></figure><h2 id="服务器">服务器</h2><h3 id="server_remote">[server_remote]</h3><p>远程服务器订阅模块，可直接订阅SSR，SS链接，以及QuantumultX格式的vmess/trojan/https订阅</p><p>其它格式可用 opt-parser 参数开启解析器导入使用</p><p>img-url参数用于指定图标，格式要求同样为 108*108 的 png图片，可远程，可本地</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># &quot;tag&quot; 跟 &quot;enabled&quot; 为可选参数，分别表示 “标签”及“开启状态”, true 为开启，false 关闭.</span><br><span class="hljs-comment"># update-interval 为更新时间参数，单位 秒, 默认更新时间为 24*60*60=86400 秒，也就是24小时.</span><br><span class="hljs-comment"># opt-parser=true/false 用于控制是否对本订阅 开启资源解析器，不写或者 false 表示不启用解析器;</span><br><span class="hljs-attr">https</span>:<span class="hljs-string">//xxx, tag=机场订阅示范, update-interval=86400, opt-parser=true, img-url=https://raw.githubusercontent.com/Koolson/Qure/master/IconSet/Quantumult_X.png, enabled=true</span><br></code></pre></td></tr></table></figure><h3 id="server_local">[server_local]</h3><p>支持本地/iCloud的节点文件/片段，位于Quantumult X/Profiles路径下<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">;servers.snippet, tag=本地服务器, img-url=https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/crossutility/</span>Quantumult-X<span class="hljs-regexp">/master/</span>quantumult-x.png, enabled=false<br></code></pre></td></tr></table></figure></p><h2 id="规则分流">规则分流</h2><h3 id="filter_remote">[filter_remote]</h3><p>远程分流模块，可使用force-policy来强制使用策略偏好,替换远程规则内所指定的策略组</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">https</span>:<span class="hljs-string">//raw.githubusercontent.com/DivineEngine/Profiles/master/Surge/Ruleset/Unbreak.list, tag=规则修正, force-policy=direct, update-interval=172800, opt-parser=true, enabled=true</span><br><span class="hljs-attr">https</span>:<span class="hljs-string">//raw.githubusercontent.com/DivineEngine/Profiles/master/Surge/Ruleset/Guard/Advertising.list, tag=广告拦截, force-policy=reject, update-interval=172800, opt-parser=true, enabled=true</span><br><span class="hljs-attr">https</span>:<span class="hljs-string">//raw.githubusercontent.com/DivineEngine/Profiles/master/Surge/Ruleset/Guard/AdvertisingPlus.list#type=domain-set, tag=广告拦截, force-policy=reject, update-interval=172800, opt-parser=true, enabled=true</span><br><span class="hljs-attr">https</span>:<span class="hljs-string">//raw.githubusercontent.com/NobyDa/Script/master/Surge/AdRule.list, tag=广告拦截, force-policy=reject, update-interval=172800, opt-parser=true, enabled=true</span><br><span class="hljs-attr">https</span>:<span class="hljs-string">//raw.githubusercontent.com/app2smile/rules/master/rule/tieba-ad-qx.list, tag=贴吧广告, force-policy=reject, update-interval=172800, opt-parser=false, enabled=true</span><br><span class="hljs-attr">https</span>:<span class="hljs-string">//raw.githubusercontent.com/DivineEngine/Profiles/master/Surge/Ruleset/Guard/Hijacking.list, tag=运营劫持, force-policy=reject, update-interval=172800, opt-parser=true, enabled=true</span><br><span class="hljs-attr">https</span>:<span class="hljs-string">//raw.githubusercontent.com/DivineEngine/Profiles/master/Surge/Ruleset/Guard/Privacy.list, tag=隐私保护, force-policy=reject, update-interval=172800, opt-parser=true, enabled=true</span><br><br><span class="hljs-attr">https</span>:<span class="hljs-string">//raw.githubusercontent.com/DivineEngine/Profiles/master/Surge/Ruleset/Global.list, tag=全球加速, force-policy=全球加速, update-interval=172800, opt-parser=true, enabled=true</span><br><span class="hljs-attr">https</span>:<span class="hljs-string">//raw.githubusercontent.com/DivineEngine/Profiles/master/Surge/Ruleset/China.list, tag=国内网站, force-policy=direct, update-interval=172800, opt-parser=true, enabled=true</span><br></code></pre></td></tr></table></figure><h3 id="filter_local">[filter_local]</h3><p>本地分流规则(对于完全相同的某条规则，本地的将优先生效)</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">;host,</span> <span class="hljs-string">www.google.com, proxy</span><br><span class="hljs-attr">host-keyword,</span> <span class="hljs-string">adsite, reject</span><br><span class="hljs-attr">;host-suffix,</span> <span class="hljs-string">googleapis.com, proxy</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># ip 规则</span><br><span class="hljs-attr">ip-cidr,</span> <span class="hljs-string">10.0.0.0/8, direct</span><br><span class="hljs-attr">ip-cidr,</span> <span class="hljs-string">127.0.0.0/8, direct</span><br><span class="hljs-attr">ip-cidr,</span> <span class="hljs-string">172.16.0.0/12, direct</span><br><span class="hljs-attr">ip-cidr,</span> <span class="hljs-string">192.168.0.0/16, direct</span><br><span class="hljs-attr">ip-cidr,</span> <span class="hljs-string">224.0.0.0/24, direct</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#ipv6 规则</span><br><span class="hljs-attr">;ip6-cidr,</span> <span class="hljs-string">2001:4860:4860::8888/32, direct</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 已采用 ip 池数据，因此注释掉 geoip cn</span><br><span class="hljs-attr">;geoip,</span> <span class="hljs-string">cn, direct</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#不在上述规则中(远程以及本地)的剩余请求，将走final 指定的节点/策略，这里是直连</span><br><span class="hljs-attr">final,</span> <span class="hljs-string">direct</span><br></code></pre></td></tr></table></figure><h2 id="重写">重写</h2><h3 id="rewrite_remote">[rewrite_remote]</h3><p>远程重写模块，内包含主机名hostname以及重写规则</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">https</span>:<span class="hljs-string">//raw.githubusercontent.com/DivineEngine/Profiles/master/Quantumult/Rewrite/Block/Advertising.conf, tag=神机去广告, update-interval=172800, opt-parser=true, enabled=true</span><br><br><span class="hljs-attr">https</span>:<span class="hljs-string">//raw.githubusercontent.com/app2smile/rules/master/module/bilibili-qx.conf, tag=Bilibili去广告, update-interval=172800, opt-parser=false, enabled=false</span><br><br><span class="hljs-attr">https</span>:<span class="hljs-string">//raw.githubusercontent.com/Orz-3/QuantumultX/master/TikTok.conf, tag=Tiktok解锁, update-interval=172800, opt-parser=false, enabled=true</span><br></code></pre></td></tr></table></figure><h3 id="rewrite_local">[rewrite_local]</h3><p>#支持本地/iCloud的复写规则文件，位于Quantumult X/Profiles路径下</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">;rewrite.txt,</span> <span class="hljs-string">tag=本地复写, opt-parser=false, enabled=false</span><br></code></pre></td></tr></table></figure><h2 id="task_local">[task_local]</h2><p>包含3种类型: cron 定时任务，UI交互脚本，网络切换脚本</p><ol type="1"><li><p>任务模块，可用于签到,天气话费查询等js文件放于iCloud或者本机的Quantumult X/Scripts路径下。TF版本可直接使用远程js链接 <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 每天 12 点 2 分，自动执行一次;</span><br><span class="hljs-comment"># tag参数为 task 命名标识;</span><br><span class="hljs-comment"># img-url参数用于指定 task 的图标(108*108)</span><br><span class="hljs-attr">2</span> <span class="hljs-string">12 * * * https://raw.githubusercontent.com/crossutility/Quantumult-X/master/sample-task.js, tag=远程示范(点击缓存/更新脚本), enabled=false, img-url=https://raw.githubusercontent.com/crossutility/Quantumult-X/master/quantumult-x.png</span><br></code></pre></td></tr></table></figure></p></li><li><p>UI交互查询脚本示范，在首页长按 节点/策略组 唤出<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">event-interaction</span> <span class="hljs-string">https://raw.githubusercontent.com/KOP-XIAO/QuantumultX/master/Scripts/streaming-ui-check.js, tag = 流媒体 - 解锁查询，img-url=checkmark.seal.system, enabled=true</span><br></code></pre></td></tr></table></figure></p></li><li><p>网络切换/变化时 触发的脚本类型 <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">;event-network</span> <span class="hljs-string">sample-taks.js</span><br></code></pre></td></tr></table></figure></p></li></ol><h2 id="http_backend">[http_backend]</h2><p>BoxJS访问地址设定为 http://boxjs.com:9999/</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">https</span>:<span class="hljs-string">//raw.githubusercontent.com/chavyleung/scripts/master/chavy.box.js, host=boxjs.com, tag=BoxJS, path=^/, enabled=true</span><br></code></pre></td></tr></table></figure><h2 id="mitm">[mitm]</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">;skip_validating_cert</span> = <span class="hljs-string">false</span><br><span class="hljs-attr">;force_sni_domain_name</span> = <span class="hljs-string">false</span><br><span class="hljs-attr">//以下为证书参数，可去UI界面自行生成并安装证书，会在此生成对应信息</span><br><span class="hljs-attr">;passphrase</span> = <span class="hljs-string"></span><br><span class="hljs-attr">;p12</span> = <span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h2 id="reference">Reference</h2><p><ahref="https://www.notion.so/Quantumult-X-1d32ddc6e61c4892ad2ec5ea47f00917">QuantumultX 不完全教程</a></p><p><ahref="https://www.nutgeek.com/quantumultxs-simple-tutorial/">速看，针对小白QuantumultX的简单上手教程！| 坚果极客 (nutgeek.com)</a></p><p><ahref="https://github.com/erdongchanyo/Rules/tree/main/QuantumultX">erdongchanyo/Rules</a></p><p><ahref="https://github.com/KOP-XIAO/QuantumultX/blob/master/QuantumultX_Profiles.conf">KOP-XIAO配置说明</a></p><p><ahref="https://github.com/Orz-3/QuantumultX">Orz-3/QuantumultX</a></p>]]></content>
    
    
    <categories>
      
      <category>瞎折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>科学上网</tag>
      
      <tag>IOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo建站小记</title>
    <link href="/2021/09/10/020bf26e7182.html"/>
    <url>/2021/09/10/020bf26e7182.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>九月十日，建站小记。开学事情不算多，在这个还未适应学习的时间，得找一些事情来避免这段时间被浪费掉，正好搞个blog，有兴趣，也不算完全浪费时间。博客基本已经不被大众使用了，还在使用的多半都是些it从业者，不知为何我会喜欢一些逐渐被人们抛弃的东西，很久之前就想搞一个博客，也尝试过用wordpress，直接用的模板，最后也没有在上面坚持写字。现在这个blog陆陆续续花了一周的时间，虽然hexo系统建立博客已经相当简单了，一个是没有基础比较愚笨（随着年龄增长越发觉得自己智商低于平均值），另一个原因是把next的很多特性都折腾了一下。<span id="more"></span>折腾了很多，最后其实样式也和官方的差不多，没有设计能力不敢大改，生怕搞出个乡村非主流，所以只能在官方的基础上修改吧。大佬们的博客很漂亮，奈何技术能力不足，尝试过模仿最后还是四不像。试了很多发现还是next主题最漂亮，简洁。我是一个不容易坚持的人，所以不敢轻易期望能够坚持什么，也是这样，凡是我认为能够坚持的一般也不会放弃。博客应该还是能够坚持下来的，因为有记录的需求。记录一些学习的成果问题，和一些想说的话。</p><h2 id="更新日志">更新日志</h2><ul><li>开启评论系统<ul><li><p>https://artitalk.js.org/doc.html</p></li><li><p>https://twikoo.js.org/</p></li></ul></li><li>换成Fluid主题<ul><li><div>            <input type="checkbox" disabled >: 文章url使用hash值          </div></li></ul></li><li>插件安装<ul><li><div>            <input type="checkbox" disabled >hexo-math: 公式 https://github.com/hexojs/hexo-math          </div></li></ul></li></ul><h2 id="quick-start">Quick Start</h2><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="参考">参考</h2><ul><li><a href="https://theme-next.js.org/docs/">Documentation |NexT</a></li><li>https://blog.51cto.com/search/user?uid=13630625&amp;q=hexo</li><li><a href="https://www.mintimate.cn/">Mintimate's Blog</a></li><li><a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册(fluid-dev.com)</a></li><li><a href="https://amnesia-f.vercel.app/">Amnesia's blog</a></li><li><a href="https://blog.zhheo.com/">张洪Heo -分享设计与科技生活</a></li><li><a href="https://shoka.lostyu.me/">Yume Shoka</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
